{-
例は32文字からなる。
10000回繰り返すと320,000文字になる。

0303673_2577212944063491565474664

320000
303673
これはリストのごく後半だけを考えればよいことを示している。
x番めの要素を計算するには、x-1個を読み飛ばし、x個を足し、x個を読み飛ばし、x個を引き、…なのだが、
中央よりも右にあるということは、「x個を足し」の途中で終わってしまうということである。
この「x個を足し」の先頭は、まさに自分自身。自分より右の値を全て足すということ。
それは、ひとつ右の要素を計算するために求めた和に、自分を足せば計算できる。
初めにリストを逆順にしておいて、前から求めると早いだろう。

input.txtの長さは650文字。
6500000
5971751
オフセットと比較すると、やはり仮定が適用できる。
-}

import Data.Char

sample4 = "03036732577212944063491565474664"
sample5 = "02935109699940807407585447034323"
sample6 = "03081770884921959731165446850517"
input = "59717513948900379305109702352254961099291386881456676203556183151524797037683068791860532352118123252250974130706958763348105389034831381607519427872819735052750376719383812473081415096360867340158428371353702640632449827967163188043812193288449328058464005995046093112575926165337330100634707115160053682715014464686531460025493602539343245166620098362467196933484413717749680188294435582266877493265037758875197256932099061961217414581388227153472347319505899534413848174322474743198535953826086266146686256066319093589456135923631361106367290236939056758783671975582829257390514211329195992209734175732361974503874578275698611819911236908050184158"

part2 :: String -> Int
part2 xs = foldr f 0 $ take 8 $ drop ((n - offset) - 8) $ (!! 100) $ iterate step initsignal
  where
    n = 10000 * length xs
    offset = read $ take 7 xs
    initsignal = concat $ replicate 10000 $ reverse $ map digitToInt xs
    step = map (flip mod 10) . scanl1 (+)
    f d r = d + 10 * r

{-
*Main> part2 sample4
84462026
*Main> part2 sample5
78725270
*Main> part2 sample6
53553731
*Main> part2 input
77247538
-}