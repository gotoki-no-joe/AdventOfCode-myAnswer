{-
まず、ファイルを読んで、行番号をキーにして、名前、スコア、接続先を配列に入れる。
単純に考えると、AAから深さ優先探索で全探索することになる感じだけど、60ノードでそれをやると、
ちょっと間に合わないような気がするんだが。
通過済みの辺を再度通過して、残してきたバルブを後で開けることには何の意味もないから、
通過した辺は無くしていい。
いいだろうか？

a   d
 >-<
c   b
こんなグラフで、
abcdと空けるとa(t-2)+b(t-6)+c(t-10)+d(t-14) = B
acbdと空けるとa(t-2)+c(t-5)+b(t-9)+d(t-12) = A
A-B = 5c - 3b + 2d = 5c + 2d - 3b
5c + 2d > 3b が A>B の条件。つまり逆転しうるから、辺は消せない。oops.

現在のノード、現在の時刻、バルブの状況、ここまでのスコア、を引数にして、
時刻30に至ったときのスコアのリストを返す
だと、やることがなくてウロウロしまくる状況の10*2^10、または60*2^60とおりの場合を調べることになって無理。

全てのノードを1度以上通る経路を求めて、バルブを空けずにスルーする場合も含めて経路ごとに最大スコアを求める感じか。

ハミルトン経路とかそういう話ではないんだな。
もしそれがあればそれが最適になりそうだけども。

「無駄のない経路」を考える。
ある頂点にいるとき、訪問済みの頂点のみを辿って到達できる未訪問の頂点それぞれについて、
最短経路を幅優先探索で調べて、その経路で訪問して、続ける。
この方法で深さ優先探索すれば、全ての「無駄のない経路」を発見できる。

次に、それぞれの経路に関して、バルブに到達したとき、1分かけて開けるか、開けずに放置するかを選んで、
残り時間ごとに最高スコアを管理して、30分経つか経路を消化するまでかのスコアを算出して、最大値を見つける。
なんか急に面倒くさいな。でもそろそろそんな感じかな。

訪問済みのフラグをbitでやれば、mutable arrayも使わずに作れるな、多分。
rateが0なノードは初めから訪問済み、というか訪問不要で扱う。

吐き出す経路は[Int]で、正の数が経路の距離、負の数がそのノードのバルブのレート。
それとも、経路を探すのと同時に実行するか？いや、タイムリミットの問題もあるからなぁ。

-}

import qualified Data.Map as M
import Data.Array
import Data.Char
import Data.List
import Data.Bits

phase1 fn = do
  ls <- lines <$> readFile fn
  let bnds = (0, pred $ length ls)
  let cc2i = M.fromList $ zip (map ((!! 1) . words) ls) [0..] -- 名前->番号
  let ra = listArray bnds $ map (read . takeWhile isDigit . tail . dropWhile ('=' /=)) ls :: Array Int Int -- レート
  let ea = listArray bnds $ map (map ((cc2i M.!) . take 2) . tail . dropWhile (not . isPrefixOf "valve") . words) ls -- 接続先
  print (cc2i, ra, ea)
