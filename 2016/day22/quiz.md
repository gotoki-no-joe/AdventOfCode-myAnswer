# 22日目：グリッドコンピューティング #

格子状に配置された大規模なストレージクラスターへのアクセス権を得ました。各ストレージノードは、それに直接隣接する4つのノードにのみ接続されています。（ノードが辺にある場合は3つ、角にある場合は2つ）

ノード `/dev/grid/node-x0-y0` でのみデータに直接アクセスできますが、他のノードでいくつかの制限されたアクションを実行できます。

- （dfを介して）全てのノードのディスク使用量を取得できます。これを行った結果が、あなたのパズル入力になります。
- すべてのデータを隣接ノードに移動する（コピーではない）ようにノードに指示できます。このとき、宛先ノードにデータを受信するのに十分な空き容量が必要です。この操作の後、送信ノードは空になります。
- ノードはその位置によって名前が付けられています。名前 `node-x10-y10` が付けられたノードは、ノード `node-x9-y10`, `node-x11-y10`, `node-x10-y9`, `node-x10-y11` に隣接しています。

始める前に、これらのノード上のデータの配置を理解する必要があります。直接接続されたノード間でのみデータを移動できますが、必要なデータにアクセスするには、多くのデータを再配置する必要があります。したがって、データをどのように移動させられるかを理解する必要があります。

これを行うには、実行可能なノードのペアの数を数えます。実行可能なペアは、直接接続されているかどうかに関係なく、次のような任意の2つのノード（A、B）です。
(viable?)

- ノードAは空ではありません。（その Used が0ではありません。）
- ノードAとBは同じノードではありません。
- ノードAのデータ（AのUsed）はノードBに適合します（BのAvail以下？）。

実行可能なノードのペアはいくつありますか？

# パート2 #

グリッドについての理解が深まったので、次は作業に取り掛かります。

あなたの目標は、yは0でxが最大のノード（つまり右上隅のノード）のデータにアクセスすることです。
(starts?)

たとえば、次のグリッドがあるとします。

```
Filesystem            Size  Used  Avail  Use%
/dev/grid/node-x0-y0   10T    8T     2T   80%
/dev/grid/node-x0-y1   11T    6T     5T   54%
/dev/grid/node-x0-y2   32T   28T     4T   87%
/dev/grid/node-x1-y0    9T    7T     2T   77%
/dev/grid/node-x1-y1    8T    0T     8T    0%
/dev/grid/node-x1-y2   11T    7T     4T   63%
/dev/grid/node-x2-y0   10T    6T     4T   60%
/dev/grid/node-x2-y1    9T    8T     1T   88%
/dev/grid/node-x2-y2    9T    6T     3T   66%
```

この例では、3行3列のストレージグリッドがあります。
直接アクセスできるノード`node-x0-y0`は、ほぼ満杯です。
アクセスしたいデータを含むノード`node-x2-y0`（yは0でxは最大値です）には、6テラバイトのデータが含まれています。
これはノード`node-x0-y0`に収まるサイズですが、それをここまで移動させるだけの十分なスペースを確保できる必要があります。

幸い、`node-x1-y1`はこのデータを移動するのに十分な空き容量があるようです。
(some of?)
実際、すべてのノードには、任意のノードのデータを保持するのに十分な容量があるようです。
（ただし`node-x0-y2`は除きます。
これははるかに大きく、ほぼいっぱいで、移動できません。）
(soon?)
したがって、最初は、グリッドの容量と接続は次のようになっています。

```
( 8T/10T) --  7T/ 9T -- [ 6T/10T]
    |           |           |
  6T/11T  --  0T/ 8T --   8T/ 9T
    |           |           |
 28T/32T  --  7T/11T --   6T/ 9T
```

直接アクセスできるノードは丸括弧で示しています。
必要なデータは、角括弧で示したノードにあります。

この例では、ほとんどのノードは交換可能です。
それらノードは、他のノードのデータが収まらないほど十分にいっぱいですが、データを移動できるほど十分に小さいです。
(???)
これらのノードを `.` で図示しましょう。
例外は `_` と図示する空のノードと、`#` と図示する非常に大きく、ほぼいっぱいのノードです。
また、目標データを `G` と図示しましょう。
すると次のようになります。

```
(.) .  G
 .  _  .
 #  .  .
```

目標は、右上のデータGを括弧のノードに移動することです。
これを行うには、グリッドにいくつかのコマンドを発行して、データを再配置します。

- データを`node-y0-x1`から`node-y1-x1`に移動し、ノード`node-y0-x1`を空にします。
```
(.) _  G
 .  .  .
 #  .  .
```
- 目標データを`node-y0-x2`から`node-y0-x1`に移動します：
```
(.) G  _
 .  .  .
 #  .  .
```
この時点で、私たちはかなり目標に近づいています。
けれど、削除コマンドはないため、さらにデータを移動する必要があります。
そこで次に、データを`node-y1-x2`から`node-y0-x2`に移動します。
```
(.) G  .
 .  .  _
 #  .  .
```
- データを`node-y1-x1`から`node-y1-x2`に移動します：
```
(.) G  .
 .  _  .
 #  .  .
```
- データを`node-y1-x0`から`node-y1-x1`に移動します：
```
(.) G  .
 _  .  .
 #  .  .
```
- 次に、データを`node-y0-x0`から`node-y1-x0`に移動することで、ノードの容量を空けられます。
```
(_) G  .
 .  .  .
 #  .  .
```
- 最後に、私たちは、`node-y0-x1`から`node-y0-x0`へそれを移動することで、目標データにアクセスすることができます：
```
(G) _  .
 .  .  .
 #  .  .
```

したがって、7手順を実行した後、必要なデータにアクセスしました。
残念ながら、これらの操作はそれぞれ時間がかかるので、効率的に行う必要があります。

目標データを`node-x0-y0`に移動するために必要な最小のステップ数はいくつですか？
