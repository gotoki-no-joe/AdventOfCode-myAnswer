{-
答えるのに必死だったか、コードが残っていないので復刻する。
-}

input = 3014387

-- 最初は、[1..input] をゴリゴリ回して解いた覚えがある。
-- プログラミングパズルなので解ければそれでもいいけれど、
-- もう少し賢くやってみよう。

{-
最初は1番から始めるので、偶数が全滅する。奇数だけ生き残る。
最初の人数が偶数だった場合、ちょうど終わって、また次もそうなる。
最初の人数が奇数だった場合、最後の一人が、次の周回の先頭を消して、偶数だけが生き残る場合になる。

n人めが残った、という答えに対して、0または1を下の桁に追加して返せばよい。

うまくいかないので、もう少し考える

0からn-1までの番号がついているとする。つまり1少ない

前の周がちょうどで終わったとき、今回の周ではb0=0なものだけが残る。
それは、前の前の周がちょうどで終わり、前の周が偶数人であったか、
前の前の周が一人余り、前の周が奇数人である場合。

前の周が一人余って終わったとき、今回の周ではb0=1なものだけが残る。
こんなややこしいこと考えるより、計算機回した方が早いな、と思ってしまうのはダメなのだろうか。

-}

q1 n = div (q1iter False n) 2

-- o : 前は奇数人だったか
-- n : 今回の人数

q1iter b 1 = if b then 1 else 0
q1iter b n = q1iter (odd n) (div (succ n) 2) * 2 + if b then 1 else 0
