-- 2025-1-20 for spoiler

-- 素朴にシミュレーション

import qualified Data.Sequence as Q
import Data.Bits
import Debug.Trace

sample, input :: Int
sample = 5
input = 3014387

part1a n = loop $ Q.fromList [1 .. n]
  where
    loop (a Q.:<| _ Q.:<| q) = loop (q Q.:|> a)
    loop (a Q.:<| Q.Empty) = a

{-
プレゼントの内容は無視して、生き残っている人だけ追跡する。
注目している位置の二人のうち、盗む方は残り、盗まれた方は次に自分の番が回ってきて抜けることになる。
-}

{-
ghci> test1
3
(0.02 secs, 62,352 bytes)
ghci> main1
1834471
(3.54 secs, 2,533,139,432 bytes)
-}

{-
ループ状の構造は、遅延参照を使ったリストでも表現できる。
ただし、現在の要素数を別で管理していないと、要素がなくなった瞬間がわからなくて困る。
1ステップ処理するたびに一人抜けるので、のこり人数が1になったら止めればよい。
（これが以前の、しかし復刻時のやり方）

この問題の場合は、aと次が同一人物であるとき、もうその人しか残っていないことでも検出できる。
と思ったんだけどナァ。
loop = iter ([1,2,3] ++ loop)
= 1 : iter ([3] ++ loop)
= 1 : iter ([3,1] ++ drop 1 loop)
= 1 : 3 : iter ([3] ++ drop 2 loop)

こうなって、[3]の次の要素は iter 自身の返り値なので無限ループに陥る、という仕掛けだ。
-}

part1b n = last loop
  where
    loop = iter n ([1 .. n] ++ loop)
    iter 1 (a:_) = [a]
    iter k (a:_:as) = a : iter (pred k) as

{-
ghci> part1a sample
3
(0.00 secs, 62,296 bytes)
ghci> part1a input
1834471
(3.51 secs, 1,543,437,688 bytes)
-}

{-
命令型言語なら、リングバッファに1～nを書いておき、二つ消しては前方を後ろに追加、
を繰り返す感じに書けば、O(n)で同じように答えに至る。


解析しようとして、挫折した感じの記録が残っている。

1始まりで考えて、

1番めから始まるとき、
(A) 列の長さが偶数のとき、偶数番目が抜けてちょうどで終わる。また1番めから始まる。
列の長さが奇数のとき、偶数番目が抜けて、末尾の奇数番目の番になる。次の周回は、消えるのは奇数番目になる。

前の周が奇数だったせいで、0番めから始まるとき、
列の長さが偶数のとき、奇数番目が抜けて、末尾が余って終わる。また0番めから始まる。
列の長さが奇数のとき、奇数番目が抜けてちょうどで終わり、次は1番目から始まる。

これ、番号を2進数で書くと、…をするには0始まりで考えないとだめで逆になるけどこらえて、
(A) は aaa0 の人が残って aaa1 が全員抜ける
(B) は aaa0 の人が残って、最後の 1110 のひとは順番が回ってきていない、という形

これによって、最下位ビットが確定する。
それ以降の周回でも、下位ビットが順にどっちなのか定まって、

前回が偶数のとき、1が抜ける（その桁のビットは0と決まる）、奇数のとき、0が抜ける（その桁のビットは1と決まる）
今回が奇数か偶数かは、末尾の番号のビットと、前回がどうだったかのxorで決まる

といっても、バグらせないで作るのは難しそうだ。
というのも、末尾の値が消えてしまうとき、一つ前の最大値に戻る必要があるから。
単に1引けばいいのか。

0始まりで考える。
0は偶数、と考える。

今回の列の一人目から始まるとき、
偶数番目が残り、奇数番目が抜ける。
末尾が偶数番のとき、その人の番が来ていないので、次は0人め（この人）の番から始まる。
末尾が奇数番のとき、ちょうど終わったので、次も1人めから始まる。末尾の人の番号を1減らして考える。
この桁について、ビットは0とすることが確定する。

残った人の全員の番号を1ビット右シフトして、同じゲームを繰り返す。

ただし、0人めから始まる、というイレギュラーがある。
0人めから始まるとき、
偶数番めが抜けて、奇数番目が残る。この桁のビットは1とすることが確定する。
最後の人が0のとき、その人がぬけて終わったので、次は1人めから始まる普通ゲームになる。末尾の人の番号は1減らした前の人にする。
最後の人が1のとき、その人が残ったので、また、0人めから始まるイレギュラーゲームになる。

最大の番号が0になったとき、つまりその人しかいないので、ゲーム反復終了。
確定したビットを並べると答えになる。
ただし0始まりなので+1して真の答えにする。

整理すると、

前回の結末から、今回の桁の残る側のビットが決まる。
なのでそれを持ち上げることにする。

末尾の番号が、残る方だったとき、次回は1が残る。
消える方だったとき、次回は0が残り、このとき、末尾の番号を1減らしてから続ける。
-}

part1c n = succ $ loop 0 (pred n)
  where
    loop _ 0 = 0 -- 末尾の番号が0なら、唯一なので終わり
    loop b k -- 今回の桁はb
      | b == r    = b + 2 * loop 1 q
      | otherwise = b + 2 * loop 0 (q - b) -- r=0(b=1)ならqを減らす
      where
        (q,r) = divMod k 2 -- 末尾の最下位ビットとそれ以外

{-
5 = 101
3 = 011 -- 正解

3014387 = 1011011111111011110011
1834471 = 0110111111110111100111  -- 正解
1833479 = 0110111111101000000111  -- 盛大にバグった

末尾の番号で考える
1011011111111011110010
0110111111110111100110  -- 正解
0110111111101000000110  -- 盛大にバグった

1011011111111011110010
..................0110
1011011111111011101


b=0, r=0 のとき b' = 1, k' = q
b=0, r=1 のとき b' = 0, k' = q -- -1しないでも0はそこにいる！
b=1, r=1 のとき b' = 1, k' = q
b=1, r=0 のとき b' = 0, k' = q-1
-}

{-
MSBを0にして左1ビットシフトして1を足す、の計算をする
-}

msb :: Int -> Int -- 64bit only
msb x = loop 32 x
  where
--    loop b x | traceShow (b,x) False = error ""
    loop _ 1 =  1
    loop b x
      | x1 == 0   = loop (b .>>. 1) x
      | otherwise = loop (b .>>. 1) x1 .<<. b
      where
        x1 = x .>>. b

part1d n = succ $ (msb n .^. n) .<<. 1

--- パート2

part2a n = loop (even n) (Q.fromList [1 .. m]) (Q.fromList [succ m .. n])
  where
    m = div n 2
    loop False Q.Empty    (a Q.:<| Q.Empty) = a
    loop True  (a Q.:<| q) (_ Q.:<| r)         = loop False q          (r Q.:|> a)
    loop False (a Q.:<| q) (_ Q.:<| b Q.:<| r) = loop True (q Q.:|> b) (r Q.:|> a)

part2b n = loop (even n) $ Q.fromList $ [succ m .. n] ++ [1 .. m]
  where
    m = div n 2
    loop False (a Q.:<| Q.Empty) = a
    loop True  (_ Q.:<| q) = loop False q
    loop False (_ Q.:<| b Q.:<| q) = loop True (q Q.:|> b)

part2b1 n
  | n < 3  = 1
  | even n    = loop $ Q.fromList $ [m+2 .. n] ++ [1 .. m]
  | otherwise = loop $ Q.fromList $ [succ m .. n] ++ [1 .. m]
  where
    m = div n 2
    loop :: Q.Seq Int -> Int
    loop q
      | Q.null q1 = Q.index q 1
      | otherwise = loop $ q1 Q.:|> Q.index q 1
      where
        q1 = Q.drop 3 q

part2c n = last loop
  where
    m = div n 2
    loop = iter n ([m+1..n] ++ [1..m] ++ loop)
    iter 1 (x:_) = [x]
    iter n (_:xs)
      | even n = iter (pred n) xs
    iter n (_:y:xs)
               = y : iter (pred n) xs
