{-
「どの」っていうのは、0番からの番号でいえばいいのかね。
というか、「長期的に」がすごくふわっとしていて、どうやって判断したらいいのだ。

とりあえずファイルを読み込もう。
-}

import Data.List
import qualified Data.Map as M

type Point = (Int,Int,Int)
type Particle = (Point,Point,Point)

cutAt :: Char -> String -> (String,String)
cutAt c xs = span (c /=) xs

parseLine :: String -> Particle
parseLine xs = ((read pxs, read pys, read pzs),(read vxs, read vys, read vzs),(read axs, read ays, read azs))
  where
    (pxs,_:xs1) = cutAt ',' $ drop 3 xs
    (pys,_:xs2) = cutAt ',' xs1
    (pzs,_:xs3) = cutAt '>' xs2
    (vxs,_:xs4) = cutAt ',' $ drop 5 xs3
    (vys,_:xs5) = cutAt ',' xs4
    (vzs,_:xs6) = cutAt '>' xs5
    (axs,_:xs7) = cutAt ',' $ drop 5 xs6
    (ays,_:xs8) = cutAt ',' xs7
    (azs,_    ) = cutAt '>' xs8

closest :: [Particle] -> Int
closest ps = snd $ minimum [(abs x + abs y + abs z, i) | (((x,y,z),_,_),i) <- zip ps [0..]]

tick = map tickfun

tickfun ((px,py,pz),(vx,vy,vz),(ax,ay,az)) = ((px1,py1,pz1),(vx1,vy1,vz1),(ax,ay,az))
  where
    (vx1,vy1,vz1) = (vx+ax, vy+ay, vz+az)
    (px1,py1,pz1) = (px+vx1, py+vy1, pz+vz1)

run1 :: [Particle] -> [Int]
run1 ps = closest ps : run1 (tick ps)

main1 = do
  co <- readFile "input.txt"
  let pvas = map parseLine $ lines co
  print $ run1 pvas

{-
単にずーっと走らせて、変わらなくなった番号を答えてみた。
*Main> main1
[270,270,270,270,270,269,269,269,269,268,264,269,293,143,206,195,3,91,198,153,
155,56,62,123,113,25,84,285,250,202,17,49,283,146,69,29,27,187,280,36,36,36,36,
36,36,36,36,36,36,36,36,36,36,36,36,36,36,285,285,285,285,285,285,285,285,285,
285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,
285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,
285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,285,
285,285,285,285,285,285,285,285,285,285,285,285,251,251,251,251,251,251,251,251,
251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,
251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,
251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,
251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,
251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,
251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,
251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,
251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,
251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,251,
251,251,251,251,150, 以降変化なし、で150
-}

{-
初期状態1000個の粒子の衝突を調べるのに1000*1000の計算をするのはおぞましいから、
ゲームとかだと象限に区切って問題を小さくするのだよね。
<0,0,0>からの距離で輪切りにしたらよさそうだ。今回は番号もいらない。
そしてまた、残り粒子の個数が変化しなくなりそうなところまで、目で観察しよう。
イジワルが仕込んであるかもしらんけど。

と思ったけど、Data.Mapで力押しするか。
-}

run2 :: [Particle] -> [Int]
run2 ps = length ps : (run2 $ tick $ collide ps)

collide ps = concat $ filter singleton $ M.elems m
  where
    m = M.fromListWith (++) [(pos,[p]) | p@(pos,_,_) <- ps]

singleton [_] = True
singleton _ = False

main2 = do
  co <- readFile "input.txt"
  let pvas = map parseLine $ lines co
  print $ run2 pvas

{-
*Main> main2
[1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,1000,979,972,956,948,936,936,924,900,
886,886,871,845,845,836,826,803,787,777,765,755,743,739,737,724,717,717,701,688,685,657, 以降変化なし
-}
