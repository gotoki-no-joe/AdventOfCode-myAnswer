# 23日目：コプロセッサ炎上 #

CPUに直接向かい、そこからプリンタを修正することにしました。

近づくと、実験的コプロセッサが非常に多くの作業を行っているため、停止して発火するのではないかとローカルプログラムたちが心配しています。
これはコンピュータの残りの部分に深刻な問題を引き起こすので、あなたは首を突っ込んで何かできるか見てみることにしました。

コプロセッサが実行中のコードは、タブレットで最近見た種類の変種のようです。
一般的な機能は非常に似ているように見えますが、いくつかの命令は違っています。

- `set X Y` レジスタXをYの値に設定します。
- `sub X Y` レジスタXをYの値だけ減らします。
- `mul X Y` レジスタXに含まれる値にYの値を掛けた結果にレジスタXを設定します。
- `jnz X Y` Yの値が零でない場合に限り、Xの値のオフセットでジャンプします。（2のオフセットは次の命令をスキップし、-1のオフセットは前の命令にジャンプします。）

上記の命令のみが使用されます。
`a`から`h`の名前の8つのレジスタがあり、すべて0で開始します。

コプロセッサーは現在、ある種のデバッグモードに設定されています。
これにより、テストは可能になりますが、意味のある作業を実行できなくなります。

プログラム（パズル入力）を実行すると、`mul`命令は何回呼び出されますか？

# パート2 #

さて、問題を修正する時が来ました。

デバッグモードのスイッチはレジスタ`a`に直接配線されています。
あなたはスイッチを切り替え、これによりプログラムは実行されるときレジスタ`a`の値は1で始まります。

たちまち、コプロセッサは過熱し始めます。
このプログラムを書いたのが誰か知りませんが、明らかに非常に効率的な実装を選択しませんでした。
サンタがそのプリンタを必要とする前に計算を完了させるために、あなたがこのプログラムを最適化する必要があります。

コプロセッサの最終的な目標は、プログラムが完了したときにレジスタ`h`に残っている最終値を決定することです。
技術的には、その値さえ得られるなら、プログラムを実行する必要すらありません。

レジスタ`a`を1に設定した後、プログラムが最後まで実行された場合、レジスタ`h`にはどのような値が残されますか？
