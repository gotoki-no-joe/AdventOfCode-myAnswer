時計を逆回しにして、
50,000,001要素の不明の箱の列のどこかに、50,000,000の値を書き込み、
そこからパズル入力ぶんだけ、まだ不明な箱を戻り、そこに49,999,999を書き込み、
...最後に1を書き込み、残った枠が0なので、その直後の値が求める答え。

しかしこれを配列でやると大変なことになる。最初はいいが、そのうちに、読み飛ばすマスばかりになってしまう。
双方向リンクリストにして、最後に0の次を見るのに順方向リンクをそのままにし、
書き込んだマスは飛ばすために逆方向リンクは付け替えていく、というやり方はどうか。
メモリが大変必要になる感じだけど。

常時辿る逆方向リンクを「付け替える」ためには、書き込むマスの一つ前のマスを残しておかないと、順方向リンクではO(1)で戻れないことに注意。

書き込まれたマスが連続したとき、その先頭以外は捨てて構わない。
これをするには、「位置的に前のマス」と「一つ手前の空欄のマス」を別に管理する必要があるな。

配列で模倣するなら、前後の要素への参照は添え字で計算できる。
書き込まれた値と、手前の空きマスへの添え字の二つだけを管理すればよい。

値配列は、初期値undefined。決まったものが書き込まれるだけ。
前のマス配列は、0->50,000,000, k->k-1 が初期値。
排他的なので、負の値で書き込みを行うと、配列が一つでよくなる。

辿ってきて、一つ手前のマスがy、書き込むべきマスがxだとして、
A[x] >= 0 を確認する。さもなくば何かバグっている。
A[y] := t := A[x] これで、yの手前がxからxの手前にすり替わる。
A[x] := -k これで、xの値が確定した。
k = 1 なら、tが0の入る位置。さもなくば、tからまたinputだけ戻る手順を繰り返す。

JSで書いてnodeで実行。
落ちないということは配列は張れているようだ。
しかし時間はかかる。
