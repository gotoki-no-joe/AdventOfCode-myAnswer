# 第10日目：結び目ハッシュ #

結び目に基づいたハッシュのソフトウェアエミュレーションを
実装しようとしているいくつかのプログラムと遭遇しました。
これらのプログラムが実装しているハッシュはそれほど強力ではありませんが、
あなたはともかくそれらを助けることに決めました。
妖精たちが後に独自の暗号機能を発明しないように(?)
頭の中でメモをしました。

このハッシュ関数は、
256個の印の付いたひもでできた輪の結び目をシミュレートします。
ハッシュ対象の入力に基づいて、
関数は繰り返しひものある区間を選択し、
両端をまとめて区間を半回転させ、その区間の印の順序を逆にします。
これを何度も行った後、
結果のハッシュを構築するために印の順序が使用されます。

~~~
  4--5   pinch   4  5           4   1
 /    \  5,0,1  / \/ \  twist  / \ / \
3      0  -->  3      0  -->  3   X   0
 \    /         \ /\ /         \ / \ /
  2--1           2  1           2   5
~~~

これを達成するために、
0から255の数の**リスト**、
**現在位置**（0すなわちリストの先頭要素で始める）、
**スキップサイズ**（0から始まる）、
**長さ**の列（あなたのパズル入力）
で始める。
次に、各長さについて：

- **リスト**の**現在の位置**の要素から始まり**長さ**だけの要素の
順序を**逆**にする。
- **現在位置**を**長さ**と**スキップサイズ**だけ前方に**移動**します。
- **スキップサイズ**を1**増やします**。

**リスト**は環状です。
**現在位置**と**長さ**がリストの末尾を超える要素を逆にしようとした場合は、
リストの先頭から必要なだけ追加の要素を使用して反転させます。
**現在位置**がリストの最後を過ぎて移動した場合は、前方に折り返します。
**リスト**の長さより大きな**長さ**は不正です。

より小さなリストを使用する例を次に示します。

代用として5つの要素0, 1, 2, 3, 4を持つ循環リストがあるとし、
入力の長さ列として3, 4, 1, 5が与えられたとします。

- リストは、`[0] 1 2 3 4`で始まります。
（角括弧が**現在の位置**を示す。）
- 最初の長さは3なので、`([0] 1 2) 3 4`と選択します。
（丸括弧は反転する部分リストを示します。）
- その区間を反転（`0 1 2`を`2 1 0`に）した後、`([2] 1 0) 3 4`を得ます。
- 次に、現在位置が**長さ**の3と**スキップサイズ**の0だけ前進します。
結果は`2 1 0 [3] 4`となります。
最後に**スキップサイズ**を1に増やします。

- 2番目の長さは4なので、折り返される範囲を選択します。`2 1) 0 ([3] 4`
- 部分リスト`3 4 2 1`は`1 2 4 3`に反転されます。`4 3) 0 ([1] 2`
- **現在位置**は**長さ**と**スキップサイズ**の合計5だけ前進し、
そこまで進めないので折り返します。`4 3 0 [1] 2`
- **スキップサイズ**は2に増加します。

- 3番目の長さは1なので、
単一の要素の部分リストを選択し、これを反転することは効果がありません。
- **現在位置**は**長さ**(1)と**スキップサイズ**(2)だけ前進します。
`4 [3] 0 1 2`
**スキップサイズ**は3まで増加します。

- 4番目の長さは5なので、2番目の要素で始まるすべての要素を選択します。
`4) ([3] 0 1 2`
この部分リストを反転する（``3 0 1 2 4`を`4 2 1 0 3`に）と
`3) ([4] 2 1 0`となります。
- 最後に、**現在位置**が前方に8移動します。`3 4 2 1 [0]`。
**スキップサイズ**は4まで増加します。

この例では、リストの最初の2つの数字は3と4で終わります。
プロセスを検査するには、それらを掛け合わせて12を求めます。

（0から255の値の）長さ256の標準リストと、
パズル入力にある**長さ**の列を代わりに使用する必要があります。
このプロセスが完了したとき、
**リストの最初の2つの数字を乗じた結果はいくつですか？**

# パート2 #

上で構築したロジックは、
**結び目ハッシュ**アルゴリズムの1**ラウンド**を成します。
完全なものを実行するには、
これらのラウンドが多数必要です。
入力および出力処理も必要です。

まず最初に、あなたの入力は数のリストではなく、
代わりにバイトの文字列としてとらえる必要がある。
特に指定がない限り、ASCIIコードを使用して文字をバイトに変換します。
これにより任意のASCII文字列を扱うことができ、
入力の「長さ」が決して255より大きくならないことが保証されます。
例えば、あなたが`1,2,3`を与えられたとき
それを各文字のASCIIコードに変換するべきです。
`49,44,50,44,51`

使用する長さの列が定まったら、
その列の末尾に次の長さを追加します。
`17, 31, 73, 47, 23`。
たとえば、`1,2,3`が与えられた場合、
最終的な長さの列は
`49,44,50,44,51,17,31,73,47,23`となります。
これは入力文字列のASCIIコードと標準の長さ接尾辞値を組み合わせたものです。

次に、上でしたように1**ラウンド**を実行するのではなく、
全部で64ラウンドを実行します。
各ラウンドでは同じ**長さ**の列を使用します。
**現在位置**と**スキップサイズ**はラウンド間で保存します。
例えば、前の例があなたの最初のラウンドだったとすると、
あなたの始める第2ラウンドは、
同じ**長さ**列
（`3, 4, 1, 5, 17, 31, 73, 47, 23`、
これらはASCIIコードであると仮定し、接尾辞を含む）
を用いて、
しかし前のラウンドの**現在位置**(4)と**スキップサイズ**(4)
で始めます。

64ラウンドが完了すると、
何らかの順序で0から255の数が並んだリストが手元に残る。
これを**疎なハッシュ**と呼ぶ。
あなたの次の作業は、これらを**密なハッシュ**と呼ばれる
16個の数だけからなるリストに濃縮することです。
これを行うには、
数のビットごとのXORを使用して、
疎なハッシュの16個の数の各連続ブロックを結合します。
（256個の数のリストにはそのようなブロックは16個あります。）
したがって、密なハッシュの最初の要素は、
疎なハッシュの最初の16要素を互いにXORしたものです。
密なハッシュの2番目の要素は、
疎なハッシュの次の16要素を互いにXORしたものです。
以下同様です。

たとえば、あなたの疎なハッシュの最初の16要素が以下に示すようなものであれば、
XOR演算子を`^`とすると、最初に出力する数は次のように計算します。

~~~
65 ^ 27 ^ 9 ^ 1 ^ 4 ^ 3 ^ 40 ^ 50 ^ 91 ^ 7 ^ 6 ^ 0 ^ 2 ^ 5 ^ 68 ^ 22 = 64
~~~

あなたの疎なハッシュ内の16個の数からなる16個のブロックの
それぞれに対してこの操作を実行して、密なハッシュ内の16個の数を決定します。

最後に、結び目ハッシュを表示する標準的な方法は、単一の16進文字列です。
最終的な出力は、16進表記による密なハッシュです。
密なハッシュの個々の数は0と255の間にあるため（端を含む）、
数は常に2桁の16進数（必要に応じて先頭の零を含める）で表します。
したがってもしあなたの最初の3つの数が`64, 7, 255`であれば、
それらは16進数`40, 07, ff`が対応しているので、
ハッシュの最初の6文字は`4007ff`となります。

すべての結び目ハッシュはそのような16個の数なので、
16進表記は常に16進数(0～f)で32桁です。

いくつかのハッシュの例を以下に示します。

- 空文字列は `a2582a3a0e66e6e86e3812dcb672a272` になります。
- `AoC 2017` は `33efeb34ea91902bb2f59c9920caa6cd` です。
- `1,2,3` は `3efbe78a8d82f29979031a4aa0b16a9d` です。
- `1,2,4` は `63960835bcdc130f0b66d7ff4f6a5a8e です。

あなたのパズル入力をASCII文字列として扱うと、
**パズル入力の結び目ハッシュは何ですか？**
遭遇する可能性のある先行または末尾の空白は無視してください。
