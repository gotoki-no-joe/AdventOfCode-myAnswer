# 18日目：デュエット #

ただ「Duet」とラベルの付けられただけの奇妙なアセンブリコードが入れられた含むタブレットを発見しました。
サウンドカードは無視して、自分でコードを実行することにしました。
残念ながら、ドキュメントが見当たらないため、命令の意味を自分で理解する必要があります。

アセンブリは、それぞれが1文字の名前を持ちそれぞれが整数をひとつ保持できるレジスタ群を操作することを目的としているようです。
各レジスタの初期値は0でだろうとあなたは想定しました。

命令はそれほど多くないので、それらが何をするのかを理解するのは難しいことではありません。
あなたが突き止めたことが以下です：

- `snd X` Xの値に等しい周波数で音を鳴らします。
- `set X Y` レジスタXをYの値に設定します。
- `add X Y` レジスタXをYの値だけ増やします。
- `mul X Y` レジスタXに含まれる値にYの値を乗算した結果をレジスタXに設定します。
- `mod X Y` レジスターXをレジスタYに含まれる値で除算した余りにレジスタXを設定します。
- `rcv X` 最後に再生されたサウンドの周波数を回復します。ただしXの値が零でない場合に限ります。（零の場合、このコマンドは何もしません。）
- `jgz X Y` Xの値が零より大きい場合にのみ、Yの値をオフセットとしてジャンプします。
（オフセット2は次の命令をスキップし、-1のオフセットは前の命令にジャンプします。）

多くの命令は、レジスタ（1文字）または数のいずれかを取ることができます。レジスタの値は、レジスタが保持している整数です。数の値はその数値です。

各ジャンプ命令の後、プログラムはジャンプめいれいによりジャンプした先から続行します。他の命令の後、プログラムは次の命令に進みます。次に進んだ先もしくはジャンプ先がプログラムのいずれかの端からはみ出た場合、プログラムは終了します。

例えば：

```
set a 1
add a 2
mul a a
mod a 5
snd a
set a 0
rcv a
jgz a -1
set a 1
jgz a -2
```

最初の4つの命令は、aに1を設定し、それに2を加え、2乗してから、5で割った余りにし、最終的に値は4になります。
次に、周波数4（aの値）のサウンドが再生されます。
その後、aは0に設定されます。これは後続の`rcv`命令と`jgz`命令の両方がスキップされる原因です。（`rcv`についてはaが0であるため、`jgz`についてはaが0より大きくないため）
最後に、aを1に設定すると、次の`jgz`命令がアクティブになり、
ジャンプして2つ前の別のジャンプ命令に戻り、再びジャンプして、`rcv`に行き、回復操作が発動されます。
この回復操作が実行された時点で、最後に再生された音の周波数は4です。

非零値で最初にrcv命令が実行されたときに復元された周波数の値（最後に再生されたサウンドの値）は何ですか？

# パート2 #

上手くやり遂げたと自分をほめていると、ずっとドキュメントがタブレットの背面にあったことに気づきました。
ほとんどの命令を正しく理解しましたが、いくつか重要な違いがありました。
このアセンブリコードは、サウンドに関するものではありません。同時に2つ実行することを目的としています。

実行中のプログラムの各コピーには独自のレジスタセットがあり、個別にコードを実行します。
実際、プログラムは必ずしも同じ速度で実行されるとは限りません。
協調するために、送信(`snd`)および受信(`rcv`)命令を使用します。

- `snd X` Xの値を他方のプログラムに送信します。
これらの値は、そのプログラムが受信する準備ができるまでキューで待機します。
各プログラムには独自のメッセージキューがあるため、プログラムは自分が送信したメッセージを受信しません。
- `rcv X` 次の値を受け取り、それをレジスタXに格納します。
キューに値がない場合、プログラムは値がキューに送信されるのを待ちます。
プログラムは、値を受け取るまで次の命令に進みません。
値は送信された順序で受信されます。

各プログラムは、独自のプログラムID（一方は0でもう一方は1）も持ちます。レジスタpはこの値で始まる必要があります。

例えば：

```
snd 1
snd 2
snd p
rcv a
rcv b
rcv c
rcv d
```

どちらのプログラムも、3つの値を他方に送信することから始まります。プログラム0は1, 2, 0を送信します。プログラム1は1, 2, 1を送信します。
次に、両プログラムは値（どちらも1）を受け取り、それをaに格納し、次の値（どちらも2）を受け取り、それをbに格納します。そして両プログラムは、相手のプログラムのプログラムIDを受け取り（プログラム0は1を受け取る、プログラム1は0を受け取る）、それをcに格納します。
ここで両プログラムは、各自のレジスタcに異なる値を持ちました。

最後に、両方のプログラムは、4回めの`rcv`を試みますが、どちらにも受信を待つデータはなく、デッドロックに至ります。
これが発生すると、両方のプログラムが終了します。

プログラムが異なる速度で実行されてもよいことに注意してください。たとえば、プログラム0が3つの値すべてを送信し、プログラム1が最初の命令を実行する前に最初のrcvで止まることもあります。

（原因に関係なく）両方のプログラムが停止したとき、プログラム1は何回値を送信しましたか？
