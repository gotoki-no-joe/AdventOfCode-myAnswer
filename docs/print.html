<!DOCTYPE HTML>
<html lang="ja" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Advent of Code</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> はじめに</a></li><li class="chapter-item affix "><li class="part-title">問題編</li><li class="chapter-item "><a href="2015/index.html"><strong aria-hidden="true">2.</strong> 2015</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2015/day1.html"><strong aria-hidden="true">2.1.</strong> Day  1</a></li><li class="chapter-item "><a href="2015/day2.html"><strong aria-hidden="true">2.2.</strong> Day  2</a></li><li class="chapter-item "><a href="2015/day3.html"><strong aria-hidden="true">2.3.</strong> Day  3</a></li><li class="chapter-item "><a href="2015/day4.html"><strong aria-hidden="true">2.4.</strong> Day  4</a></li><li class="chapter-item "><a href="2015/day5.html"><strong aria-hidden="true">2.5.</strong> Day  5</a></li><li class="chapter-item "><a href="2015/day6.html"><strong aria-hidden="true">2.6.</strong> Day  6</a></li><li class="chapter-item "><a href="2015/day7.html"><strong aria-hidden="true">2.7.</strong> Day  7</a></li><li class="chapter-item "><a href="2015/day8.html"><strong aria-hidden="true">2.8.</strong> Day  8</a></li><li class="chapter-item "><a href="2015/day9.html"><strong aria-hidden="true">2.9.</strong> Day  9</a></li><li class="chapter-item "><a href="2015/day10.html"><strong aria-hidden="true">2.10.</strong> Day 10</a></li><li class="chapter-item "><a href="2015/day11.html"><strong aria-hidden="true">2.11.</strong> Day 11</a></li><li class="chapter-item "><a href="2015/day12.html"><strong aria-hidden="true">2.12.</strong> Day 12</a></li><li class="chapter-item "><a href="2015/day13.html"><strong aria-hidden="true">2.13.</strong> Day 13</a></li><li class="chapter-item "><a href="2015/day14.html"><strong aria-hidden="true">2.14.</strong> Day 14</a></li><li class="chapter-item "><a href="2015/day15.html"><strong aria-hidden="true">2.15.</strong> Day 15</a></li><li class="chapter-item "><a href="2015/day16.html"><strong aria-hidden="true">2.16.</strong> Day 16</a></li><li class="chapter-item "><a href="2015/day17.html"><strong aria-hidden="true">2.17.</strong> Day 17</a></li><li class="chapter-item "><a href="2015/day18.html"><strong aria-hidden="true">2.18.</strong> Day 18</a></li><li class="chapter-item "><a href="2015/day19.html"><strong aria-hidden="true">2.19.</strong> Day 19</a></li><li class="chapter-item "><a href="2015/day20.html"><strong aria-hidden="true">2.20.</strong> Day 20</a></li><li class="chapter-item "><a href="2015/day21.html"><strong aria-hidden="true">2.21.</strong> Day 21</a></li><li class="chapter-item "><a href="2015/day22.html"><strong aria-hidden="true">2.22.</strong> Day 22</a></li><li class="chapter-item "><a href="2015/day23.html"><strong aria-hidden="true">2.23.</strong> Day 23</a></li><li class="chapter-item "><a href="2015/day24.html"><strong aria-hidden="true">2.24.</strong> Day 24</a></li><li class="chapter-item "><a href="2015/day25.html"><strong aria-hidden="true">2.25.</strong> Day 25</a></li></ol></li><li class="chapter-item "><a href="2016/index.html"><strong aria-hidden="true">3.</strong> 2016</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2016/day1.html"><strong aria-hidden="true">3.1.</strong> Day  1</a></li><li class="chapter-item "><a href="2016/day2.html"><strong aria-hidden="true">3.2.</strong> Day  2</a></li><li class="chapter-item "><a href="2016/day3.html"><strong aria-hidden="true">3.3.</strong> Day  3</a></li><li class="chapter-item "><a href="2016/day4.html"><strong aria-hidden="true">3.4.</strong> Day  4</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.</strong> 2017</div></li><li class="chapter-item "><div><strong aria-hidden="true">5.</strong> 2018</div></li><li class="chapter-item "><div><strong aria-hidden="true">6.</strong> 2019</div></li><li class="chapter-item "><div><strong aria-hidden="true">7.</strong> 2020</div></li><li class="chapter-item "><div><strong aria-hidden="true">8.</strong> 2021</div></li><li class="chapter-item "><a href="2022/index.html"><strong aria-hidden="true">9.</strong> 2022</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2022/day1.html"><strong aria-hidden="true">9.1.</strong> Day  1</a></li><li class="chapter-item "><a href="2022/day2.html"><strong aria-hidden="true">9.2.</strong> Day  2</a></li><li class="chapter-item "><a href="2022/day3.html"><strong aria-hidden="true">9.3.</strong> Day  3</a></li><li class="chapter-item "><a href="2022/day4.html"><strong aria-hidden="true">9.4.</strong> Day  4</a></li><li class="chapter-item "><a href="2022/day5.html"><strong aria-hidden="true">9.5.</strong> Day  5</a></li><li class="chapter-item "><a href="2022/day6.html"><strong aria-hidden="true">9.6.</strong> Day  6</a></li><li class="chapter-item "><a href="2022/day7.html"><strong aria-hidden="true">9.7.</strong> Day  7</a></li><li class="chapter-item "><a href="2022/day8.html"><strong aria-hidden="true">9.8.</strong> Day  8</a></li><li class="chapter-item "><a href="2022/day9.html"><strong aria-hidden="true">9.9.</strong> Day  9</a></li><li class="chapter-item "><a href="2022/day10.html"><strong aria-hidden="true">9.10.</strong> Day 10</a></li><li class="chapter-item "><a href="2022/day11.html"><strong aria-hidden="true">9.11.</strong> Day 11</a></li><li class="chapter-item "><a href="2022/day12.html"><strong aria-hidden="true">9.12.</strong> Day 12</a></li><li class="chapter-item "><a href="2022/day13.html"><strong aria-hidden="true">9.13.</strong> Day 13</a></li><li class="chapter-item "><a href="2022/day14.html"><strong aria-hidden="true">9.14.</strong> Day 14 (未)</a></li><li class="chapter-item "><a href="2022/day15.html"><strong aria-hidden="true">9.15.</strong> Day 15 (未)</a></li><li class="chapter-item "><a href="2022/day16.html"><strong aria-hidden="true">9.16.</strong> Day 16xx</a></li><li class="chapter-item "><div><strong aria-hidden="true">9.17.</strong> Day 17x</div></li><li class="chapter-item "><a href="2022/day18.html"><strong aria-hidden="true">9.18.</strong> Day 18</a></li><li class="chapter-item "><div><strong aria-hidden="true">9.19.</strong> Day 19xx</div></li><li class="chapter-item "><div><strong aria-hidden="true">9.20.</strong> Day 20</div></li><li class="chapter-item "><a href="2022/day21.html"><strong aria-hidden="true">9.21.</strong> Day 21</a></li><li class="chapter-item "><div><strong aria-hidden="true">9.22.</strong> Day 22</div></li><li class="chapter-item "><div><strong aria-hidden="true">9.23.</strong> Day 23</div></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">10.</strong> 2023</div></li><li class="chapter-item "><a href="2024/index.html"><strong aria-hidden="true">11.</strong> 2024</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2024/day1.html"><strong aria-hidden="true">11.1.</strong> Day  1</a></li><li class="chapter-item "><a href="2024/day2.html"><strong aria-hidden="true">11.2.</strong> Day  2</a></li><li class="chapter-item "><a href="2024/day3.html"><strong aria-hidden="true">11.3.</strong> Day  3</a></li><li class="chapter-item "><a href="2024/day4.html"><strong aria-hidden="true">11.4.</strong> Day  4</a></li><li class="chapter-item "><a href="2024/day5.html"><strong aria-hidden="true">11.5.</strong> Day  5</a></li><li class="chapter-item "><a href="2024/day6.html"><strong aria-hidden="true">11.6.</strong> Day  6</a></li><li class="chapter-item "><a href="2024/day7.html"><strong aria-hidden="true">11.7.</strong> Day  7</a></li><li class="chapter-item "><a href="2024/day8.html"><strong aria-hidden="true">11.8.</strong> Day  8</a></li><li class="chapter-item "><a href="2024/day9.html"><strong aria-hidden="true">11.9.</strong> Day  9</a></li><li class="chapter-item "><a href="2024/day10.html"><strong aria-hidden="true">11.10.</strong> Day 10</a></li><li class="chapter-item "><a href="2024/day11.html"><strong aria-hidden="true">11.11.</strong> Day 11</a></li><li class="chapter-item "><a href="2024/day12.html"><strong aria-hidden="true">11.12.</strong> Day 12</a></li><li class="chapter-item "><a href="2024/day13.html"><strong aria-hidden="true">11.13.</strong> Day 13</a></li><li class="chapter-item "><a href="2024/day14.html"><strong aria-hidden="true">11.14.</strong> Day 14</a></li><li class="chapter-item "><a href="2024/day15.html"><strong aria-hidden="true">11.15.</strong> Day 15</a></li><li class="chapter-item "><a href="2024/day16.html"><strong aria-hidden="true">11.16.</strong> Day 16</a></li><li class="chapter-item "><a href="2024/day17.html"><strong aria-hidden="true">11.17.</strong> Day 17</a></li><li class="chapter-item "><a href="2024/day18.html"><strong aria-hidden="true">11.18.</strong> Day 18</a></li><li class="chapter-item "><a href="2024/day19.html"><strong aria-hidden="true">11.19.</strong> Day 19</a></li><li class="chapter-item "><a href="2024/day20.html"><strong aria-hidden="true">11.20.</strong> Day 20</a></li><li class="chapter-item "><a href="2024/day21.html"><strong aria-hidden="true">11.21.</strong> Day 21</a></li><li class="chapter-item "><a href="2024/day22.html"><strong aria-hidden="true">11.22.</strong> Day 22</a></li><li class="chapter-item "><a href="2024/day23.html"><strong aria-hidden="true">11.23.</strong> Day 23</a></li><li class="chapter-item "><a href="2024/day24.html"><strong aria-hidden="true">11.24.</strong> Day 24</a></li><li class="chapter-item "><a href="2024/day25.html"><strong aria-hidden="true">11.25.</strong> Day 25</a></li></ol></li><li class="chapter-item "><li class="part-title">解答編</li><li class="chapter-item "><div><strong aria-hidden="true">12.</strong> 2015</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2015/spoiler1.html"><strong aria-hidden="true">12.1.</strong> Day  1</a></li><li class="chapter-item "><a href="2015/spoiler2.html"><strong aria-hidden="true">12.2.</strong> Day  2</a></li><li class="chapter-item "><a href="2015/spoiler3.html"><strong aria-hidden="true">12.3.</strong> Day  3</a></li><li class="chapter-item "><a href="2015/spoiler4.html"><strong aria-hidden="true">12.4.</strong> Day  4</a></li><li class="chapter-item "><a href="2015/spoiler5.html"><strong aria-hidden="true">12.5.</strong> Day  5</a></li><li class="chapter-item "><a href="2015/spoiler6.html"><strong aria-hidden="true">12.6.</strong> Day  6</a></li><li class="chapter-item "><a href="2015/spoiler7.html"><strong aria-hidden="true">12.7.</strong> Day  7</a></li><li class="chapter-item "><a href="2015/spoiler8.html"><strong aria-hidden="true">12.8.</strong> Day  8</a></li><li class="chapter-item "><a href="2015/spoiler9.html"><strong aria-hidden="true">12.9.</strong> Day  9</a></li><li class="chapter-item "><a href="2015/spoiler10.html"><strong aria-hidden="true">12.10.</strong> Day 10</a></li><li class="chapter-item "><a href="2015/spoiler11.html"><strong aria-hidden="true">12.11.</strong> Day 11</a></li><li class="chapter-item "><a href="2015/spoiler12.html"><strong aria-hidden="true">12.12.</strong> Day 12</a></li><li class="chapter-item "><a href="2015/spoiler13.html"><strong aria-hidden="true">12.13.</strong> Day 13</a></li><li class="chapter-item "><a href="2015/spoiler14.html"><strong aria-hidden="true">12.14.</strong> Day 14</a></li><li class="chapter-item "><a href="2015/spoiler15.html"><strong aria-hidden="true">12.15.</strong> Day 15</a></li><li class="chapter-item "><a href="2015/spoiler16.html"><strong aria-hidden="true">12.16.</strong> Day 16</a></li><li class="chapter-item "><a href="2015/spoiler17.html"><strong aria-hidden="true">12.17.</strong> Day 17</a></li><li class="chapter-item "><a href="2015/spoiler18.html"><strong aria-hidden="true">12.18.</strong> Day 18</a></li><li class="chapter-item "><a href="2015/spoiler19.html"><strong aria-hidden="true">12.19.</strong> Day 19</a></li><li class="chapter-item "><a href="2015/spoiler20.html"><strong aria-hidden="true">12.20.</strong> Day 20</a></li><li class="chapter-item "><a href="2015/spoiler21.html"><strong aria-hidden="true">12.21.</strong> Day 21</a></li><li class="chapter-item "><a href="2015/spoiler22.html"><strong aria-hidden="true">12.22.</strong> Day 22</a></li><li class="chapter-item "><a href="2015/spoiler23.html"><strong aria-hidden="true">12.23.</strong> Day 23</a></li><li class="chapter-item "><a href="2015/spoiler24.html"><strong aria-hidden="true">12.24.</strong> Day 24</a></li><li class="chapter-item "><a href="2015/spoiler25.html"><strong aria-hidden="true">12.25.</strong> Day 25</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">13.</strong> 2016</div></li><li class="chapter-item "><div><strong aria-hidden="true">14.</strong> 2017</div></li><li class="chapter-item "><div><strong aria-hidden="true">15.</strong> 2018</div></li><li class="chapter-item "><div><strong aria-hidden="true">16.</strong> 2019</div></li><li class="chapter-item "><div><strong aria-hidden="true">17.</strong> 2020</div></li><li class="chapter-item "><div><strong aria-hidden="true">18.</strong> 2021</div></li><li class="chapter-item "><div><strong aria-hidden="true">19.</strong> 2022</div></li><li class="chapter-item "><div><strong aria-hidden="true">20.</strong> 2023</div></li><li class="chapter-item "><div><strong aria-hidden="true">21.</strong> 2024</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2024/spoiler1.html"><strong aria-hidden="true">21.1.</strong> Day  1</a></li><li class="chapter-item "><a href="2024/spoiler2.html"><strong aria-hidden="true">21.2.</strong> Day  2</a></li><li class="chapter-item "><a href="2024/spoiler3.html"><strong aria-hidden="true">21.3.</strong> Day  3</a></li><li class="chapter-item "><a href="2024/spoiler4.html"><strong aria-hidden="true">21.4.</strong> Day  4</a></li><li class="chapter-item "><a href="2024/spoiler5.html"><strong aria-hidden="true">21.5.</strong> Day  5</a></li><li class="chapter-item "><a href="2024/spoiler6.html"><strong aria-hidden="true">21.6.</strong> Day  6</a></li><li class="chapter-item "><a href="2024/spoiler7.html"><strong aria-hidden="true">21.7.</strong> Day  7</a></li><li class="chapter-item "><a href="2024/spoiler8.html"><strong aria-hidden="true">21.8.</strong> Day  8</a></li><li class="chapter-item "><a href="2024/spoiler9.html"><strong aria-hidden="true">21.9.</strong> Day  9</a></li><li class="chapter-item "><a href="2024/spoiler10.html"><strong aria-hidden="true">21.10.</strong> Day 10</a></li><li class="chapter-item "><a href="2024/spoiler11.html"><strong aria-hidden="true">21.11.</strong> Day 11</a></li><li class="chapter-item "><a href="2024/spoiler12.html"><strong aria-hidden="true">21.12.</strong> Day 12</a></li><li class="chapter-item "><a href="2024/spoiler13.html"><strong aria-hidden="true">21.13.</strong> Day 13</a></li><li class="chapter-item "><a href="2024/spoiler14.html"><strong aria-hidden="true">21.14.</strong> Day 14</a></li><li class="chapter-item "><a href="2024/spoiler15.html"><strong aria-hidden="true">21.15.</strong> Day 15</a></li><li class="chapter-item "><a href="2024/spoiler16.html"><strong aria-hidden="true">21.16.</strong> Day 16</a></li><li class="chapter-item "><a href="2024/spoiler17.html"><strong aria-hidden="true">21.17.</strong> Day 17</a></li><li class="chapter-item "><a href="2024/spoiler18.html"><strong aria-hidden="true">21.18.</strong> Day 18</a></li><li class="chapter-item "><a href="2024/spoiler19.html"><strong aria-hidden="true">21.19.</strong> Day 19</a></li><li class="chapter-item "><a href="2024/spoiler20.html"><strong aria-hidden="true">21.20.</strong> Day 20</a></li><li class="chapter-item "><a href="2024/spoiler21.html"><strong aria-hidden="true">21.21.</strong> Day 21</a></li><li class="chapter-item "><a href="2024/spoiler22.html"><strong aria-hidden="true">21.22.</strong> Day 22</a></li><li class="chapter-item "><a href="2024/spoiler23.html"><strong aria-hidden="true">21.23.</strong> Day 23</a></li><li class="chapter-item "><a href="2024/spoiler24.html"><strong aria-hidden="true">21.24.</strong> Day 24</a></li><li class="chapter-item "><a href="2024/spoiler25.html"><strong aria-hidden="true">21.25.</strong> Day 25</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Advent of Code</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="advent-of-code"><a class="header" href="#advent-of-code">Advent of Code</a></h1>
<p><a href="https://adventofcode.com/">Advent of Code</a>の問題を翻訳しています。</p>
<h2 id="訳語とかについて"><a class="header" href="#訳語とかについて">訳語とかについて</a></h2>
<p>サンタの周りで色々と騒ぎを引き起こす、物語の主要な登場人物は、
原文では elf, elves となっています。
これを「エルフ」と訳してしまうと、現代日本では、耳の長い長命な亜人のことになってしまうので、
「小人」としました。</p>
<h2 id="todo"><a class="header" href="#todo">TODO</a></h2>
<p>全体的に途中かけ。2015年、2024年のみ一応完成。</p>
<ul>
<li>2015/day19のspoilerは、解の正しさを保証する内容になっていない。</li>
<li>2015/day23のspoilerは、手抜きといえば手抜きかもしれない。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2015年"><a class="header" href="#2015年">2015年</a></h1>
<p>サンタはホワイトクリスマスを望んでいましたが、
彼のお天気制御装置の「雪」機能はスターが動力源なのに、
彼はスターを使い切ってしまったところです！
クリスマスを救うには、12月25日までに50個のスターを集める必要があります。</p>
<p>サンタがパズルを解くのを助けることでスターを集めよう。
このアドベントカレンダーでは、毎日2つのパズルが利用可能になります。
2番目のパズルは、1番目を完了するとロックが解除されます。
各パズルで1つずつ星が貰えます。がんばろう！</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right"></th><th style="text-align: left">タイトル</th><th style="text-align: left">ひとこと</th></tr></thead><tbody>
<tr><td style="text-align: right">1</td><td style="text-align: left">Lispではない</td><td style="text-align: left">LISPはLots of Irritating Superfluous Parenthesesの略</td></tr>
<tr><td style="text-align: right">2</td><td style="text-align: left">数学は使わない、と私は言われた</td><td style="text-align: left">算数のお時間</td></tr>
<tr><td style="text-align: right">3</td><td style="text-align: left">真空中の完全球形住宅</td><td style="text-align: left">東西南北に駆け回る</td></tr>
<tr><td style="text-align: right">4</td><td style="text-align: left">理想的な長靴下の詰め合わせ</td><td style="text-align: left">AdventCoins</td></tr>
<tr><td style="text-align: right">5</td><td style="text-align: left">彼はこれ用の小人研修生を持っていないのですか？</td><td style="text-align: left">いい文字列</td></tr>
<tr><td style="text-align: right">6</td><td style="text-align: left">火災の危険性あり</td><td style="text-align: left">電飾でご近所さんと張り合う</td></tr>
<tr><td style="text-align: right">7</td><td style="text-align: left">組み立てが少々必要</td><td style="text-align: left">論理回路シミュレーション</td></tr>
<tr><td style="text-align: right">8</td><td style="text-align: left">マッチ棒</td><td style="text-align: left">バックスラッシュ文字のこと？</td></tr>
<tr><td style="text-align: right">9</td><td style="text-align: left">一晩で</td><td style="text-align: left">巡回サンタ問題</td></tr>
<tr><td style="text-align: right">10</td><td style="text-align: left">小人は見る、小人は話す</td><td style="text-align: left">読み上げ順列ゲーム</td></tr>
<tr><td style="text-align: right">11</td><td style="text-align: left">企業方針</td><td style="text-align: left">パスワード生成</td></tr>
<tr><td style="text-align: right">12</td><td style="text-align: left">JSAbacusFramework.io</td><td style="text-align: left">JSONを読め</td></tr>
<tr><td style="text-align: right">13</td><td style="text-align: left">食卓の騎士</td><td style="text-align: left">これもTSP</td></tr>
<tr><td style="text-align: right">14</td><td style="text-align: left">トナカイオリンピック</td><td style="text-align: left">走行距離を競うタイプ</td></tr>
<tr><td style="text-align: right">15</td><td style="text-align: left">飢えた人々のための科学</td><td style="text-align: left">クッキーを作ろう</td></tr>
<tr><td style="text-align: right">16</td><td style="text-align: left">スーおばさん</td><td style="text-align: left">マイファースト犯罪現場分析機はテム＝レイサーキットを内蔵</td></tr>
<tr><td style="text-align: right">17</td><td style="text-align: left">多くていけないものはない</td><td style="text-align: left">卵酒を保存したいナップザック問題</td></tr>
<tr><td style="text-align: right">18</td><td style="text-align: left">あなたの庭のGIFアニメ</td><td style="text-align: left">ライフゲーム</td></tr>
<tr><td style="text-align: right">19</td><td style="text-align: left">ルドルフのための薬</td><td style="text-align: left">書き換え系</td></tr>
<tr><td style="text-align: right">20</td><td style="text-align: left">無限の小人と無限の家</td><td style="text-align: left">プレゼントを配るのに大忙し</td></tr>
<tr><td style="text-align: right">21</td><td style="text-align: left">RPGシミュレータ20XX</td><td style="text-align: left">RPGのやりこみプレイ</td></tr>
<tr><td style="text-align: right">22</td><td style="text-align: left">魔法使いシミュレータ20XX</td><td style="text-align: left">(spoilerまだ)</td></tr>
<tr><td style="text-align: right">23</td><td style="text-align: left">チューリングロックを開く</td><td style="text-align: left">コラッツCPUエミュレーション</td></tr>
<tr><td style="text-align: right">24</td><td style="text-align: left">バランスしてぶら下がっている</td><td style="text-align: left">バランスをとらないとそりが飛べない</td></tr>
<tr><td style="text-align: right">25</td><td style="text-align: left">雪よ降れ</td><td style="text-align: left">立ちはだかるマニュアルプロテクト</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="1日目lispではない"><a class="header" href="#1日目lispではない">1日目：Lispではない</a></h1>
<p>今日はあなたの準備運動のための簡単なパズルです。</p>
<p>サンタは大きなマンションでプレゼントを配ろうとしていますが、
彼は正しいフロアを見つけることができません。
彼が得た指示は何だかややこしいものです。
彼は地上階(0階)から開始し、一度に1文字ずつ指示に従います。</p>
<p>開き括弧 <code>(</code> は1階上がるべきであることを意味し、
閉じ括弧 <code>)</code> はフロアを1つ降りることを意味します。</p>
<p>マンションの建物は非常に高く、地下室も非常に深いです。
彼は決して最上階や最下層に到達することはありません。</p>
<h2 id="例"><a class="header" href="#例">例</a></h2>
<ul>
<li><code>(())</code> と <code>()()</code> はどちらも0階で終わります。</li>
<li><code>(((</code> と <code>(()(()(</code> はどちらも3階で終わります。</li>
<li><code>))(((((</code> もまた3階になります。</li>
<li><code>())</code> と <code>))(</code> はどちらも \(-1\) 階（地下1階）になります。</li>
<li><code>)))</code> と <code>)())())</code> はどちらも \(-3\) 階になります。</li>
</ul>
<p>さて、指示書に従ったサンタが最後にたどり着くのは<strong>何階</strong>でしょうか？</p>
<h1 id="パート2"><a class="header" href="#パート2">パート2</a></h1>
<p>今度は、同じ指示書を受け取ったとして、
彼を地下1階（\(-1\)階）に到達させる最初の文字の位置を見つけてください。
指示書の最初の文字の位置は1、
2番目の文字は位置2、以下同文とします。</p>
<h2 id="例-1"><a class="header" href="#例-1">例</a></h2>
<ul>
<li><code>)</code> 彼は位置1の文字で地下1階に入ります。</li>
<li><code>()())</code> 彼は位置5の文字で地下1階に入ります。</li>
</ul>
<p>サンタが最初に地下1階に入る原因となる<strong>文字の位置</strong>は？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2日目数学は使わないと私は言われた"><a class="header" href="#2日目数学は使わないと私は言われた">2日目：数学は使わない、と私は言われた</a></h1>
<p>小人は包装紙を使い切りそうになっているので、もっと注文する必要があります。
彼らは各プレゼントの寸法（長さ \(l\) 、幅 \(w\) 、高さ \(h\) ）のリストを持っていて、
必要なだけを正確に注文したいです。</p>
<p>幸いなことに、すべてのプレゼントは箱（正確な直方体）です。
これは、それぞれの贈り物に必要な包装紙の計算を少し簡単にします。
箱の表面積 \(2 \times l \times w + 2 \times w \times h + 2 \times h \times l\)
を求めてください。
小人はまた、それぞれのプレゼントに少し、
具体的には最も小さい面の面積だけ紙を余分に必要とします。</p>
<h2 id="例-2"><a class="header" href="#例-2">例</a></h2>
<ul>
<li>寸法 \(2 \times 3 \times 4\) のプレゼントは、
\(2 \times 6 + 2 \times 12 + 2 \times 8 = 52\) 平方フィートに、
余裕を6加えた58平方フィートの包装紙が必要です。</li>
<li>寸法 \(1 \times 1 \times 10\) のプレゼントは
\(2 \times  1 + 2 \times 10 + 2 \times 10 = 42\) 平方フィートに
余裕を1加えた43平方フィートの包装紙が必要です。</li>
</ul>
<p>小人のリストに載っている数字はすべてフィートです。
注文するべき<strong>包装紙の総面積</strong>は何平方フィートですか？</p>
<h1 id="パート2-1"><a class="header" href="#パート2-1">パート2</a></h1>
<p>小人はリボンも使い切りそうです。
リボンはすべて同じ幅であるため、
注文するときに気にすることは必要な長さだけで、
やはり正確に注文したいと考えています。</p>
<p>プレゼントを縛るために必要なリボンは、
その側面の周長のうち最短のもの、
言い換えるといずれかの面の周長の最小値です。
それぞれのプレゼントには、リボンの蝶結びも必要です。
完璧な蝶結びに必要なリボンの長さは、
プレゼントの容積の立方フィートと同じです。
彼らがどのように蝶結びを作るのか尋ねないでください。
彼らは決して教えてくれません。</p>
<h2 id="例-3"><a class="header" href="#例-3">例</a></h2>
<ul>
<li>寸法 \(2 \times 3 \times 4\) のプレゼントは、縛るために \(2+2+3+3 = 10\) フィートのリボンが、
蝶結びのために \(2 \times 3 \times 4 = 24\) フィートのリボンが必要で、
合わせて34フィート必要です。</li>
<li>寸法 \(1 \times 1 \times 10\) のプレゼントは、縛るために \(1+1+1+1 = 4\) フィートのリボンが、
蝶結びのために \(1 \times 1 \times 10 = 10\) フィートのリボンが必要で、
合わせて14フィート必要です。</li>
</ul>
<p>彼らが注文するべき<strong>リボンの総長</strong>はどれだけですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3日目真空中の完全球形住宅"><a class="header" href="#3日目真空中の完全球形住宅">3日目：真空中の完全球形住宅</a></h1>
<p>サンタは無限の2次元グリッド住宅街にプレゼントを届けています。</p>
<p>彼は出発地にある家にプレゼントを配達することから始めます。
北極にいる小人が無線で彼に連絡し、次にどこへ行くべきかを彼に伝えます。
移動は常にちょうど1軒隣の
北（<code>^</code>）、南（<code>v</code>）、東（<code>&gt;</code>）、西（<code>&lt;</code>）の家です。
それぞれの移動の後、彼は彼の新しい位置の家に次のプレゼントを届けます。</p>
<p>しかし、北極にいる小人は卵酒を少し飲み過ぎてしまったために指示が少しずれて、
その結果サンタがいくつかの家を複数回訪れてしまいました。
<strong>少なくとも1つ</strong>プレゼントを受けとる家は何軒ありますか？</p>
<p>例えば：</p>
<ul>
<li><code>&gt;</code> は2軒にプレゼントを届けます。
出発地に1つ、東に1つ。</li>
<li><code>^&gt;v&lt;</code> は四角く並んだ4軒にプレゼントを届けます。
彼の出発かつ終了地点の家には2度訪れます。</li>
<li><code>^v^v^v^v^v</code> は2軒の家だけにいる
非常に幸運な子どもたちにたくさんのプレゼントを届けます。</li>
</ul>
<h1 id="パート2-2"><a class="header" href="#パート2-2">パート2</a></h1>
<p>翌年、処理を高速化するために、
サンタは自分自身のロボット版である<strong>メカサンタ</strong>を作成しました。
彼と一緒にプレゼントを届けるためのものです。</p>
<p>サンタとメカサンタは同じ場所から出発し
（同じ出発地点の家に2つのプレゼントを配達する）、
卵酒を飲み過ぎたせいで去年と同じ行動計画を読み上げる小人の指示に基づいて<strong>交互に</strong>移動します。</p>
<p>今年は、何軒の家が<strong>少なくとも1つ</strong>のプレゼントを受け取りますか？</p>
<p>例えば：</p>
<ul>
<li><code>^v</code> は3軒にプレゼントを届けます。
サンタは北に行き、その後メカサンタが南に行くからです。</li>
<li><code>^&gt;v&lt;</code> は今回3軒にプレゼントを配達し、
サンタとメカサンタは彼らが始めた地点に戻ってきます。</li>
<li><code>^v^v^v^v^v</code> は今回11軒の家にプレゼントを届けます。
サンタは一方向に、メカサンタはそれと反対向きに向かって行きます。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4日目理想的な長靴下の詰め合わせ"><a class="header" href="#4日目理想的な長靴下の詰め合わせ">4日目：理想的な長靴下の詰め合わせ</a></h1>
<p>（原題は stocking stuffer で頭韻を踏んでいる）</p>
<p>サンタは
AdventCoins（<strong>bitcoins</strong>と非常によく似た何か）を<strong>マイニング</strong>する手助けを求めています。
経済的に先進的な全ての子供たちへのプレゼントにするのです。</p>
<p>それには、<strong>MD5</strong>ハッシュが<strong>16進数</strong>で少なくとも<strong>5つのゼロ</strong>で始まるようなものを見つける必要があります。
MD5ハッシュへの入力は何かの秘密鍵（パズル入力）に10進数の数字を続けたものです。
AdventCoinsをマイニングするために、
そのようなハッシュを生成するような最小の正の数（先行する零は付けずに1,2,3,…で）を見つける必要があります。</p>
<p>例えば：</p>
<ul>
<li>あなたの秘密鍵が<code>abcdef</code>のとき、その答は<code>609043</code>です。
というのは<code>abcdef609043</code>のMD5のハッシュは5つの零で始まり（<code>000001dbbfa...</code>）、またそうなる最小の数だからです。</li>
<li>あなたの秘密鍵が<code>pqrstuv</code>のとき、連結して5つの零で始まるMD5ハッシュを作る最小の数は<code>1048970</code>です。
つまり、<code>pqrstuv1048970</code>のMD5ハッシュは<code>000006136ef...</code>となります。</li>
</ul>
<p>あなたのパズル入力は (実際の内容) です。</p>
<h1 id="パート2-3"><a class="header" href="#パート2-3">パート2</a></h1>
<p>今度は6つの0で始まるようなものを見つけてください。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5日目彼はこれ用の小人研修生を持っていないのですか"><a class="header" href="#5日目彼はこれ用の小人研修生を持っていないのですか">5日目：彼はこれ用の小人研修生を持っていないのですか？</a></h1>
<p>(intern-elvesが何の駄洒落なのかわからない)</p>
<p>サンタは、テキストファイルの文字列がそれぞれ、
「いい」か「いやらしい」のどちらなのかを突き止める手助けを必要としています。</p>
<p><strong>いい文字列</strong>とは、以下の性質のすべてを有するものです。</p>
<ul>
<li>少なくとも3つの母音（<code>aeiou</code>のみ）が含まれている。
例えば<code>aei</code>, <code>xazegov</code>, <code>aeiouaeiouaeiou</code></li>
<li>少なくとも1つ、2回続けて現れる文字を含む。
例えば<code>xx</code>, <code>abcdde</code> (dd), <code>aabbccdd</code> (aa, bb, cc, dd)</li>
<li><code>ab</code>, <code>cd</code>, <code>pq</code>, <code>xy</code>を<strong>含まない</strong>。
それらが他の要件のいずれかの一部であっても例外ではない。</li>
</ul>
<p>いい文字列でない文字列は、いやらしい文字列です。</p>
<p>例えば：</p>
<ul>
<li><code>ugknbfddgicrmopn</code> はいい文字列です。
少なくとも3つの母音 (u...i...o...)と
続き文字 (...dd...)を含み、
許可されていない部分文字列を持っていません。</li>
<li><code>aaa</code> はいい文字列です。
少なくとも3つの母音と2つの文字を持つためです。
異なる規則で使用されている文字が重なっていてもかまいません。</li>
<li><code>jchzalrnumimnmhp</code> は続き文字がないのでいやらしい文字列です。</li>
<li><code>haegwjzuvuyypxyu</code> は文字列<code>xy</code>を含んでいるのでいやらしい文字列です。</li>
<li><code>dvszwmarrgswjxmb</code> は1つの母音しか含まれていないので、いやらしい文字列です。</li>
</ul>
<p>いい文字列はいくつありますか？</p>
<h1 id="パート2-4"><a class="header" href="#パート2-4">パート2</a></h1>
<p>サンタは自分のやり方の間違いに気がついて、
文字列が「いい」か「いやらしい」かを判断するより良いモデルに切り替えました。
古い規則は全て明らかにばかげているので適用されません。</p>
<p>さて、いい文字列は、以下のすべての性質を持つものです。</p>
<ul>
<li>何らかの2つの文字の対が重ならずに二回またはそれ以上に現れます。
例えば<code>xyxy</code> (<code>xy</code>)や<code>aabcdefgaa</code> (<code>aa</code>)はこれにあてはまりますが、
<code>aaa</code>は<code>aa</code>が2度現れますが重なっているので違います。</li>
<li>間にちょうど1文字を挟んで同じ文字が繰り返すような並びが1回またはそれ以上に現れます。
例えば<code>xyx</code>, <code>abcdefeghi</code> (<code>efe</code>) のようなものです。
また<code>aaa</code>も該当します。</li>
</ul>
<p>例えば：</p>
<ul>
<li><code>qjhvhtzxzqqjkmpb</code>はいい文字列です。
2回出現する対<code>qj</code>と、1文字置いて繰り返される文字<code>zxz</code>があるためです。</li>
<li><code>xxyxx</code>はいい文字列です。
二重に現れる対と間に1文字置いて繰り返される文字があります。
両規則で使用されている文字が重なっていても構いません。</li>
<li><code>uurcxstgmygtbstg</code>
これには対(<code>tg</code>)はありますが、一文字置いた繰り返しがありませんので、いやらしい文字列です。</li>
<li><code>ieodomkazucvgmuy</code>
1文字置いた繰り返し文字がありますが(<code>odo</code>)、2回現れる対はありませんので、いやらしい文字列です。</li>
</ul>
<p>これらの新しい規則の下で、いい文字列はいくつありますか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6日目火災の危険性あり"><a class="header" href="#6日目火災の危険性あり">6日目：火災の危険性あり</a></h1>
<p>あなたのご近所さんがホリデーハウスデコレーションコンテストであなたを
毎年敗北させ続けるので、
\(1,000 \times 1,000\) グリッドに 100万本のライトを配備することに決めました。</p>
<p>さらに、あなたは今年、特にいい子でいたので、
理想的な照明を表示する構成の手順書をサンタからメールで受け取りました。</p>
<p>グリッド内のライトは、各方向に0から999の番号が付けられます。
四隅のライトはそれぞれ座標<code>0,0</code>、<code>0,999</code>、<code>999,999</code>、<code>999,0</code>となります。
各指示は
<code>turn on</code>（点灯）、<code>turn off</code>（消灯）、<code>toggle</code>（反転）
のいずれかです。
指示には、座標の対によりその操作を行う範囲（境界を含む）が含まれます。
各座標対は、長方形の対向する角を表します。
よって例えば <code>0,0 through 2,2</code> という座標対は、\(3 \times 3\) の正方形の9つのライトを指します。
すべてのライトはオフで始まります。</p>
<p>今年あなたのご近所さんに打ち勝つためには、
サンタから送られた手順書に従って、
あなたのライトを設定しさえすればよいのです。</p>
<p>例えば：</p>
<ul>
<li><code>turn on 0,0 through 999,999</code> は全てのライトをオンにします。
（元からオンのものはオンのままです）。</li>
<li><code>toggle 0,0 through 999,0</code> 第1行の1000個のライトを反転します。
オンになっていたものをオフにし、オフになっていたものをオンにします。</li>
<li><code>turn off 499,499 through 500,500</code> 中央の4つのライトをオフにします。
（元からオフのものはオフのままです。）</li>
</ul>
<p>一通り指示書に従った後、<strong>点灯しているライトはいくつですか？</strong></p>
<h1 id="パート2-5"><a class="header" href="#パート2-5">パート2</a></h1>
<p>勝利パターンを実装し終わったとき、サンタからのメッセージを
古代ノルディック小人語から翻訳するときに間違えていたことに気付きました。</p>
<p>あなたが購入したライトグリッドには、実際には個々の明るさコントロールがありました。
各ライトは0以上の明るさを持ちます。ライトはすべて明るさ0で始まります。</p>
<p><code>turn on</code>というフレーズは実際には
あなたがそれらのライトの明るさを1増やすべきであることを意味します。</p>
<p><code>turn off</code>というフレーズは実際には
あなたがライトの明るさを1下げる必要があることを意味します。
その最小値は零です。</p>
<p><code>toggle</code>のフレーズは実際には
あなたがそれらのライトの明るさを2増やすべきであることを意味します。</p>
<p>サンタの指示に従った後に、すべてのライトの明るさを合わせた
<strong>明るさの合計値</strong>はいくつでしょう？</p>
<p>例えば：</p>
<ul>
<li><code>turn on 0,0 through 0,0</code>は合計値を1増加させます。</li>
<li><code>toggle 0,0 through 999,999</code>は合計値を2000000増加させます。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7日目組み立てが少々必要"><a class="header" href="#7日目組み立てが少々必要">7日目：組み立てが少々必要</a></h1>
<p>今年、サンタはボビー・テーブルス少年に
配線ワイヤとビット<strong>論理ゲート</strong>のセットを届けました！
残念ながら、Bobbyは推奨の年齢層より少し小さいので、
彼は回路を組み立てるのに助けが必要です。</p>
<p>各ワイヤは識別子（小文字アルファベット）を持ち、
16ビットの信号（0～65535の数）を伝えることができます。
各ワイヤには、ゲートまたは別のワイヤから信号が伝えられるか、定数値が与えられます。
各ワイヤは1つの信号源からのみ信号を得ることができますが、複数の接続先に信号を供給することができます。
ゲートは、その入力のすべてが信号を持つまで信号を供給しません。</p>
<p>付属の取扱説明書には、どのようにパーツを接続するかが書かれています。
<code>x AND y -&gt; z</code>は
ワイヤ<code>x</code>とワイヤ<code>y</code>を<code>AND</code>ゲートに接続し、
その出力をワイヤ<code>z</code>に接続することを意味します。</p>
<p>例えば：</p>
<ul>
<li><code>123 -&gt; x</code> は信号<code>123</code>がワイヤ<code>x</code>に供給されることを意味します。</li>
<li><code>x AND y -&gt; z</code> はワイヤ<code>x</code>とワイヤ<code>y</code>との<strong>ビット単位の論理積</strong>が
ワイヤ<code>z</code>に供給されることを意味します。</li>
<li><code>p LSHIFT 2 -&gt; q</code> はワイヤ<code>p</code>からの値が2だけ<strong>左シフト</strong>され、
そのワイヤ<code>q</code>に提供されることを意味します。</li>
<li><code>NOT e -&gt; f</code> はワイヤ<code>e</code>からの値の<strong>ビット単位の反転</strong>が
ワイヤ<code>f</code>に供給されることを意味します。</li>
</ul>
<p>他の使用可能なゲートには、<code>OR</code>（<strong>ビット単位OR</strong>）および<code>RSHIFT</code>（<strong>右シフト</strong>）があります。
何らかの理由で代わりに回路を<strong>エミュレート</strong>したい場合、
ほとんどすべてのプログラミング言語（C, JavaScript, Pythonなど）はこれらのゲートの演算子を提供しています。</p>
<p>例えば、ここには簡単な回路があります：</p>
<pre><code>123 -&gt; x
456 -&gt; y
x AND y -&gt; d
x OR y -&gt; e
x LSHIFT 2 -&gt; f
y RSHIFT 2 -&gt; g
NOT x -&gt; h
NOT y -&gt; i
</code></pre>
<p>それが実行された後、ワイヤ上の信号は次のようになります。</p>
<pre><code>d: 72
e: 507
f: 492
g: 114
h: 65412
i: 65079
x: 123
y: 456
</code></pre>
<p>ボビー少年のキットの説明書
（あなたのパズル入力として提供されている）
では、最終的にどのような信号が<strong>ワイヤ<code>a</code>に</strong>流れますか？</p>
<h1 id="パート2-6"><a class="header" href="#パート2-6">パート2</a></h1>
<p>今度は、ワイヤ<code>a</code>上にある信号を取り出し、
その信号をワイヤ<code>b</code>へ上書きし、
他のワイヤ（ワイヤ<code>a</code>を含む）をリセットします。
最終的にどのような新しい信号がワイヤ<code>a</code>に流れますか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="8日目マッチ棒"><a class="header" href="#8日目マッチ棒">8日目：マッチ棒</a></h1>
<p>今年はソリの容積が制限されているので、サンタはリストをデジタルコピーにして持ち込む予定です。
彼は、リストを保存したときどのくらいのメモリ容量を使うかを知る必要があります。</p>
<p>多くのプログラミング言語では、
文字列内の特殊文字をエスケープする方法を提供することが一般的です。
例えばC, JavaScript, Perl, Python, またPHPさえ特殊文字を非常に似た方法で扱います。</p>
<p>ただし、<strong>文字列リテラルのコード表現</strong>の文字数と
<strong>メモリ中の文字列自体の文字数</strong>の違いを理解することが重要です。</p>
<p>例えば：</p>
<ul>
<li><code>""</code> はコード表現では2文字（2つのダブルクオート）ですが、文字列は文字を零個持ちます。</li>
<li><code>"abc"</code> はコード表現では5文字ですが、文字列データ内は3文字です。</li>
<li><code>"aaa\"aaa"</code> はコード表現では10文字ですが、
文字列自体は6個の文字<code>a</code>と
エスケープされたダブルクオートを1文字持ち、
合わせて文字列データ内は7文字です。</li>
<li><code>"\x27"</code> はコード表現では6文字ですが、
文字列自体は16進表記を使用してエスケープしたアポストロフィ<code>'</code>1文字だけからなります。</li>
</ul>
<p>サンタのリストは、ダブルクオートで囲まれた文字列リテラルを各行に1つずつ含む大きなファイルです。
使用されるエスケープシーケンスは
<code>\\</code>（単一のバックスラッシュを表す）、
<code>\"</code>（単独のダブルクオートを表す）、
<code>\x</code> に16進文字を2つ続けたもの（そのASCIIコードを持つ1文字を表す）
だけです。</p>
<p>ファイル内の空白を無視して、
ファイル全体で
<strong>文字列リテラルのコード表現での文字数</strong>から、
<strong>文字列データのメモリ中の文字数</strong>
を引いた値はいくらですか？</p>
<p>たとえば、上の4つの文字列を指定すると、
コード表現の文字列の総文字数 \(2 + 5 + 10 + 6 = 23\) から
文字列データのメモリ中の総文字数 \(0 + 3 + 7 + 1 = 11\) を引くと
\(23 - 11 = 12\) となります。</p>
<h1 id="パート2-7"><a class="header" href="#パート2-7">パート2</a></h1>
<p>では今度は逆をしましょう。
コード表現の文字列の文字数を求めることに加えて、
<strong>個々のコード表現を新しい文字列としてエンコード</strong>し、
新しいエンコードされた表現の文字数（ダブルクオートを含めて）を求めてください。</p>
<p>例えば：</p>
<ul>
<li><code>""</code> は <code>"\"\""</code> とエンコードされ、2文字から6文字に増加します。</li>
<li><code>"abc"</code> は <code>"\"abc\""</code> とエンコードされ、5文字から9文字に増加します。</li>
<li><code>"aaa\"aaa"</code> は <code>"\"aaa\\\"aaa\""</code> とエンコードされ、10文字から16文字に増加します。</li>
<li><code>"\x27"</code> は <code>"\"\\x27\""</code> とエンコードされ、6文字から11文字に増加します。</li>
</ul>
<p>あなたの仕事は、<strong>新しくエンコードされた文字列を表すために必要な文字の総数</strong>から、
<strong>それぞれの元の文字列リテラルのコード表現での文字数</strong>を引いたものを見つけることです。
たとえば、上記の文字列の場合、
コード化された長さ (\(6 + 9 + 16 + 11 = 42\)) から
元のコード表現の文字の長さ (このパズルの前半と同じ23) を差し引いた結果は
\(42 - 23 = 19\) です。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="9日目一晩で"><a class="header" href="#9日目一晩で">9日目：一晩で</a></h1>
<p>毎年、サンタは一晩ですべてのプレゼントを配達します。</p>
<p>しかし、今年は新たに訪れる場所がいくつか増えました。
彼の小人は彼に場所のすべての対の間の距離を与えました。
彼は自分が望む任意の2つの（異なる）場所から出発して終了することができますが、
各場所をちょうど1回ずつ訪問する必要があります。
これを達成するための彼の移動する<strong>最短距離</strong>は何ですか？</p>
<p>たとえば、次の距離が与えられたとします。</p>
<pre><code>London to Dublin = 464
London to Belfast = 518
Dublin to Belfast = 141
</code></pre>
<p>したがって、可能なルートは次のとおりです。</p>
<pre><code>Dublin -&gt; London -&gt; Belfast = 982
London -&gt; Dublin -&gt; Belfast = 605
London -&gt; Belfast -&gt; Dublin = 659
Dublin -&gt; Belfast -&gt; London = 659
Belfast -&gt; Dublin -&gt; London = 605
Belfast -&gt; London -&gt; Dublin = 982
</code></pre>
<p>これらの中で最短のものはLondon -&gt; Dublin -&gt; Belfast = 605で、
この例に対する答は605です。</p>
<p>最短ルートの距離はどれくらいですか？</p>
<h1 id="パート2-8"><a class="header" href="#パート2-8">パート2</a></h1>
<p>翌年、見せびらかすために、逆にサンタは<strong>最長距離</strong>の経路を取ることにしました。</p>
<p>前回同様、
彼は自分が望む任意の2つの（異なる）場所から出発して終了することができますが、
各場所をちょうど1回ずつ訪問する必要があります。</p>
<p>例えば、上記の距離を考えると、
最長の経路は例えば Dublin -&gt; London -&gt; Belfastの982です。</p>
<p>最長ルートの距離はどれくらいですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10日目小人は見る小人は話す"><a class="header" href="#10日目小人は見る小人は話す">10日目：小人は見る、小人は話す</a></h1>
<p>今日、小人たちは
<a href="https://ja.wikipedia.org/wiki/%E8%AA%AD%E3%81%BF%E4%B8%8A%E3%81%92%E6%95%B0%E5%88%97">読み上げ数列</a>（
<a href="https://en.wikipedia.org/wiki/Look-and-say_sequence">look-and-say</a>）
というゲームをしています。
彼らは順番に前の列を朗読し、その読みを次の列として使用して列を作ります。
たとえば、<code>211</code>は「1つの2、2つの1」と読み、<code>1221</code>という列になります。</p>
<p>前回の値を次のステップの入力として使用して、look-and-sayの列は反復して生成されます。
各ステップについて、前回の値を取って、
<code>111</code>のようなそれぞれの同じ数字の並びを個数に続けてその数字そのもので置き換えます。</p>
<p>例えば：</p>
<ul>
<li><code>1</code>は<code>11</code>となります。（1つの数字の<code>1</code>）</li>
<li><code>11</code>は<code>21</code>に（2つの数字の1）</li>
<li><code>21</code>は<code>1211</code>に（1つの数字の2、1つの数字の1）</li>
<li><code>1211</code>は<code>111221</code>に（1つの1、1つの2、2つの1）</li>
<li><code>111221</code>は<code>312211</code>に（3つの1、2つの2、1つの1）</li>
</ul>
<p>パズル入力の数字から始めて、このプロセスを40回適用します。
<strong>結果の長さ</strong>はどれだけですか？</p>
<h1 id="パート2-9"><a class="header" href="#パート2-9">パート2</a></h1>
<p>すばらしい！わかった？
あなたは<a href="https://www.youtube.com/watch?v=ea7lJkEhytA">John Conwayのこの列に関する講演</a>
も楽しめるでしょう。
（<strong>Conwayのライフゲーム</strong>のConwayです。）</p>
<p>さて、もう一度あなたのパズル入力の数字で始めて、
このプロセスを<strong>50回</strong>適用してください。
<strong>新しい結果の長さ</strong>はどのくらいですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11日目企業方針"><a class="header" href="#11日目企業方針">11日目：企業方針</a></h1>
<p>サンタの以前のパスワードは期限切れです。
新しいパスワードを選択するのに手助けが必要です。</p>
<p>古いパスワードが期限切れになった後に
新しいパスワードを覚えるのを助けるために、
サンタは前のパスワードに基づいてパスワードを設定する方法を考案しました。
企業の方針では、
セキュリティ上の理由からパスワードは全て小文字で
ちょうど8文字にする必要があるため、
古いパスワード文字列を有効になるまで
繰り返し<strong>インクリメント</strong>して新しいパスワードを探します。</p>
<p>インクリメントはちょうど数字で数えるようなものです。
<code>xx</code>, <code>xy</code>, <code>xz</code>, <code>ya</code>, <code>yb</code>, などと続きます。
一番右の文字を1つ次にしてください。
それが<code>z</code>であった場合は<code>a</code>に巻き戻り、
巻き戻りしなくなるまで左の次の文字について繰り返します。</p>
<p>サンタにとって残念なことに、新しいセキュリティ担当の小人が最近着任しました。
彼はいくつかの追加パスワード要求を課しています。</p>
<ul>
<li>パスワードは少なくとも3文字の連続したインクリメントした並びを一つ含む必要がある。
それは<code>abc</code>, <code>bcd</code>, <code>cde</code> から <code>xyz</code> までのようなものである。
文字をスキップすることはできない。<code>abd</code>はこれに含まれない。</li>
<li>パスワードには文字<code>i</code>, <code>o</code>, <code>l</code> を含めることはできない。
これらの文字は他の文字と間違える可能性があり、
したがって混乱する可能性があるためである。</li>
<li>パスワードは<code>aa</code>, <code>bb</code>, <code>zz</code>のような文字の対を、重なりなく別個に少なくとも2つ含む必要がある。</li>
</ul>
<p>例えば：</p>
<ul>
<li><code>hijklmmn</code> 第1の要件を満たしています。（インクリメント列<code>hij</code>が含まれています。）
しかし第2の要件に失敗しています。（<code>i</code>および<code>l</code>が含まれています。）</li>
<li><code>abbceffg</code> 第3の要件を満たしています。（<code>bb</code>と<code>ff</code>を繰り返しています。）
しかし第1の要件を満たしていません。</li>
<li><code>abbcegjk</code> 第3の要件に失敗します。なぜなら、二重文字がひとつ(<code>bb</code>)しかないからです。</li>
<li><code>abcdefgh</code>の次のパスワードは<code>abcdffaa</code>です。</li>
<li><code>ghijklmn</code>の次のパスワードは<code>ghjaabcc</code>です。
これは<code>i</code>が許されないために<code>ghi...</code>で始まるすべてのパスワードを結局スキップするためです。</li>
</ul>
<p>サンタの現在のパスワード（あなたのパズル入力）が与えられたとき、
彼の<strong>次のパスワード</strong>は何ですか？</p>
<h1 id="パート2-10"><a class="header" href="#パート2-10">パート2</a></h1>
<p>サンタのパスワードが再び期限切れになりました。次は何ですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12日目jsabacusframeworkio"><a class="header" href="#12日目jsabacusframeworkio">12日目：JSAbacusFramework.io</a></h1>
<p>サンタの会計担当小人は、最近の注文後の帳簿のバランスを取るのに手助けか必要です。
残念なことに、彼らの会計ソフトウェアは異様な記録形式を使用しています。
そんなところにあなたが来ました。</p>
<p>彼らはJSON文書を持っています。
それは様々なものを含んでいます。
配列(<code>[1,2,3]</code>)、オブジェクト(<code>{"a":1, "b":2}</code>)、数値、文字列です。
あなたの最初の仕事は、
文書全体からすべての数値を見つけてそれらを足し合わせることです。</p>
<p>例えば：</p>
<ul>
<li><code>[1,2,3]</code>と<code>{"a":2,"b":4}</code>は両方とも合計6です。</li>
<li><code>[[[3]]]</code>と<code>{"a":{"b":4},"c":-1}</code>は両方とも合計3です。</li>
<li><code>{"a":[-1,1]}</code>と<code>[-1,{"a":1}]</code>は両方とも合計0です。</li>
<li><code>[]</code>と<code>{}</code>は両方とも合計0です。</li>
</ul>
<p>文字列に数字が含まれることはありません。</p>
<p>文書内の<strong>すべての数値</strong>の合計はいくつですか？</p>
<h1 id="パート2-11"><a class="header" href="#パート2-11">パート2</a></h1>
<p>あちゃー…会計担当小人は、彼らは赤字をすべて二重に数えたことに気付いた。</p>
<p>値<code>"red"</code>を持つ任意のプロパティを持つオブジェクト（およびそのすべての子）を無視します。
これはオブジェクト(<code>{...}</code>)だけで行い、配列(<code>[...]</code>)では行いません。</p>
<ul>
<li><code>[1,2,3]</code>はやはり合計6です。</li>
<li><code>[1,{"c":"red","b":2},3]</code>は中間のオブジェクトが無視されるため、今は合計4です。</li>
<li><code>{"d":"red","e":[1,2,3,4],"f":5}</code>は構造体全体が無視されるため、今は合計0です。</li>
<li><code>[1,"red",5]</code>は合計6です。配列中の<code>"red"</code>には何の効果もありません。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13日目食卓の騎士"><a class="header" href="#13日目食卓の騎士">13日目：食卓の騎士</a></h1>
<p>この数年間、あなたの家族との休暇の饗宴はあまりうまくいっていませんでした。
皆が仲良しという訳にはいかないのです！
今年はそんな状況を変えようとあなたは決心しました。
<strong>最適な座席の配置</strong>を見つけ、それらの気まずい会話をすべてなくすつもりです。</p>
<p>あなたはまず招待したすべての人のリストと、
彼らが隣に誰が座っているときにその幸福度が増減する量を
すべての組み合わせについて書くことから始めました。
全員が快適にちょうど収まる大きさの円形テーブルがあなたの家にあり、
それぞれの人が2人の隣人を持つことになります。</p>
<p>たとえば、予定されている出席者が4人だけで、次のように幸福度を算出したとします。</p>
<pre><code>Alice would gain 54 happiness units by sitting next to Bob.
Alice would lose 79 happiness units by sitting next to Carol.
Alice would lose 2 happiness units by sitting next to David.
Bob would gain 83 happiness units by sitting next to Alice.
Bob would lose 7 happiness units by sitting next to Carol.
Bob would lose 63 happiness units by sitting next to David.
Carol would lose 62 happiness units by sitting next to Alice.
Carol would gain 60 happiness units by sitting next to Bob.
Carol would gain 55 happiness units by sitting next to David.
David would gain 46 happiness units by sitting next to Alice.
David would lose 7 happiness units by sitting next to Bob.
David would gain 41 happiness units by sitting next to Carol.
</code></pre>
<p>あなたがAliceをDavidの隣に着席させると、Aliceは幸せを2単位を失います。
（Davidがとてもおしゃべりなせいです。）
一方Davidは幸せを46単位得るでしょう。
（Aliceはとても良い聞き手だからです。）
合計で+44です。</p>
<p>テーブルを周って続けて、BobをAliceの隣に座らせるかもしれません。
（Bobは83得て、Aliceは54得る。）
最後にCarolを席に着かせて、隣はBob（Carolは60得て、Bobは7失う）とDavid（Carolは55得て、Davidは41得る）。
配置は次のようになります。</p>
<pre><code>     +41 +46
+55   David    -2
Carol       Alice
+60    Bob    +54
     -7  +83
</code></pre>
<p>この仮定のシナリオで、他のすべての座席配置を試すと、
これが最も最適であり、全体の幸せ度が330となることがわかります。</p>
<p>実際のゲストのリストに対する最適な座席配置における
<strong>幸せ度の合計</strong>はいくつですか？</p>
<h1 id="パート2-12"><a class="header" href="#パート2-12">パート2</a></h1>
<p>大騒ぎの中で、あなたは自分を座らせるのを忘れていたことに気づきます。</p>
<!-- そういやそうだ。ワロス。-->
<p>この点で、あなたは全体に対してかなり無関心であり、
隣に座っている人によってあなたの幸福度は実際のところ上がったり下がったりしません。
あなたは他の人についても、
誰もがあなたが隣に座っていることについて
同様に無関心である(ambivalent ?)と仮定します。</p>
<p>よって、自分自身をリストに追加して、
あなたに関係するすべての幸福関係にスコア0を与えてください。</p>
<p>実際にあなた自身を含む最適な座席配置に対する<strong>幸せ度の合計</strong>はいくつですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14日目トナカイオリンピック"><a class="header" href="#14日目トナカイオリンピック">14日目：トナカイオリンピック</a></h1>
<p>今年はトナカイオリンピックです！
トナカイは高速で飛ぶことができますが、
エネルギーを回復するために時々休まなければなりません。
サンタは、彼のトナカイのどれが最速かを知りたいので、
彼はレースをさせます。(have one race?)</p>
<p>トナカイは<strong>飛行状態</strong>（常に最高速度）
または<strong>休息</strong>（全く動かない）のいずれかで、
すべての時間でいずれかの状態にあります。</p>
<p>たとえば、次のようなトナカイがあるとします。</p>
<ul>
<li>Cometは<strong>14km/sで10秒間</strong>飛行できますが、その後<strong>127秒間</strong>休む必要があります。</li>
<li>Dancerは<strong>16km/sで11秒間</strong>飛行できますが、その後は<strong>162秒間</strong>休む必要があります。</li>
</ul>
<p>1秒後、Cometは14km、Dancerは16km進みました。
10秒後、Cometは140km、Dancerは160km進みました。
11秒目に、Cometは休息を開始し（140kmに留まる）、Dancerは飛び続けて176kmまで進みます。
12秒目には、両方のトナカイが休息しています。
Comentがさらに10秒間飛ぼうとするまでの138秒目まで、
彼らは休み続けます。
174秒目に、Dancerは次の11秒間の飛行を開始します。</p>
<p>この例では、1000秒後に両方のトナカイが休息しており、
Cometが<strong>1120km</strong>で先行しています。
（この時点ではかわいそうなDancerは<strong>1056km</strong>しか進めていません。）
したがって、この状況ではComentが勝ちます（レースが1000秒で終了した場合）。</p>
<p>（あなたのパズル入力として）各トナカイの説明が与えられています。
ちょうど2503秒後に、<strong>優勝したトナカイはどれだけの距離を移動しましたか？</strong></p>
<h1 id="パート2-13"><a class="header" href="#パート2-13">パート2</a></h1>
<p>トナカイが爆発的に動くのを見て、
サンタは自分が古い評価体系に満足していないと判断します。</p>
<p>代わりに、各秒の終わりに、
彼は現在首位であるトナカイに1点を与えます。
（同点一位のトナカイが複数いる場合は、全員がれぞれ1点を得ます。）
彼はもちろん、伝統的な2503秒の制限時間を守りました。
そうしないのは完全にばかげているからです。</p>
<p>上の例のトナカイを考えると、
最初の1秒後、Dancerが先行して1点を獲得します。
彼はComentの2回目の爆発までの数秒の間は先行しつづけます。
140秒後、Cometが先頭に立ち、最初の得点を獲得します。
もちろん、Dancerはそれまでの139秒間は先行していたので、
140秒めまでに139点を貯めています。</p>
<p>1000秒後、Dancerは<strong>689</strong>点を貯めていましたが、
以前の勝者であるかわいそうなCometは312点しか持っていません。
したがって、新しい評価体系ではDancerが勝利します（レースが1000秒で終了した場合）。</p>
<p>今回も（あなたのパズル入力の中の）各トナカイの説明が与えられたとき、
ちょうど2503秒後に、<strong>優勝したトナカイはどれだけの点を獲得しましたか？</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第15日飢えた人々のための科学"><a class="header" href="#第15日飢えた人々のための科学">第15日：飢えた人々のための科学</a></h1>
<p>今日あなたは牛乳浸しクッキーのレシピを完成させる作業を開始しました。
あなたがしなければならないことは、原材料の適切なバランスを見つけることだけです。</p>
<p>あなたのレシピは小さじちょうど100杯の原材料の余地が残っています。
<strong>レシピを完成させるために使用できる残りの原材料</strong>のリスト（パズルの入力）と
小さじ1杯ごとの特性値のリストを作成します。</p>
<ul>
<li><code>capacity</code> （容量：クッキーが牛乳を吸収するのをどれくらい助けるか）</li>
<li><code>durability</code> （耐久：牛乳でいっぱいになったときにクッキーをどのくらい崩れなく保つか）</li>
<li><code>flavor</code> （風味：クッキーをどれだけ美味しくするか）</li>
<li><code>texture</code> （口当たり：クッキーの感触をどれだけよくするか）</li>
<li><code>calories</code> （栄養価：クッキーに追加されるカロリーの量）</li>
</ul>
<p>あなたは原材料を小さじ1杯単位でのみ量り取ることができ、
また今後も結果を再現できるように正確でなければなりません。
クッキーの<strong>総合点</strong>は、
特性値をそれぞれ合算して（負の合計は0となる）、
カロリー以外のすべてを掛け合わせることで得られます。</p>
<p>たとえば、次の2つの原材料があるとします。</p>
<pre><code>Butterscotch: capacity -1, durability -2, flavor 6, texture 3, calories 8
Cinnamon: capacity 2, durability 3, flavor -2, texture -1, calories 3
</code></pre>
<p>すると、バタースコッチを小さじ44杯とシナモンを小さじ56杯使う
（各原材料の量は合計して100になる必要があります）
ことを選択すると、
以下の特性値を有するクッキーが得られます。</p>
<ul>
<li>容量 \(44 \times (-1) + 56 \times 2 = 68\)</li>
<li>耐久 \(44 \times (-2) + 56 \times 3 = 80\)</li>
<li>風味 \(44 \times 6 + 56 \times (-2) = 152\)</li>
<li>口当たり \(44 \times 3 + 56 \times (-1) = 76\)</li>
</ul>
<p>これらを掛け合わせると（\(68 \times 80 \times 152 \times 76\), ここではカロリーは無視します）、
総合点<code>62842880</code>が得られます。
これはこれらの原材料が与えられたときに可能な最高得点です。
いずれかの特性値が負の合計を生成した場合は、
それは零になるので、掛け合わせることで総合点が零になります。</p>
<p>あなたの台所にある原材料その特性値が与えられたとき、
作ることができる最高得点のクッキーの<strong>総合点</strong>はいくらですか？</p>
<h1 id="パート2-14"><a class="header" href="#パート2-14">パート2</a></h1>
<p>あなたのクッキーレシピは大人気になりました！</p>
<p>クッキーひとつがちょうど500カロリーを持つ
別のレシピを作ることができるかどうかを尋ねられました。
（そうすると彼らは食事の代わりとしてそれを使用することができます。）
残りのあなたの受賞歴のあるプロセスは同じにしてください。
（小さじ100杯、同じ材料、同じ採点システム）</p>
<p>例えば、上の材料を考えれば、
代わりに小さじ40杯のバタースコッチと小さじ60杯のシナモンを選択した場合、
（やはり合計で100杯になる必要があります）
合計カロリーは \($40 \times 8 + 60 \times 3 = 500$になります。
ただし総合点はわずか57600000に下がります。
これはこの試行中の状況でできる最高値です。</p>
<p>あなたの台所にある原材料とその特性値を考えて、
500カロリーで作ることができる
最高得点のクッキーの<strong>総合点</strong>はいくらですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="16日目スーおばさん"><a class="header" href="#16日目スーおばさん">16日目：スーおばさん</a></h1>
<p>あなたのスーおばさんはあなたに素晴らしい贈り物をくれました。
そこであなたは彼女に感謝の手紙を送りたいのです。
しかし、ちょっとした問題があります。
彼女は「スーおばさんより」と記名していました。</p>
<p>あなたには「スー」という名前のおばが500人います。</p>
<p>だから、間違った人に手紙を送るのを避けるために、
あなたはどのスーおばさん
（あなたは自分の正気を保つために便宜上1から500の番号を付けています）
があなたに贈り物をしたのかを知る必要があります。
あなたは贈り物を開けます。なんと運のいいことでしょう。
古きよきスーおばさんはあなたにマイファースト犯罪現場分析機をくれました！
まさにあなたが欲しいもの、あるいは必要なもの、です。</p>
<p>マイファースト犯罪現場分析機
（My First Crime Scene Analysis Machine, 略してMFCSAM）は、
与えられたサンプル中のいくつかの特定の化合物、
およびそれらの化合物の種類がいくつあるかを検出することができます。
説明書によると、MFCSAMが検出できるものは以下のとおりです。</p>
<ul>
<li><code>children</code>（子供） 人間のDNA年齢分析ができます。</li>
<li><code>cats</code>（猫） 個々の品種は区別できません。</li>
<li>いくつかの一見ランダムな犬の品種：
<code>samoyeds</code>（サモエド）, <code>pomeranians</code>（ポメラニアン）,
<code>akitas</code>（秋田犬）, <code>vizslas</code>（ショートヘアード・ハンガリアン・ビズラ）</li>
<li><code>goldfish</code>（金魚）それ以外の魚は検出できません。</li>
<li><code>trees</code> （木）1つのグループにまとめられています。</li>
<li><code>cars</code>（車）おそらく排気ガスかガソリンか何かによって。</li>
<li><code>perfumes</code>（香水）あなたのスーおばさんの多くはいくつかを付けているので、これは便利です。</li>
</ul>
<p>実際には、あなたのスーおばさんの多くはこれらの多くを持っています。
あなたは贈り物の包装をMFCSAMに入れました。
それはあなたに数回不思議にビープ音を鳴らしてから
紙テープ(ticker tape)にメッセージをプリントアウトします。</p>
<pre><code>children: 3
cats: 7
samoyeds: 2
pomeranians: 3
akitas: 0
vizslas: 0
goldfish: 5
trees: 3
cars: 2
perfumes: 1
</code></pre>
<p>あなたはそれぞれのスーおばさんについて、思い出せたもののリストを作ります。
あなたのリストには欠けているものは、
あなたが単に数を覚えていなかいということで、
ゼロだという意味ではありません。</p>
<p>あなたに贈り物をしたスーおばさんの<strong>番号</strong>はいくつですか？</p>
<h1 id="パート2-15"><a class="header" href="#パート2-15">パート2</a></h1>
<p>あなたがお礼状を送ろうとしたそのとき、
MFCSAMの説明書の中の何かがあなたの目を引きます。</p>
<p>どうやら、それは旧式のテム＝レイサーキット
（原文では<a href="https://www.youtube.com/watch?v=RXJKdh1KZ0w">retroencabulator</a>, <a href="https://en.wikipedia.org/wiki/Turboencabulator">Wikipedia</a>）
を使っているため、機械からの出力は正確な値ではありません。
それらのいくつかは範囲を示しています。</p>
<p>特に、<code>cats</code>と<code>trees</code>の読み取り値は、
それ<strong>より多く</strong>のものがあることを示しています
（猫のフケと木の花粉の予測できない核崩壊のため）、
一方<code>pomeranians</code>と<code>goldfish</code>の読み取り値は、
それ<strong>より少ない</strong>ことを示しています
（磁気抵抗のモード相互作用による） 。
(modial?)</p>
<p>本物のスーおばさんの<strong>番号</strong>は何でしょう？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="17日目多くていけないものはない"><a class="header" href="#17日目多くていけないものはない">17日目：多くていけないものはない</a></h1>
<p>小人はまたもや卵酒を買いすぎました、今度は150リットル。
それをすべてあなたの冷蔵庫に収めるには、小さな容器に移す必要があります。
あなたは利用可能な容器の容量のリストを書きます。</p>
<p>たとえば、あなたが20, 15, 10, 5, 5リットルの容器を持っているとします。
25リットルを保管する必要がある場合は、4つの方法があります。</p>
<ul>
<li>15と10</li>
<li>20と5（ひとつめの5）</li>
<li>20と5（ふたつめの5）</li>
<li>15, 5, 5</li>
</ul>
<p>使う容器はいっぱいにして使うという条件で、
150リットルの卵酒をちょうど収める
<strong>容器の異なる組み合わせ</strong>
はいくつありますか？</p>
<h1 id="パート2-16"><a class="header" href="#パート2-16">パート2</a></h1>
<p>台所のあるだけの容器で遊んでいる間に、卵酒の別の配達が到着しました！
出荷部門と受入部門は、できるだけ多くの容器を使えるようにしておくことを求めています。</p>
<p>150リットルの卵酒をぴったり入れられる容器の最小数を見つけてください。
その数の容器をいっぱいにしてちょうど150リットルを保持できる<strong>方法はいくつありますか？</strong></p>
<p>上記の例では、容器の最小数は2です。
その数の容器をを使用する方法は3とおりあり、
よって答は3となります。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="18日目あなたの庭のgifアニメ"><a class="header" href="#18日目あなたの庭のgifアニメ">18日目：あなたの庭のGIFアニメ</a></h1>
<p>100万灯ライト事件の後、防火条例がより厳しくなりました。
今では許されるのは1万本までのライトです。
あなたはそれを \(100 \times 100\) の碁盤状に並べました。</p>
<p>あなたを失望させることは絶対にありません、
サンタは今回も理想的な照明の構成の手順をメールであなたに送りました。
それほど少ない数のライトでは、彼の言うには、
<strong>アニメーション</strong>の力を借りる必要があるとのことです。</p>
<p>同封した初期状態（あなたのパズル入力）にライトを構成して始めます。
<code>#</code>は点灯、<code>.</code>は消灯を表します。</p>
<p>そして、ステップであなたのグリッドをアニメーションさせてください。
各ステップでは現在の構成に基づいて次の構成を決定します。
それぞれのライトの次の状態（点灯または消灯）は
その現在の状態とそれに隣接（斜めも含む）する8個のライトの
現在の状態に依存しています。
グリッドの縁にあるライトは隣人が8より少ないですが、欠けている部分は常に消灯として数えます。</p>
<p>例えば、下の単純化した6x6のグリッドで、
<code>A</code>と印したライトは1から8の隣人を持ちますが、
<code>B</code>と印したライトは縁にあるので、1から5の隣人しかありません。</p>
<pre><code>1B5...
234...
......
..123.
..8A4.
..765.
</code></pre>
<p>ライトの次の状態は現在の状態（点灯または消灯）と
<strong>点灯している隣人の数</strong>に基づいて決まります。</p>
<ul>
<li><strong>点灯</strong>しているライトは
点灯している隣人が2または3であるとき点灯を続け、
さもなくば消灯します。</li>
<li><strong>消灯</strong>しているライトは
点灯している隣人がちょうど3のとき点灯し、
さもなくば消灯し続けます。</li>
</ul>
<p>すべてのライトは同時に更新されます。
ライトはみな同じ現在の状態で考えて次の状態に動きます。</p>
<p>6x6グリッドの構成例での動作ステップを示します。</p>
<p>初期状態：</p>
<pre><code>.#.#.#
...##.
#....#
..#...
#.#..#
####..
</code></pre>
<p>1ステップ後：</p>
<pre><code>..##..
..##.#
...##.
......
#.....
#.##..
</code></pre>
<p>2ステップ後：</p>
<pre><code>..###.
......
..###.
......
.#....
.#....
</code></pre>
<p>3ステップ後：</p>
<pre><code>...#..
......
...#..
..##..
......
......
</code></pre>
<p>4ステップ後：</p>
<pre><code>......
......
..##..
..##..
......
......
</code></pre>
<p>4ステップ後、この例は4つのライトが点灯しています。</p>
<p>あなたの100x100のライトで、与えられた初期構成で、
<strong>100ステップ後にはいくつのライトが点灯していますか？</strong></p>
<h1 id="パート2-17"><a class="header" href="#パート2-17">パート2</a></h1>
<p>あなたは手順書をペラっとめくりました。
サンタからのメッセージの続きに、これは単にConwayのライフゲームの実装に過ぎないという指摘がありました。
少なくとも、購入したライトのグリッドに問題があることに気づくまでは。
4つの角に1つずつあるライトが<strong>点灯しっぱなし</strong>で消灯できません。
上記の例は、実際には次のようになります。</p>
<p>初期状態：</p>
<pre><code>##.#.#
...##.
#....#
..#...
#.#..#
####.#
</code></pre>
<p>1ステップ後：</p>
<pre><code>#.##.#
####.#
...##.
......
#...#.
#.####
</code></pre>
<p>2ステップ後：</p>
<pre><code>#..#.#
#....#
.#.##.
...##.
.#..##
##.###
</code></pre>
<p>3ステップ後：</p>
<pre><code>#...##
####.#
..##.#
......
##....
####.#
</code></pre>
<p>4ステップ後：</p>
<pre><code>#.####
#....#
...#..
.##...
#.....
#.#..#
</code></pre>
<p>5ステップ後：</p>
<pre><code>##.###
.##..#
.##...
.##...
#.#...
##...#
</code></pre>
<p>5ステップ後、この例では17ライトが点灯しています。</p>
<p>あなたの100x100のライトで、与えられた初期構成で、
ただし角の4つのライトは常に<strong>点灯</strong>しているとき、
<strong>100ステップ後にはいくつのライトが点灯していますか？</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="19日目ルドルフのための薬"><a class="header" href="#19日目ルドルフのための薬">19日目：ルドルフのための薬</a></h1>
<p>赤鼻のトナカイのルドルフは病気です！
彼の鼻はあまり明るく輝いていません、
そして彼は薬を必要としています。</p>
<p>赤鼻のトナカイ生物学は通常のトナカイ生物学と似ていません。
ルドルフは特製の薬を必要とするでしょう。
残念なことに、赤鼻のトナカイ化学も通常のトナカイ化学と似ていません。</p>
<p>北極には赤鼻のトナカイ核融合・核分裂プラントが装備されており、
必要なあらゆる赤鼻のトナカイ分子を構築することができます。
それはいくつかの入力分子から始めて、
それからそれが正しい分子を持つまでステップごとに1つの、
一連の<strong>置換</strong>をすることによって働きます。</p>
<p>ただし、この装置は使用する前に校正する必要があります。
校正は、与えられた出発点から1ステップで生成され得る分子の数を決定することで行います。</p>
<p>たとえば、以下の置換のみに対応した、ずっと単純な装置を想像してみてください。</p>
<pre><code>H =&gt; HO
H =&gt; OH
O =&gt; HH
</code></pre>
<p>上記の置換が与えられ、<code>HOH</code>から始めると、
次のような分子が生成される可能性があります。</p>
<ul>
<li><code>HOOH</code> （1番目の<code>H</code>に<code>H =&gt; HO</code>）</li>
<li><code>HOHO</code> （2番目の<code>H</code>に<code>H =&gt; HO</code>）</li>
<li><code>OHOH</code> （1番目の<code>H</code>に<code>H =&gt; OH</code>）</li>
<li><code>HOOH</code> （2番目の<code>H</code>に<code>H =&gt; OH</code>）</li>
<li><code>HHHH</code> （<code>O =&gt; HH</code>）</li>
</ul>
<p>よって、上記の例では、<code>HOH</code>からの1回の置換の後に、
<strong>4種類</strong>の異なる分子があります。
（<code>HOOH</code>が2回出現するため5種類ではありません。）
サンタのお気に入りの分子<code>HOHOHO</code>は、
（<code>H</code>から6つ、<code>O</code>から3つの9個の置換を経て）
<strong>7種類</strong>の分子になることができます。</p>
<p>装置は周囲の文字を無視して置換します。
たとえば、文字列<code>H2O</code>が与えられると、遷移<code>H =&gt; OO</code>により<code>OO2O</code>となります。</p>
<p>あなたのパズル入力はすべての可能な置換について説明しています。
そして最下部に、あなたが装置を校正するのに必要な薬品分子があります。
薬品分子に1つの置換を行うことができるすべてのさまざまな方法の後に、
<strong>何種類の異なる分子を作成することができますか？</strong></p>
<h1 id="パート2-18"><a class="header" href="#パート2-18">パート2</a></h1>
<p>これで装置は校正されたので、分子製造を始める準備が整いました。</p>
<p>分子製造は、常に単一の電子だけから始まります。
そして校正のときと同様に、一度にひとつの置換を適用します。</p>
<p>たとえば、次のような置換があるとします。</p>
<pre><code>e =&gt; H
e =&gt; O
H =&gt; HO
H =&gt; OH
O =&gt; HH
</code></pre>
<p><code>HOH</code>を作成したいならば、<code>e</code>から始め、次のように置換します。</p>
<ul>
<li><code>e =&gt; O</code> これは<code>O</code>を得るため</li>
<li><code>O =&gt; HH</code> これは<code>HH</code>を得るため</li>
<li><code>H =&gt; OHH</code> （2番目の<code>H</code>に）これで<code>HOH</code>を得る</li>
</ul>
<p>よって、<strong>3ステップ</strong>で<code>HOH</code>を作ることができます。
サンタの好きな分子<code>HOHOHO</code>は<strong>6ステップ</strong>で作ることができます。</p>
<p>薬を作るのにどれくらいかかりますか？
あなたのパズル入力にある
利用可能な<strong>置換</strong>と<strong>薬の分子</strong>を考えるとき、
<code>e</code>から薬の分子に行くための<strong>最小のステップ数</strong>はいくつですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="20日目無限の小人と無限の家"><a class="header" href="#20日目無限の小人と無限の家">20日目：無限の小人と無限の家</a></h1>
<p>小人たちを忙しくしておくために、サンタは彼らにいくつかのプレゼントを
ドアからドアへ、手渡しで配達させます。
サンタは小人たちを
順に番号が1,2,3,4,5…と振られている家が無限に並ぶ通りに
送り込みました。</p>
<p>各小人にも番号が割り当てられており、
その番号に基づいて家にプレゼントを配達します。</p>
<ul>
<li>1番目の小人（1番）はすべての家にプレゼントを配達します。1, 2, 3, 4, 5, …</li>
<li>2番目の小人（2番）はひとつおきの家にプレゼントを配達します。2, 4, 6, 8, 10, …</li>
<li>3番目の小人はふたつおきのすべての家にプレゼントを配達します。3, 6, 9, 12, 15, …</li>
</ul>
<p>1で始まる番号が付けられた無数の小人がいます。
各小人は家ごとに自分の数の10倍に相当するプレゼントを配達します。</p>
<p>よって、通りの最初の9つの家は最終的に次のようになります。</p>
<pre><code>House 1 got 10 presents.
House 2 got 30 presents.
House 3 got 40 presents.
House 4 got 70 presents.
House 5 got 60 presents.
House 6 got 120 presents.
House 7 got 80 presents.
House 8 got 150 presents.
House 9 got 130 presents.
</code></pre>
<p>1番目の家はプレゼント10個受け取ります。
それはプレゼントを \(1 \times 10\) 個届ける1番の小人によってのみ訪問されます。
4番目の家は番号1,2,4の小人が訪れているので、
合計で \(10 + 20 + 40 = 70\) 個のプレゼントを受け取ります。</p>
<p>あなたのパズル入力の数と少なくとも同じだけの数のプレゼントを得る家の、
<strong>最も小さい家番号</strong>は何番ですか？</p>
<h1 id="パート2-19"><a class="header" href="#パート2-19">パート2</a></h1>
<p>小人たちは無限の数の家を訪れたくないと考えました。
代わりに、小人はそれぞれ50軒にプレゼントを配達した後に停止します。
それを補うために、
彼らは各家で自分の番号の11倍に相当するプレゼントを届けることにしました。</p>
<p>これらの変更により、
あなたのパズル入力の数と少なくとも同じ数のプレゼントを得る家の
新しい<strong>最小の家番号</strong>は何番ですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21日目rpgシミュレータ20xx"><a class="header" href="#21日目rpgシミュレータ20xx">21日目：RPGシミュレータ20XX</a></h1>
<p>Little Henry Caseがクリスマス用の新しいビデオゲームを手に入れました。
それはRPGです、そして、彼はボスで立ち往生しています。
彼は店でどんな装備を買うべきかを知る必要があります。
彼はあなたにコントローラーを渡します。</p>
<p>このゲームでは、プレイヤー（あなた）と敵（ボス）が交互に攻撃します。
常にプレイヤーが最初に行動します。
各攻撃は相手のヒットポイントを少なくとも1減少させます。
先にヒットポイント0以下になったキャラクターが負けます。</p>
<p>各ターンに攻撃側によって与えられるダメージは、
攻撃側のダメージスコアから防御側のアーマースコアを引いたものになります。
攻撃者は常に少なくとも1ダメージを与えます。
したがって、攻撃側のダメージスコアが8で、
防御側のアーマースコアがである3場合、
防御側は5ヒットポイントを失います。
防御側のアーマースコアが300であれば、
防御側は依然として1ヒットポイントを失います。</p>
<p>あなたのダメージスコアとアーマースコアは両方ともゼロから始まります。
それらは金と引き換えにアイテムを購入することで増やすことができます。
始めあなたはアイテムなしで、お金はいくらでも必要なだけ持っています。
あなたの総ダメージスコアやアーマースコアは
あなたのアイテム全てからのそれらの属性値の合計になります。
あなたは<strong>100ヒットポイント</strong>を持っています。</p>
<p>これがアイテムショップで売っているものです。</p>
<pre><code>Weapons:    Cost  Damage  Armor
Dagger        8     4       0
Shortsword   10     5       0
Warhammer    25     6       0
Longsword    40     7       0
Greataxe     74     8       0

Armor:      Cost  Damage  Armor
Leather      13     0       1
Chainmail    31     0       2
Splintmail   53     0       3
Bandedmail   75     0       4
Platemail   102     0       5

Rings:      Cost  Damage  Armor
Damage +1    25     1       0
Damage +2    50     2       0
Damage +3   100     3       0
Defense +1   20     0       1
Defense +2   40     0       2
Defense +3   80     0       3
</code></pre>
<p>あなたは武器を一つだけ購入しなければなりません。二刀流ではありません。
防具はオプションですが、複数使用することはできません。
あなたは0～2個の指輪を購入することができます（両手にそれぞれ最大1個）。
あなたはあなたが買ったアイテムを全て使わなければなりません。
ショップには各アイテムが1つしかないので、
例えばダメージ+3の指輪を2つ買うことはできません。</p>
<p>たとえば、あなたは8ヒットポイント、5ダメージスコア、5アーマースコアを持ち、
ボスは12ヒットポイント、7ダメージスコア、2アーマースコアを持つとします。</p>
<ul>
<li>プレイヤーは \(5-2 = 3\) ダメージを与えます。ボスは9ヒットポイントになります。</li>
<li>ボスは \(7-5 = 2\) ダメージを与えます。プレイヤーは6ヒットポイントになります。</li>
<li>プレイヤーは \(5-2 = 3\) ダメージを与えます。ボスは6ヒットポイントになります。</li>
<li>ボスは \(7-5 = 2\) ダメージを与えます。プレイヤーは4ヒットポイントになります。</li>
<li>プレイヤーは \(5-2 = 3\) ダメージを与えます。ボスは3ヒットポイントになります。</li>
<li>ボスは \(7-5 = 2\) ダメージを与えます。プレイヤーは2ヒットポイントになります。</li>
<li>プレイヤーは \(5-2 = 3\) ダメージを与えます。ボスは0ヒットポイントになります。</li>
</ul>
<p>このシナリオでは、（かろうじて）プレイヤーが勝ちます！</p>
<p>あなたは<strong>100ヒットポイント</strong>を持っています。
ボスの実際の属性値はあなたのパズルの入力にあります。
あなたが使う<strong>最小の、それでも戦いに勝つことができる金額</strong>はいくらですか？</p>
<h1 id="パート2-20"><a class="header" href="#パート2-20">パート2</a></h1>
<p>店主がボスと通じていることが判明しました。
店主はそうしたいものを何でも、あなたに買うように説得することができます。
他の規則はまだ適用され、彼はやはり各アイテムを1つずつしか持っていません。</p>
<p>あなたが使う<strong>最大の、それでも戦いに負けることになる金額</strong>はいくらですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22日目魔法使いシミュレータ20xx"><a class="header" href="#22日目魔法使いシミュレータ20xx">22日目：魔法使いシミュレータ20XX</a></h1>
<p>Little Henry Caseは、刀や杖でボスを倒すのは退屈だと判断しました。
今、彼は魔法使いでゲームをしています。
もちろん、彼は別のボスに立ち往生しているし、もう一度あなたの助けが必要です。</p>
<p>このバージョンでは、プレイヤーとボスが交互に交代しながら戦闘が進行します。
プレイヤーはやはり先に行動します。
しかし今、あなたは装備を持っていません。
代わりに、あなたは唱えるためにあなたの呪文の1つを選ばなければなりません。
先にヒットポイント0以下になったキャラクターが負けます。</p>
<p>あなたは魔法使いなので、あなたは鎧を着ることができず、
あなたは普通に攻撃することはできません。
しかし、あなたは<strong>魔法のダメージを与える</strong>ので、
あなたの対戦相手の装甲は無視され、そのためボスも事実上装甲は零です。
以前のように、（この場合、呪文からの）装甲がダメージを1未満に減少させるのであれば、
それは代わりに1になります。
つまり、ボスの攻撃は常に少なくとも1ダメージを与えます。</p>
<p>あなたの各ターンに、
あなたは唱えるためにあなたの呪文の一つを選ぶ必要があります。
呪文を唱える余裕がない場合、あなたは負けます。
呪文は<strong>マナ</strong>を消費します。
あなたは<strong>500</strong>マナから始めますが、上限はありません。
あなたは呪文を唱えるのに十分なマナを持っていなければならず、
あなたがそれを唱えたときにそのコストは即座に差し引かれます。
あなたの呪文はマジックミサイル、ドレイン、シールド、ポイズン、リチャージです。</p>
<ul>
<li><strong>マジックミサイル</strong>は53マナかかります。即座に4ダメージを与えます。</li>
<li><strong>ドレイン</strong>は73マナがかかります。
それは即座に2ダメージを与え、2ヒットポイントを回復します。</li>
<li><strong>シールド</strong>は113マナがかかります。
それは6ターン持続する<strong>効果</strong>を開始します。
それがアクティブになっている間、あなたのアーマースコアは7増加します。</li>
<li><strong>ポイズン</strong>は173マナかかります。
それは6ターン持続する<strong>効果</strong>を開始します。
それがアクティブである間、各ターンの開始時に、それはボスに3ダメージを与えます。</li>
<li><strong>リチャージ</strong>は229マナかかります。
それは5ターン持続する<strong>効果</strong>を開始します。
それがアクティブになっている間、各ターンの開始時に、
それはあなたに新しいマナを101与えます。</li>
</ul>
<p><strong>効果</strong>はすべて同じように機能します。
効果はプレイヤーのターンとボスのターンの両方の開始時に適用されます。
効果はタイマー（それらが持続するターン数）を伴って作成されます。
各ターンの開始時に、彼らが持っている効果を適用した後、
それらのタイマーは1減少します。
これによりタイマーが零になると、効果は終了します。
あなたはすでにアクティブになっている効果を開始する呪文を唱えることはできません。
ただし、効果はそれらが終了するのと同じターンに開始することができます。</p>
<p>たとえば、プレイヤーに10ヒットポイントと250マナがあり、
ボスに13ヒットポイントと8ダメージがあるとします。</p>
<pre><code>-- Player turn --
- Player has 10 hit points, 0 armor, 250 mana
- Boss has 13 hit points
Player casts Poison.

-- Boss turn --
- Player has 10 hit points, 0 armor, 77 mana
- Boss has 13 hit points
Poison deals 3 damage; its timer is now 5.
Boss attacks for 8 damage.

-- Player turn --
- Player has 2 hit points, 0 armor, 77 mana
- Boss has 10 hit points
Poison deals 3 damage; its timer is now 4.
Player casts Magic Missile, dealing 4 damage.

-- Boss turn --
- Player has 2 hit points, 0 armor, 24 mana
- Boss has 3 hit points
Poison deals 3 damage. This kills the boss, and the player wins.
</code></pre>
<p>それでは、
ボスが代わりに14ヒットポイントを持っていることを除いて、
同じ初期条件を仮定します。</p>
<pre><code>-- Player turn --
- Player has 10 hit points, 0 armor, 250 mana
- Boss has 14 hit points
Player casts Recharge.

-- Boss turn --
- Player has 10 hit points, 0 armor, 21 mana
- Boss has 14 hit points
Recharge provides 101 mana; its timer is now 4.
Boss attacks for 8 damage!

-- Player turn --
- Player has 2 hit points, 0 armor, 122 mana
- Boss has 14 hit points
Recharge provides 101 mana; its timer is now 3.
Player casts Shield, increasing armor by 7.

-- Boss turn --
- Player has 2 hit points, 7 armor, 110 mana
- Boss has 14 hit points
Shield's timer is now 5.
Recharge provides 101 mana; its timer is now 2.
Boss attacks for 8 - 7 = 1 damage!

-- Player turn --
- Player has 1 hit point, 7 armor, 211 mana
- Boss has 14 hit points
Shield's timer is now 4.
Recharge provides 101 mana; its timer is now 1.
Player casts Drain, dealing 2 damage, and healing 2 hit points.

-- Boss turn --
- Player has 3 hit points, 7 armor, 239 mana
- Boss has 12 hit points
Shield's timer is now 3.
Recharge provides 101 mana; its timer is now 0.
Recharge wears off.
Boss attacks for 8 - 7 = 1 damage!

-- Player turn --
- Player has 2 hit points, 7 armor, 340 mana
- Boss has 12 hit points
Shield's timer is now 2.
Player casts Poison.

-- Boss turn --
- Player has 2 hit points, 7 armor, 167 mana
- Boss has 12 hit points
Shield's timer is now 1.
Poison deals 3 damage; its timer is now 5.
Boss attacks for 8 - 7 = 1 damage!

-- Player turn --
- Player has 1 hit point, 7 armor, 167 mana
- Boss has 9 hit points
Shield's timer is now 0.
Shield wears off, decreasing armor by 7.
Poison deals 3 damage; its timer is now 4.
Player casts Magic Missile, dealing 4 damage.

-- Boss turn --
- Player has 1 hit point, 0 armor, 114 mana
- Boss has 2 hit points
Poison deals 3 damage. This kills the boss, and the player wins.
</code></pre>
<p>あなたは<strong>50ヒットポイント</strong>と<strong>500マナポイント</strong>から始めます。
ボスの実際の属性値はあなたのパズルの入力にあります。
あなたが使うことができ、それでも戦いに勝てる<strong>マナの最小量</strong>は何ですか？
（リチャージの効果を負のマナを「支出する」として含めないでください。）</p>
<h1 id="パート2-21"><a class="header" href="#パート2-21">パート2</a></h1>
<p>次回のゲームでは、難易度を「ハード」に上げます。</p>
<p>各<strong>プレイヤーターン</strong>の開始時（他の効果が適用される前）に、
あなたは1ヒットポイントを失います。
これで0ヒットポイント以下になった場合、あなたは負けます。</p>
<p>あなたとボスの開始属性値は上と同じで、
あなたが使うことができて、まだ戦いに勝つことができる<strong>マナの最小量</strong>は何ですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="23日目チューリングロックを開く"><a class="header" href="#23日目チューリングロックを開く">23日目：チューリングロックを開く</a></h1>
<p>Little Jane Marieはとある篤志家からクリスマスに彼女の最初のコンピュータを贈られました。
説明書とサンプルプログラムが付属していますが、コンピュータ自体が誤動作しているようです。
彼女はそのプログラムが何をするのか知りたがっているので、
彼女がそれを実行するのをあなたに手伝ってほしいのです。</p>
<p>このマニュアルでは、
コンピュータが2つのレジスタと6つの命令をサポートしていると説明しています。
（本当に、読者に確認しておくと、これは最新技術です。）
レジスタには<code>a</code>と<code>b</code>という名前が付けられ、負でない整数を保持できます。
値が0の状態で始まります。
命令は次のとおりです。</p>
<ul>
<li><code>hlf r</code> レジスタrを現在の値の<strong>半分に</strong>設定してから、次の命令に進みます。</li>
<li><code>tpl r</code> レジスタrを現在の値の<strong>3倍に</strong>設定してから、次の命令に進みます。</li>
<li><code>inc r</code> レジスタrを<strong>インクリメント</strong>する、すなわちそれに1を足して、次の命令に進みます。</li>
<li><code>jmp offset</code> は<strong>ジャンプ</strong>です。
それはそれ自身に対して相対的に<code>offset</code>離れた命令に進みます。</li>
<li><code>jie r, offset</code> は<code>jmp</code>に似ていますが、
レジスタrが偶数の場合にのみジャンプします。
（jump if even 「偶数の場合はジャンプ」）</li>
<li><code>jio r, offset</code> は<code>jmp</code>に似ていますが、
レジスタrが1の場合にのみジャンプします。
（jump if one 「1であればジャンプ」「奇数」ではないので注意。）</li>
</ul>
<p>3つのジャンプ命令はすべて、その命令に対する相対的<strong>オフセット</strong>で機能します。
オフセットは常にジャンプの方向を示す接頭辞<code>+</code>または<code>-</code>を付けて
（それぞれ順方向または逆方向）書かれます。
例えば、<code>jmp +1</code>は単に次の命令に進むだけで、
<code>jmp +0</code>は継続的にそれ自体に永遠に戻ります。</p>
<p>プログラムは、定義されている命令を超えて命令を実行しようとすると終了します。</p>
<p>たとえば、このプログラムは、<code>a</code>を<code>2</code>に設定します。
それは<code>jio</code>命令によって<code>tpl</code>命令がスキップされるためです。</p>
<pre><code>inc a
jio a, +2
tpl a
inc a
</code></pre>
<p>あなたのパズル入力のプログラムが実行を終了したときの<strong>レジスタbの値</strong>は何ですか？</p>
<h1 id="パート2-22"><a class="header" href="#パート2-22">パート2</a></h1>
<p>匿名の篤志家はあなたがまんまと騙されて結果を出してくれたこと、ではなくて、
コンピュータのことでLittle Jane Marieを助けてくれたことを<strong>とても</strong>感謝しています。
レジスタaが代わりに1で始まった場合、
プログラムが実行を終了したときのレジスタbの値は何ですか？
という問題は、決してあなたを失望させることはないでしょう。
（ちょっと英語がよくわからない。）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="24日目バランスしてぶら下がっている"><a class="header" href="#24日目バランスしてぶら下がっている">24日目：バランスしてぶら下がっている</a></h1>
<p>クリスマスイブです、そしてサンタは今年の配達のためにそりに積み込んで​​います。
しかし、1つ小さな問題があります。
彼はそりのバランスをとることができません。
バランスが取れていなければ、彼は物理学に逆らうことはできず、
そして今年誰もプレゼントをもらうことができません。</p>
<p>無理をしないで。</p>
<p>サンタはそりにうまく詰め込む必要のあるすべての包みの重量のリストをあなたに提供しました。
包みは、<strong>まったく同じ重さの3つのグループ</strong>に分割する必要があり、
すべての包みを収める必要があります。
最初のグループはそりの客室に行き、
2番目と3番目のグループは左右のコンテナに入ります。
3つのグループすべてがまったく同じ重さになったときにのみ、そりは飛ぶことができます。
物理学に反することには規則があります、わかりますね！</p>
<p>もちろん、それだけが問題ではありません。
最初のグループ、つまり客室内に移動するグループは、
サンタの足元に余裕を持たせるために、
<strong>包みの数をできるだけ少なく</strong>する必要があります。
すべてのグループの重量が同じであれば、
他の2つのグループにはいくつ包みが含まれていてもかまいません。</p>
<p>さらに、サンタは、
可能な限り少ないものが最初のグループになるように包みを配置する方法が複数ある場合、
最初のグループが最小の<strong>量子もつれ</strong> (Quantum Entanglement)を持つ方法を選択して、
「複雑化」(complication, 合併症？) の可能性を減らすようにする必要があります。
包みのグループの量子もつれは、それらの重みの積、つまり、それらの重みを掛け合わせたときに得られる値です。
すべてのグループの重量が同じでかつ
最初のグループに含まれる可能性のある包みの数が最も少ない場合にのみ、量子もつれを考慮してください。</p>
<p>たとえば、1から5と7から11の重みを持つ10の包みがあるとします。
この状況に関して、
いくつかの一意な最初のグループ、その量子もつれ、
そして残りの包みを分割する方法は以下の通りです。</p>
<pre><code>Group 1;             Group 2; Group 3
11 9       (QE= 99); 10 8 2;  7 5 4 3 1
10 9 1     (QE= 90); 11 7 2;  8 5 4 3
10 8 2     (QE=160); 11 9;    7 5 4 3 1
10 7 3     (QE=210); 11 9;    8 5 4 2 1
10 5 4 1   (QE=200); 11 9;    8 7 3 2
10 5 3 2   (QE=300); 11 9;    8 7 4 1
10 4 3 2 1 (QE=240); 11 9;    8 7 5
9 8 3      (QE=216); 11 7 2;  10 5 4 1
9 7 4      (QE=252); 11 8 1;  10 5 3 2
9 5 4 2    (QE=360); 11 8 1;  10 7 3
8 7 5      (QE=280); 11 9;    10 4 3 2 1
8 5 4 3    (QE=480); 11 9;    10 7 2 1
7 5 4 3 1  (QE=420); 11 9;    10 8 2
</code></pre>
<p>これらのうち、<code>10 9 1</code>が最も小さい量子もつれ（90）を持っていますが、
2つの包みだけからなる構成<code>11 9</code>が、
客室内にあるときサンタに最も大きな足元の余裕を与えて勝ちます。
この状況では、理想的な配置に対する量子もつれは99です。
最初のグループに包みが2つしかない構成が2つあった場合は、
より小さな量子もつれを持つ構成が選択されます。</p>
<p>理想的な構成における包みの最初のグループの<strong>量子もつれ</strong>はいくつですか？</p>
<h1 id="パート2-23"><a class="header" href="#パート2-23">パート2</a></h1>
<p>何か変です…そりはまだバランスが取れていません。</p>
<p>「ホーホーホー」サンタは自分自身に夢中になります。「トランクを忘れた。」</p>
<p>再びそりのバランスを取りますが、今回は、包みを3つではなく4つのグループに分けます。
他の制約は依然として適用されます。</p>
<p>上記の包みの例を考えたときの、いくつかの新しい一意な最初のグループ、
それらの量子もつれ、そして残りの包みを分割する方法の一つを示します。</p>
<pre><code>11 4    (QE=44); 10 5;   9 3 2 1; 8 7
10 5    (QE=50); 11 4;   9 3 2 1; 8 7
9 5 1   (QE=45); 11 4;   10 3 2;  8 7
9 4 2   (QE=72); 11 3 1; 10 5;    8 7
9 3 2 1 (QE=54); 11 4;   10 5;    8 7
8 7     (QE=56); 11 4;   10 5;    9 3 2 1
</code></pre>
<p>このうち、そこに最初のグループに包みの最小の個数（2）を置く構成が3つあります。
<code>11 4</code>, <code>10 5</code>, <code>8 7</code>です。
これらの中で、<code>11 4</code>が量子もつれが最小なので、それが選択されます。</p>
<p>さて、理想的な構成における包みの最初のグループの<strong>量子もつれ</strong>はいくつですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="25日目雪よ降れ"><a class="header" href="#25日目雪よ降れ">25日目：雪よ降れ</a></h1>
<p>メリークリスマス！
サンタはお天気制御装置を起動しています。
あなたは結局<a href="2015/./day1.html">ホワイトクリスマス</a>を得られそうです。</p>
<p>お天気制御装置がビービーと鳴りました！
装置のコンソールには、
取扱説明書のコードを入力するように求めるコピー防止メッセージが出ています。
どうやら、あなたがそのコードを与えない限り、それは実行を拒否するようです。
別に問題はありません。あなたはマニュアルからコードを調べるでしょう…</p>
<p>「ホー、ホー、ホー」サンタは大声で熟考します。
「マニュアルを見つけ出せる気がしない。」</p>
<p>製造元のサポート電話番号を調べて、電話をかけます。
良いこともあります - その49番目のスターはそれ自体で稼ぐことはできませんでした。
(???)</p>
<p>「ああ、その機械はかなり古いです！」と彼らは言います。
「そのモデルは6分前にサポートを終了しました。
そして、私たちはすべてのマニュアルをシュレッダーにかけたばかりです。
ただし、コード生成アルゴリズムを見つけることができると思います。」</p>
<p>20分間保留にされた後
（あなたの電話は彼らにとって非常に重要であると何度も思い出させられました）、
ようやくコードシステムの仕組みを覚えているエンジニアが見つかりました。</p>
<p>コードは、左上隅から始まる無限の紙に印刷されています。
コードは対角線で埋められます。
空の最初のマスを1つもつ最初の行から始まり、コードは斜めに上と右に向かって埋められます。
このプロセスは、
<a href="https://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%B3%E3%83%88%E3%83%BC%E3%83%AB%E3%81%AE%E5%AF%BE%E8%A7%92%E7%B7%9A%E8%AB%96%E6%B3%95">無限の紙が覆われる</a>
まで繰り返されます。
よって、最初のいくつかのコードは次の順序で埋められます。</p>
<pre><code>   | 1   2   3   4   5   6
---+---+---+---+---+---+---+
 1 |  1   3   6  10  15  21
 2 |  2   5   9  14  20
 3 |  4   8  13  19
 4 |  7  12  18
 5 | 11  17
 6 | 16
</code></pre>
<p>たとえば、12番目のコードは4行2列に書き込まれます。
15番目のコードは1行5列に書き込まれます。</p>
<p>電話の向こうの声は、続けてコードが実際にどのように生成されるかを説明します。
最初のコードは<code>20151125</code>です。
その後、各コードは、前のコードに<code>252533</code>を乗算してから、
その値を<code>33554393</code>で除算した余りとして生成されます。</p>
<p>したがって、2番目のコード（2行1列にくる）を見つけるには、
前の値<code>20151125</code>から始めます。
それに<code>252533</code>を掛けて<code>5088824049625</code>を得ます。
そしてそれを<code>33554393</code>で割ると余りが<code>31916031</code>となります。
この余りが2番目のコードです。</p>
<p>「ああ！」と声がします。
「マニュアルにコードのページがあるのを見落としていたようです。読んでみましょう。」
あなたは彼の読み上げる番号を書き留めます。</p>
<pre><code>   |    1         2         3         4         5         6
---+---------+---------+---------+---------+---------+---------+
 1 | 20151125  18749137  17289845  30943339  10071777  33511524
 2 | 31916031  21629792  16929656   7726640  15514188   4041754
 3 | 16080970   8057251   1601130   7981243  11661866  16474243
 4 | 24592653  32451966  21345942   9380097  10600672  31527494
 5 |    77061  17552253  28094349   6899651   9250759  31663883
 6 | 33071741   6796745  25397450  24659492   1534922  27995004
</code></pre>
<p>「さて、覚えておいて」声は続きます。
「それは最初のいくつかの数字のすべてでさえありません。
例えば、あなたは行6列2の前に来るはずの行7列1の内容がありません。
でもこれだけ判っていれば充分で…
ああ、昼食の時間だよ、さようなら」通話が切断されます。</p>
<p>サンタはオロオロしています。
あなたのパズル入力には、装置のコンソールにあるメッセージが含まれています。
<strong>あなたは装置にどんなコードを与えますか？</strong></p>
<h1 id="パート2-24"><a class="header" href="#パート2-24">パート2</a></h1>
<p>装置は活気を取り戻し、その後また沈黙します。
ビープ音がします。
「燃料不足」とコンソールに表示されます。
「先へ進むには<strong>50個のスター</strong>が必要です。<strong>スターがひとつ</strong>利用可能です。」</p>
<p>…「スターがひとつ利用可能？」あなたは燃料タンクを点検します。
確かに、唯一のスターがその友人を待って、一番下に座っています。
49個は自分で用意する必要があるようです。</p>
<h2 id="スターが足らない場合"><a class="header" href="#スターが足らない場合">スターが足らない場合</a></h2>
<p>あなたは装置を起動するのに十分な星がありません。さらに(?)個必要です。</p>
<h2 id="スターが49揃った場合"><a class="header" href="#スターが49揃った場合">スターが49揃った場合</a></h2>
<p>あなたはお天気制御装置を起動するのに充分なスターを持っています。</p>
<p>あなたはお天気制御装置に50個のスターを充填します。それは息を吹き返しました！</p>
<p><strong>雪が降り始めます。</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2016年"><a class="header" href="#2016年">2016年</a></h1>
<p>サンタのそりは動作制御のために非常に高精度のクロックを使用しており、
そのクロックの発振器はスターによって調律されています。
不幸にも、スターはイースターバニーに盗まれてしまいました。
クリスマスを救うには、
サンタは12月25日までに50個のスターをすべて取り返す必要があります。</p>
<p>パズルを解いてスターを集めよう。
サンタがパズルを解くのを助けることでスターを集めよう。
このアドベントカレンダーでは、毎日2つのパズルが利用可能になります。
2番目のパズルは、1番目を完了するとロックが解除されます。
各パズルで1つずつ星が貰えます。がんばろう！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1日目タクシーの時間がない"><a class="header" href="#1日目タクシーの時間がない">1日目：タクシーの時間がない</a></h1>
<p>あなたはどこかの都市の<strong>イースターバニー司令部</strong>の近くへ空中投下されました。
「近く」とは残念ながらできるだけ近くした結果でしかありません。
サンタ付きの小人たちが入手した
イースターバニー募集要項の指示はこの地点から開始されており、
それ以上にこれを分析する時間はありませんでした。</p>
<p>要項は、
あなたが与えられた座標（あなたが着地した場所）から、
北に向いた状態で始めるよう指示しています。
次に、90度左（L）または右（R）のいずれかの方向に向きを変えて、
指定した数のブロックを進み、新しい交差点で終了します。</p>
<p>このようなばかげた指示に徒歩で従う時間はありませんので、
少し時間を割いて目的地を見つけましょう。
<strong>碁盤の目</strong>のようになった都市の<strong>道だけを歩いて</strong>、
目的地までの最短距離はどれだけですか？</p>
<h2 id="例-4"><a class="header" href="#例-4">例</a></h2>
<ul>
<li><code>R2, L3</code> に従うと2ブロック東3ブロック北に到着し、
それは出発位置から5ブロック離れています。</li>
<li><code>R2, R2, R2</code> に従うと2ブロック南に到着し、
それは2ブロック離れています。</li>
<li><code>R5, L5, R5, R3</code> は12ブロック離れた場所に到着します。</li>
</ul>
<p>イースターバニー司令部は<strong>何ブロック先</strong>にありますか？</p>
<details><summary>解説</summary><div>
<p>まずは、入力を読み込んで、左右と進むブロック数のコマンド列に変換する。</p>
<pre><code class="language-haskell">import Data.Char

main1 = do
  co &lt;- readFile "input.txt"
  let is = parse co
  print is

parse :: String -&gt; [Either Int Int]
parse = loop
  where
    loop ('L':xs) = sub Left  xs
    loop ('R':xs) = sub Right xs
    loop "" = []
    sub f xs = f (read as) : loop (dropWhile (not.isUpper) bs)
      where
        (as,bs) = span isDigit xs
</code></pre>
<p>現在位置 \((x,y)\), 現在の向き \((d_x, d_y)\) を状態にして、コマンド列を消化する。</p>
<pre><code class="language-haskell">step ((x,y), (dx,dy)) (Left  n) = ((x - n * dy, y + n * dx), (- dy, dx))
step ((x,y), (dx,dy)) (Right n) = ((x + n * dy, y - n * dx), (dy, - dx))

main1 = do
  ...
  let ((x,y),_) = foldl step ((0,0), (0,1)) is
  print $ abs x + abs y
</code></pre>
</div></details>
<h1 id="パート2-25"><a class="header" href="#パート2-25">パート2</a></h1>
<p>その後、募集要項の裏面に指示が続いていることに気がつきました。
本当のイースターバニー司令部はあなたが最初に2度訪れる場所にあります。</p>
<p>たとえば、指示が R8, R4, R4, R8 である場合、
最初に2回訪れた場所は東に4ブロック離れた所です。</p>
<p>あなたが<strong>最初に2度訪れる場所</strong>は何ブロック離れていますか？</p>
<details><summary>解説</summary><div>
<p>細かくステップを分けて考える。
コマンド列から、1マスずつの差分の列を生成し、
原点上向きから出発して全ての座標の列に直し、
先頭から消費し、既出の座標を発見したところで停止する。</p>
<pre><code class="language-haskell">import Data.Set
import qualified Data.Set as S
import Data.List

deltas :: [Either Int Int] -&gt; [(Int, Int)]
deltas = concat . snd . mapAccumL step (0,1)
  where
    step (dx,dy) (Left  n) = sub n (- dy, dx)
    step (dx,dy) (Right n) = sub n (dy, - dx)
    sub n dxy = (dxy, replicate n dxy)

positions is = scanl add (0,0)
  where
    add (x, y) (dx, dy) = (x + dx, y + dy)

loop s (p:ps)
  | S.member p s = p
  | otherwise    = loop (S.insert p s) ps

main1 = do
  ...
  let (z,w) = loop S.empty $ positions $ deltas1 is
  print $ abs z + abs w
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2日目トイレのセキュリティ"><a class="header" href="#2日目トイレのセキュリティ">2日目：トイレのセキュリティ</a></h1>
<p>あなたは暗闇の中でイースター・バニー司令部に到着します。
しかし、あなたはとても慌ただしかったためにトイレに行っておくことを忘れていました！
このような素晴らしいオフィスビルは通常トイレに暗証番号によるロックが付いているので、
番号がないかフロントデスクを探します。</p>
<p>見つけた書類には次のように書いてありました。
「セキュリティを向上させるために、暗証番号は書き留めなくなりました。
代わりに、トイレに行くためには以下の手順を覚えておいて実行してください。」</p>
<p>この書類によると、押すべき各ボタンは、ひとつ前のボタンから始めて、
キーパッド上の隣接するボタンへ移動することで各ボタンを見つけることができると説明されています。
<code>U</code>は上に移動、<code>D</code>は下に移動、<code>L</code>は左に移動、<code>R</code>は右に移動。
命令の各行は1つのボタンに対応しており、
ひとつ前のボタン（最初の行の場合は「5」ボタン）から始めます。
各行の指示の最後に到達したボタンを押してください。
移動によりボタンから外れる場合は無視してください。</p>
<p>これをずっと覚えておくことはできませんので、トイレまで歩いていくうちにコードを把握することにします。
あなたはこのようなキーパッドを心に描いています：</p>
<pre><code>1 2 3
4 5 6
7 8 9
</code></pre>
<p>指示が以下の通りだとします。</p>
<pre><code>ULL
RRDDD
LURDL
UUUUD
</code></pre>
<ul>
<li>"5"から始め、上がって（"2"）左に（"1"）、
さらに左に（移動できないので"1"に留まります）、
よって最初のボタンは1です。</li>
<li>前のボタン（"1"）から始め、
右に2回移動し（"3"）、
次に3回下に（2回移動した後に"9"で停止し3回目を無視して）移動し
9で終わります。</li>
<li>"9"から続けて、左、上、右、下、左に移動し、8で終わります。</li>
<li>最後に、あなたは4回上がり（"2"で止まる）、次に1回下に移動し、
5で終わります。</li>
</ul>
<p>したがって、この例では、トイレの暗証番号は1985です。</p>
<p>あなたのパズルの入力は、フロントデスクで見つけた文書にあった指示です。
<strong>トイレの暗証番号</strong>は何ですか？</p>
<details><summary>解説</summary><div>
<p>キーパッドをグラフと考える。ノードはボタンで、文字で区別する。
移動できる有向辺は方向を表す文字がラベル付けされている。
キーパッドの図から、ネットワークを表す接続行列を表す写像を作る。</p>
<pre><code class="language-haskell">import qualified Data.Map

keypad1 = mkKeyPad ["123", "456", "789"]

mkKeyPad :: [String] -&gt; M.Map (Char,Char) Char
mkKeyPad xss = M.fromList $
  [ t | xs &lt;- xss, (v,w) &lt;- zip xs (tail xs), v /= ' ', w /= ' '
  , t &lt;- [((v,'R'),w),((w,'L'),v)]]
  ++
  [ t | (xs, ys) &lt;- zip xss (tail xss), (v,w) &lt;- zip xs ys, v /= ' ', w /= ' '
  , t &lt;- [((v,'D'),w),((w,'U'),v)]]
</code></pre>
<p>開始の文字と、一連の指示を受け取り、グラフを辿って最終的に到達した文字を返す。
辿れないときは無視する。</p>
<pre><code class="language-haskell">exec kp c ds = foldl step c ds
  where
    step c d = M.findWithDefault c (c,d) kp
</code></pre>
<p>入力を読み取り、'5' から始めて、行の内容に従ってグラフを辿る。
たどり着いた文字は結果でありかつ、次の行の開始位置になる。</p>
<pre><code class="language-haskell">import Data.List

main1 = do
  co &lt;- readFile "input.txt"
  putStrLn $ tail $ scanl (exec keypad ) '5' $ lines co
</code></pre>
</div></details>
<h1 id="パート2-26"><a class="header" href="#パート2-26">パート2</a></h1>
<p>ついにあなたはトイレにたどり着きました。
（ロビーから数分歩いているので、
この階には数多くの会議室やウォータークーラーがあることが見て取れます。）
では暗証番号を打ち込みましょう。
キーパッドが想像していたようなものと全く異なった驚きのほとんどが膀胱を狼狽させました。
トイレの暗証番号ロックのキーパッドデザイン会議に数百万人時間を注いだ成果とあなたは対峙しています。</p>
<pre><code>    1
  2 3 4
5 6 7 8 9
  A B C
    D
</code></pre>
<p>あなたはやはり "5" から始め、端にいるときに止まりますが、
上と同じ指示が与えられたときの結果は非常に異なります。</p>
<ul>
<li>あなたは "5" から始め、まったく動かず（上と左はどちらも端）、5で終わります。</li>
<li>"5"から続けて、右に2回下に3回移動し（"6","7","B","D","D"と通って）Dで終わります。</li>
<li>次に、"D"からもう5回移動して（"D","B","C","C","B"を通って）Bで終わります。</li>
<li>最後に、さらに5回移動した後、あなたは3で終わります。</li>
</ul>
<p>したがって、実際のキーパッドの配置に基づくと、暗証番号は<code>5DB3</code>になります。</p>
<p>パズル入力ファイルにある同じ指示を使用して、<strong>トイレの正しい暗証番号</strong>は何ですか？</p>
<details><summary>解説</summary><div>
<p>キーパッドのグラフを差し替えればよい。</p>
<pre><code class="language-haskell">keypad2 = mkKeyPad ["  1  "," 234 ","56789"," ABC ","  D  "]

main2 = do
  co &lt;- readFile "input.txt"
  putStrLn $ tail $ scanl (exec keypad2) '5' $ lines co
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3日目三角形広場"><a class="header" href="#3日目三角形広場">3日目：三角形広場</a></h1>
<p>（原題の「広場」はsquareで、三角形と掛かっている。）</p>
<p>あなたは頭がはっきりしてきたので、
イースターバニー司令部のこの部分を構成する
廊下とオフィス家具の迷路にもっと深く入っていきます。
ここはグラフィックデザイン部門に違いありません。
壁一面に三角形の仕様が貼り出されています。</p>
<p>いや、どうだろう？</p>
<p>設計文書は、それが定義する各三角形の辺の長さが記されています。
しかし… 5 10 25？三角形にならないものが混じっています。
あなたは三角形にならないものに印を付けずにはいられませんでした。</p>
<p>正しい三角形では、任意の2つの辺の合計が残りの辺よりも大きい必要があります。
例えば、上の「三角形」は、
\(5 + 10\) は25より大きくはないので、三角形になりません。</p>
<p>あなたのパズル入力では、
記述されている三角形のうち<strong>正しいものはいくつありますか？</strong></p>
<details><summary>解説</summary><div>
<p>三角形をなす条件を判定する述語を定義する。</p>
<pre><code class="language-haskell">property a b c = a + b &gt; c &amp;&amp; b + c &gt; a &amp;&amp; c + a &gt; b
</code></pre>
<p>条件を満たすものを数えればよい。</p>
<pre><code class="language-haskell">main1 =
  readFile "input.txt" &gt;&gt;=
  pure . map (map read . words) . lines &gt;&gt;=
  print . length . filter (\[a,b,c] -&gt; property a b c)
</code></pre>
</div></details>
<h1 id="パート2-27"><a class="header" href="#パート2-27">パート2</a></h1>
<p>あなたが設計文書に役立つ印を付け終わったところで、三角形が縦に3つの組で指定されていることに気付きました。
列の3つの数字の各組は三角形を指定します。行は無関係です。</p>
<p>たとえば、次の仕様があるとき、百の位が同じ数字は同じ三角形の一部になります。
（訳注：「百の位が同じ数字」は同じ三角形の一部になるための条件ではなくて、
数字列をどのような組み合わせで解釈するかの説明のためにそうしたということ）</p>
<pre><code>101 301 501
102 302 502
103 303 503
201 401 601
202 402 602
203 403 603
</code></pre>
<p>あなたのパズル入力において、行でなく列で読んで、
記述されている三角形のうち<strong>正しいものはいくつありますか？</strong></p>
<details><summary>解説</summary><div>
<p>3行ずつに切り分け、それらを転置し、全体を連結してからパート1と同じことをすればよい。</p>
<pre><code class="language-haskell">import Data.List
import Data.List.Split

main2 =
  readFile "input.txt" &gt;&gt;=
  pure . concat . map transpose . chunksOf 3 . map (map read . words) . lines &gt;&gt;=
  print . length . filter (\[a,b,c] -&gt; property a b c)
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4日目不明瞭さによるセキュリティ"><a class="header" href="#4日目不明瞭さによるセキュリティ">4日目：不明瞭さによるセキュリティ</a></h1>
<p>（原題はSecurity Through Obscurityと韻を踏んでいる）</p>
<p>ついに、部屋のリストが表示された情報キオスクの場所に着きました。
もちろん、リストは暗号化され、囮データでいっぱいですが、
リストを解読するための説明はすぐそばにまるで隠すことなく置いてあります。
まずは囮データを削除するのがよいでしょう。</p>
<p>各部屋は、暗号化された名前（ダッシュで区切られた小文字）、
ダッシュ、セクタID、角括弧で囲んだチェックサム、
で構成されています。</p>
<p>チェックサムが
暗号化された名前の中で最も多く現れる5つの文字で、
多い順に並んでいて、
同順のものはアルファベット順であるならば、
部屋は本物です。（囮ではありません。）
例えば：</p>
<ul>
<li><code>aaaaa-bbb-z-y-x-123[abxyz]</code>は本物の部屋です。
最もよく現れる文字は<code>a</code>(5回)、<code>b</code>(3回)、
その後同順の<code>x</code>,<code>y</code>,<code>z</code>はアルファベット順に列挙されているからです。</li>
<li><code>a-b-c-d-e-f-g-h-987[abcde]</code>は本物の部屋です。
すべての文字は同順ですが（それぞれ1つ）、
最初の5つがアルファベット順にリストされているためです。</li>
<li><code>not-a-real-room-404[oarel]</code>は本物の部屋です。</li>
<li><code>totally-real-room-200[decoy]</code> は本物ではありません。</li>
</ul>
<p>上のリストのうち本物の部屋のセクタIDの合計は1514です。</p>
<p><strong>本物の部屋のセクタIDの合計はいくつですか？</strong></p>
<h1 id="パート2-28"><a class="header" href="#パート2-28">パート2</a></h1>
<p>囮データがすべて消えたので、このリストを解読して話を進める時間です。</p>
<p>部屋の名前は最先端の<strong>シフト暗号</strong>で暗号化されています。
これは適切なソフトウェアがなければほとんど解読できません。
しかし、イースターバニー司令部の情報キオスクのデザイナーは、
あなたのような暗号の達人を相手にすることを予想していませんでした。</p>
<p>部屋の名前を復号化するには、
部屋のセクターIDに等しい数だけ
各文字を前方にアルファベットで回転させます。
<code>A</code>は<code>B</code>になり、<code>B</code>は<code>C</code>になり、<code>Z</code>は<code>A</code>になり、等々。
ダッシュはスペースになります。</p>
<p>たとえば、
<code>qzmt-zixmtkozy-ivhz-343</code>
の実際の名前は
<code>very encrypted name</code>
です。</p>
<p>North Pole objectが格納されている部屋の<em>セクタID</em>は何ですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2022年"><a class="header" href="#2022年">2022年</a></h1>
<p>サンタのトナカイは通常、普通のトナカイフードを食べますが、
クリスマスにプレゼントを届けるには魔法力がたくさん必要です。
そのため、彼らのお気に入りのおやつは、ジャングルの奥深くでしか育たない特別な種類のスターフルーツです。
サンタ付きの小人は、そのスターフルーツが育つ果樹園への毎年恒例の遠征にあなたを連れてきました。</p>
<p>十分な魔法力を供給するには、遠征隊は12月25日までに最低50個のスターを回収する必要があります。
小人は果樹園にたくさんの果物があることを保証しますが、
あなたは途中で見つけたスターフルーツを全て収穫することにしました。念のためです。</p>
<p>パズルを解いてスターを集めよう。
アドベントカレンダーでは、毎日2つのパズルが利用可能になります。
最初のパズルを完了すると、2番目のパズルのロックが解除されます。
パズルごとに星が1つ付与されます。幸運を！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1日目--カロリー計算"><a class="header" href="#1日目--カロリー計算">1日目 : カロリー計算</a></h1>
<p>ジャングルは生い茂りすぎて、車での移動や空からのアクセスは困難に違いありません。
小人の遠征は伝統的に徒歩で行われます。
あなたのボートが陸地に近づくと、小人たちは物資の在庫を調べ始めます。
重要な考慮事項のひとつは食料です。
特に、それぞれの小人が運んでいるカロリーの量（パズル入力）です。</p>
<p>小人たちは、持ってきたさまざまな食料、おやつ、レーションなどに含まれるカロリーの量を順番に書き留めます。
1行に1項目ずつ。
小人たちは、自分の目録を前の小人の目録（存在する場合）と空行で区切ります。</p>
<p>例えば、小人たちが所持品のカロリーを書き終えて、次のリストになったとします。</p>
<pre><code>1000
2000
3000

4000

5000
6000

7000
8000
9000

10000
</code></pre>
<p>このリストは、5人の小人が運ぶ食品のカロリーを表しています。</p>
<ul>
<li>最初の小人はそれぞれ1000, 2000, 3000カロリーで合計6000カロリーの食料を運んでいます。</li>
<li>2番目の小人は4000カロリーの食品を1つ運んでいます。</li>
<li>3番目の小人は5000と6000カロリー、合計11000カロリーの食料を運んでいます。</li>
<li>4番目の小人は7000,8000,9000カロリー、合計24000カロリーの食料を運んでいます。</li>
<li>5番目の小人は10000カロリーある食品を1つ運んでいます。</li>
</ul>
<p>小人のお腹が空いて追加のおやつが必要になった場合、どの小人に求めればよいかを知る必要があります。
彼らは、最も多くのカロリーを運んでいる小人がどれだけのカロリーを運んでいるかを知りたがっています。
上記の例では、これは（4番目の小人が運ぶ）24000です。</p>
<p>最も多くのカロリーを運んでいる小人を見つけてください。
<strong>その小人が持っている総カロリーはいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

`Data.List.Split`には列を区切る方法がいくつか実装されている。
これを用いて小人ごとのリストに戻し、それぞれ和を取り、最大値を求めればよい。

```haskell
main1 =
  readFile "input.txt" >>=
  pure . map (map read) . wordsBy null . lines >>=
  print . maximum . map sum
```

</div></details>
-->
<h1 id="パート2-29"><a class="header" href="#パート2-29">パート2</a></h1>
<p>あなたが小人の疑問に対する答えを計算する頃には、
彼らは、最大のカロリーを運ぶ小人の在庫が最後にはなくなってしまう可能性があることにすでに気づいています.</p>
<p>この容認できない状況を回避するために、小人は代わりに、
最も多くのカロリーを運ぶ上位3人の小人が運ぶ総カロリーを知りたいと考えています。
そうすれば、小人の1人がおやつを使い果たしたとしても、2人の控えが残っています。</p>
<p>上の例では、上位3人の小人は4番目の小人（24000カロリーを持つ）、3番目の小人（11000カロリー）、
5番目の小人（10000カロリー）です。
この3人の小人が持っているカロリーの合計は45000です。</p>
<p>最も多くのカロリーを運ぶ上位3人の小人を見つけてください。
<strong>それらの小人は合計で何カロリーを持っていますか？</strong></p>
<!--
<details><summary>解説</summary><div>

最大値一つを `maximum` で得る代わりに、
整列して端を取り出すことで、上位3つのカロリーを足し合わせればよい。

```haskell
main2 =
  readFile "input.txt" >>=
  pure . map (sum . map read) . wordsBy null . lines >>=
  print . sum . take 3 . sortBy (flip compare)
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="2日目-じゃんけん"><a class="header" href="#2日目-じゃんけん">2日目: じゃんけん</a></h1>
<p>小人たちはビーチにキャンプを設置し始めています。
おやつ貯蔵庫に最も近いテントに誰が入るかを決めるために、巨大な<a href="https://ja.wikipedia.org/wiki/%E3%81%98%E3%82%83%E3%82%93%E3%81%91%E3%82%93">じゃんけん</a>トーナメントがすでに進行中です。</p>
<p>じゃんけんは2人のプレイヤー間のゲームです。各ゲームには多くのラウンドからなります。
各ラウンドで、両プレイヤーは同時に手の形を使用して石、紙、鋏のいずれかを選択します。
そしてそのラウンドの勝者が決まります。
石が鋏に勝利し、鋏が紙に勝利し、紙が石に勝利します。
両方のプレイヤーが同じ形を選択した場合、ラウンドは引き分けで終了します。</p>
<p>昨日のあなたの助けに感謝して、一人の小人が暗号化された戦略ガイド（パズルの入力）をあなたに渡します。
「最初の列は対戦相手の出す手です。<code>A</code>は石、<code>B</code>は紙、<code>C</code>は鋏です。2番目の列は…」
突然、その小人は誰かのテントを手伝って欲しいと呼ばれて行ってしまいました。</p>
<p>2番目の列について、あなたは推測します。
これはおそらく、あなたが対応して出す手に違いありません。
<code>X</code>は石、<code>Y</code>は紙、<code>Z</code>は鋏でしょう。
毎回勝つのは怪しいので、手は慎重に選ばれたに違いありません。</p>
<p>トーナメント全体の勝者は、最高得点のプレイヤーです。
合計スコアは、各ラウンドのスコアの合計です。
1ラウンドの得点は、選択した形の得点（石は1点、紙は2点、鋏は3点）にラウンドの結果の得点（負けた場合は0点、引き分けの場合は3点、勝った場合は6点）を加えたものです。</p>
<p>小人があなたを助けようとしているのか、それともハメようとしているのかわからないので、攻略ガイドに従った場合に得られるスコアを計算する必要があります。</p>
<p>たとえば、次の戦略ガイドが与えられたとします。</p>
<pre><code>A Y
B X
C Z
</code></pre>
<p>この戦略ガイドでは、次のことを予言し、勧めています。</p>
<ul>
<li>最初のラウンドでは、対戦相手は石(<code>A</code>)を選択し、自分は紙(<code>Y</code>)を選択する必要があります。
これはあなたの勝ちになり、スコアは8点（紙を選んだので 2 + 勝ったので 6）になります。</li>
<li>2ラウンドめは対戦相手が紙(<code>B</code>)を選び、自分は石('X')を選びます。
これは負けになりスコアは1 (1 + 0) 点を得ます。</li>
<li>第3ラウンドは両方のプレイヤーが鋏を選択して引き分けて、スコアは 3 + 3 = 6 になります。</li>
</ul>
<p>この例では、戦略ガイドに従う場合、あなたは合計スコア15(8 + 1 + 6) を得ます。</p>
<p><strong>すべてが戦略ガイドどおりに進んだ場合、合計スコアはいくつになりますか？</strong></p>
<!--
<details><summary>解説</summary><div>

入力の各行（の1文字めと3文字め）からラウンドの得点が計算でき、その合計を求める。

```haskell
main1 = readFile "input.txt" >>= print . sum . map score1 . lines
```

自分の出す手に応じて、形の点と、相手の手に応じて勝敗点を導く関数が選択できる。

```haskell
score1 (o:_:'X':_) = 1 + sub o (3,0,6) -- X=石 対 o=A/B/C での勝敗点
score1 (o:_:'Y':_) = 2 + sub o (6,3,0) -- 紙
score1 (o:_:'Z':_) = 3 + sub o (0,6,3) -- 鋏

sub 'A' (a,_,_) = a
sub 'B' (_,b,_) = b
sub 'C' (_,_,c) = c
```

</div></details>
-->
<h1 id="パート2-30"><a class="header" href="#パート2-30">パート2</a></h1>
<p>先ほどの小人がテントの手伝いを終え、忍び足で戻ってきました。
「とにかく、2番目の列には、ラウンドがどのように終了する必要があるかが示されています。
つまり、<code>X</code>は負ける必要があることを意味し、
<code>Y</code>はラウンドを引き分けで終了する必要があることを意味し、
<code>Z</code>は勝つ必要があることを意味します。
頑張って！」</p>
<p>合計スコアは同じ方法で計算されますが、今、指示されているようにラウンドを追えるためには
どの形を選べばよいかを導く必要があります。
上記の例は次のようになります。</p>
<ul>
<li>最初のラウンドで相手は石(<code>A</code>)を選択し、引き分け(<code>Y</code>)でラウンドを終了する必要があるため、こちらも石を選択します。これにより、1 + 3 = 4のスコアを得ます。</li>
<li>第2ラウンドでは、対戦相手は紙(<code>B</code>)を選択し、あなたは石を選択することで負け(<code>X</code>)て、スコアは 1 + 0 = 1 です。</li>
<li>第3ラウンドでは、相手の鋏を石で倒して 1 + 6 = 7のスコアを得ます。</li>
</ul>
<p>これで、超極秘戦略ガイドを正しく解読でき、合計スコアは12となります。</p>
<p>2番目の列のエルフの指示に従って、<strong>全てが戦略ガイドどおりに進んだ場合、合計スコアはいくつになるでしょうか？</strong></p>
<!--
<details><summary>解説</summary><div>

ラウンドの結果に応じて、勝敗点と、相手の手に応じて自分の手の形の点を導く関数が選択できる。

```haskell
main2 = readFile "input.txt" >>= print . sum . map score2 . lines

score2 (o:_:'X':_) = 0 + scoresub o (3,1,2) -- o=A/B/C に負けるための手の形点
score2 (o:_:'Y':_) = 3 + scoresub o (1,2,3) -- 引き分ける
score2 (o:_:'Z':_) = 6 + scoresub o (2,3,1) -- 勝つ
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-日目--リュックサックの再編成"><a class="header" href="#3-日目--リュックサックの再編成">3 日目 : リュックサックの再編成</a></h1>
<p>ある小人が、ジャングルへの旅の物資を全てのリュックサックに詰め込むという重要な仕事をしています。
残念ながら、その小人は梱包の指示をまるで無視したので、いくつかの荷物を再配置する必要があります.</p>
<p>各リュックサックには2つの大きな区画があります。
様々な種類の全ての荷物はそれぞれ、2つの区画のいずれかにだけ入れることになっています。
荷造りをした小人は、リュックサックごとに、同じ種類の荷物はひとつだけという規則に従いませんでした。</p>
<p>小人は現在各リュックサックに入っている全ての荷物のリストを作成しました（あなたのパズル入力）が、誤りを見つけるためにあなたの助けが必要です。
全ての荷物の種類は、単一の小文字または大文字で識別されます。
(つまり、<code>a</code>と<code>A</code>は異なる種類の荷物を指します。）</p>
<p>各リュックサックの荷物のリストは、全て一行の文字列として示されます。
リュックサックの2つの区画には常に同じ数の荷物が入っているため、文字列の前半は最初の区画の荷物を表し、文字列の後半は2番目の区画の荷物を表します。</p>
<p>例えば、次のような、6つのリュックサックの内容のリストがあるとします。</p>
<pre><code>vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
</code></pre>
<ul>
<li>最初のリュックサックには荷物  <code>vJrwpWtwJgWrhcsFMMfFFhFp</code> が入っています。
つまり、最初の区画には荷物 <code>vJrwpWtwJgWr</code> があり、
2番目の区画には荷物 <code>hcsFMMfFFhFp</code> が入っています。
両方の区画に現れている唯一の荷物の種類は小文字 <code>p</code> です。</li>
<li>2番目のリュックサックの区画には
<code>jqHRNqRjqzjGDLGL</code> と <code>rsFMfFZSrLrFZsSL</code>
が入っています。
両方の区画に現れている唯一の荷物の種類は大文字 <code>L</code> です。</li>
<li>3番目のリュックサックの区画には
<code>PmmdzqPrV</code> と <code>vPwwTWBwg</code>
があり、唯一の共通の種類は大文字 <code>P</code> です。</li>
<li>4番目のリュックサックの区画は種類 <code>v</code> のみを共有しています。</li>
<li>5番目のリュックサックの区画は種類 <code>t</code> のみを共有しています。</li>
<li>6番目のリュックサックの区画は種類 <code>s</code> のみを共有しています。</li>
</ul>
<p>荷物の再配置に優先順位を付けるために、全ての荷物の種類を優先度に変換できます。</p>
<ul>
<li>小文字の荷物種類 <code>a</code>～<code>z</code> は、優先度 1 から 26 を持ちます。</li>
<li>大文字の荷物種類 <code>A</code>～<code>Z</code> は、優先度 27 から 52 を持ちます。</li>
</ul>
<p>上記の例では、各リュックサックの両方の区画に現れる荷物種類の優先度は、16 (<code>p</code>), 38 (<code>L</code>), 42 (<code>P</code>), 22 (<code>v</code>), 20 (<code>t</code>), 19 (<code>s</code>) です。
これらの合計は157です。</p>
<p>各リュックサックの両方の区画に現れる荷物の種類を見つけます。<strong>これらの荷物種類の優先度の合計はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

`Data.List.intersect`で、リストを集合とみなして共通部分を取り出すことができる。

```haskell
import Data.List

main1 = body "input.txt" compute1

body fn cp = readFile fn >>= print . cp . lines

compute1 :: [String] -> Int
compute1 = sum . map func1

func1 :: String -> Int
func1 xs = prio $ head $ intersect as bs
  where
    (as,bs) = splitAt (div (length xs) 2) xs

-- 優先度
prio c
  | c <= 'Z'  = fromEnum c - fromEnum 'A' + 27
  | otherwise = fromEnum c - fromEnum 'a' + 1
```

</div></details>
-->
<h1 id="パート2-31"><a class="header" href="#パート2-31">パート2</a></h1>
<p>入れ間違えた荷物の特定が完了すると、小人が別の問題を抱えてやってきます。</p>
<p>安全のため、小人は3人ずつグループに分けられます。
全ての小人はグループを識別するバッジを持っています。
効率のために、3人の小人の各グループ内で、バッジは<strong>その小人3人ともが共通して持つ唯一の荷物の種類</strong>です。
つまり、グループのバッジが種類<code>B</code>の場合、3人の小人はみなリュックサックのどこかに種類<code>B</code>の荷物を持ち、
そしてそれ以外の種類の荷物は多くて2人までしかそれを持っていません。
（訳注：3人共通の種類はひとつに定まる、ということ。）</p>
<p>問題は、誰かがバッジに今年更新された証紙シールを貼り付け忘れたことです。
新しい証紙シールを貼り付けるために、全てのバッジをリュックサックから取り出す必要があります。</p>
<p>さらに、各グループのバッジに対応する荷物の種類を誰も書き留めていませんでした。
どの荷物種類が正解かを判断する唯一の方法は、各グループの3人の小人全てに共通する1つの荷物種類を見つけることです。</p>
<p>リスト内の3行ずつの各組は1つのグループに対応しますが、各グループは異なるバッジの荷物種類を持つことができます。
したがって、上記の例では、最初のグループのリュックサックは最初の3行です。</p>
<pre><code>vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
</code></pre>
<p>2番目のグループのリュックサックはその次の3行です。</p>
<pre><code>wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
</code></pre>
<p>最初のグループでは、3つのリュックサックすべてに現れる唯一の荷物種類は小文字 <code>r</code> です。
これが彼らのバッジに違いありません。
2番目のグループでは、バッジの荷物種類は <code>Z</code> です。</p>
<p>これらの荷物の優先順位は、証紙シール貼り付け作業を計画するために引き続き調べる必要があります。
ここでは、最初のグループは 18 (<code>r</code>)、2番目のグループは 52 (<code>Z</code>) です。
これらの合計は70です。</p>
<p>小人の3人グループそれぞれについて、バッジに対応する荷物種類を見つけます。
<strong>これらの荷物種類の優先度の合計はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

3人グループのリストに対して、`intersect`を2度使えば共通の要素が取り出せる。

```haskell
import Data.List.Split

main2 = body "input.txt" compute2

compute2 :: [String] -> Int
compute2 = sum . map func2 . chunksOf 3

func2 :: [String] -> Int
func2 = prio . head . foldl1 intersect
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-日目--キャンプの後片付け"><a class="header" href="#4-日目--キャンプの後片付け">4 日目 : キャンプの後片付け</a></h1>
<p>船から最後の物資を降ろす前に、場所を空ける必要があります。
そのため、数人の小人がキャンプの区画を片付ける仕事を割り当てられています。
全ての区画には一意の<strong>ID番号</strong>があり、小人にはそれぞれ区画IDの範囲がひとつずつ割り当てられています。</p>
<p>ところが、ある小人が区画の割り当てを互いに見比べたところ、
割り当ての多くに<strong>重複がある</strong>ことに気付きました。
重複をすばやく見つけて無駄な作業を減らすために、小人たちは二人一組になり、
<strong>それぞれの組の割り当て区画の大きなリスト</strong>（パズル入力）を作成します。</p>
<p>例えば、次の区画割り当て対のリストを考えてみましょう：</p>
<pre><code>2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8
</code></pre>
<p>最初の数個の対について、このリストの意味を説明します：</p>
<ul>
<li>最初の小人の組では、最初の小人には区画2-4（区画2,3,4）が割り当てられ、
2番目の小人には区画6-8（区画6,7,8）が割り当てられました。</li>
<li>2番目の小人の組には、それぞれ2つの区画が割り当てられました。</li>
<li>3番目の小人の組には、それぞれ3つの区画が割り当てられました。
一人は区画5,6,7で、もう一方は同じく7と、あと8,9です。</li>
</ul>
<p>このリストの例では、図示しやすいように1桁の区画IDを使用しています。
実際のリストにはもっと大きな数が含まれている可能性があります。
これらの区画割り当ての対は、視覚的には次のようになります。</p>
<pre><code>.234.....  2-4
.....678.  6-8

.23......  2-3
...45....  4-5

....567..  5-7
......789  7-9

.2345678.  2-8
..34567..  3-7

.....6...  6-6
...456...  4-6

.23456...  2-6
...45678.  4-8
</code></pre>
<p>一部の組は、彼らの割り当ての一方が他方を<strong>完全に含んでいる</strong>ことに気付きました。
例えば、<code>2-8</code>は<code>3-7</code>を完全に含んでおり、<code>6-6</code>は<code>4-6</code>に完全に含まれています。</p>
<p>一方の割り当てがもう一方の割り当てを完全に含む組では、組の小人の一人は、
相棒が既に清掃している区画だけを清掃するため、これらは最も再検討が必要と思われます。
この例では、そのような組が2組あります。</p>
<p><strong>一人の範囲がもう一人の範囲に完全に含まれる割り当ての組はいくつありますか？</strong></p>
<!--
<details><summary>解説</summary><div>

一行にある4つの数を順に \\(a,b,c,d\\) と呼ぶことにする。
データに矛盾がないこと、すなわち\\(a \leq b, c \leq d\\)は満たされていると仮定する。

行を読み取るのには、数字の並びの部分だけを抽出する必要がある。
次に出現する数字でない文字が固定なので、それを用いて取り出すのが簡易。

```haskell
import Data.List

parse :: String -> (Int,Int,Int,Int)
parse xs0 = (read as, read bs, read cs, read ds)
  where
    (as,_:xs1) = span ('-' /=) xs0
    (bs,_:xs2) = span (',' /=) xs1
    (cs,_:ds ) = span ('-' /=) xs2
```

完全に重なっているとは、\\(a \leq c \land d \leq b\\) または
\\(c \leq a \land b \leq d\\) である。
これを満たしている行の数を数える。

```haskell
prop1 (a,b,c,d) = a <= c && d <= b || c <= a && b <= d

main1 = readFile "input.txt" >>= print . length . filter prop1 . map parse . lines
```

</div></details>
-->
<h1 id="パート2-32"><a class="header" href="#パート2-32">パート2</a></h1>
<p>まだかなりの重複作業が予定されているようです。
代わりに、小人たちは重なりがある組のの数を知りたがっています。</p>
<p>上記の例では、最初の2つの組（<code>2-4,6-8</code>と<code>2-3,4-5</code>）は重なりませんが、
残りの4つ組（<code>5-7,7-9</code>, <code>2-8,3-7</code>, <code>6-6,4-6</code>, `2-6,4-8)）は重なります。</p>
<ul>
<li><code>5-7,7-9</code> は単一の区画<code>7</code>が重複しています。</li>
<li><code>2-8,3-7</code> は<code>3</code>から<code>7</code>までの全ての区画で重なっています。</li>
<li><code>6-6,4-6</code> 単一の区画<code>6</code>で重なっています。</li>
<li><code>2-6,4-8</code> は区画<code>4</code>,<code>5</code>,<code>6</code>で重なっています。</li>
</ul>
<p>したがって、この例では、重なりのある割り当て組のの数は4です。</p>
<p><strong>範囲が重複する割り当て組はいくつありますか？</strong></p>
<!--
<details><summary>解説</summary><div>

逆に、重複が**ない**とは、\\(b < c\\) または \\(d < a\\) が満たされることである。
これをそのまま書いてもいいし、ド・モルガンの法則を用いて
\\(\neg (b < c \lor d < a) = b \geq c \land d \geq a\\)
としてもよい。

```haskell
prop2 (a,b,c,d) = not (b < c || d < a)

main2 = readFile "input.txt" >>= print . length . filter prop2 . map parse . lines
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-日目-物資の山"><a class="header" href="#5-日目-物資の山">5 日目: 物資の山</a></h1>
<p>船から最後の物資が降ろされ次第、遠征隊は出発できます。
物資はそれぞれ印付きの木箱に収められ、積み上げられてスタックをなしていますが、
必要な物資は他の多くの木箱の下に埋もれているため、木箱を再配置する必要があります。</p>
<p>船には、木箱をスタック間で移動できる巨大な貨物クレーンがあります。
木箱がつぶれたり倒れたりしないように、クレーンのオペレーターは慎重に計画された一連の手順で木箱を再配置します。
木箱を再配置すると、目的の木箱が各スタックの一番上になります。</p>
<p>小人たちは、この繊細な手順の間、クレーンオペレーターの邪魔をしたくありませんが、どの木箱がどこに到着するのかを尋ねるのを忘れていました。
出発するために、再配置が完了したらできるだけ早く荷下ろしにかかれるように備えたいと思っています。</p>
<p>しかし彼らは、木箱のスタックの初期状態の図と再配置手順（パズル入力）しか持っていません。
例えば：</p>
<pre><code>    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 

move 1 from 2 to 1
move 3 from 1 to 3
move 2 from 2 to 1
move 1 from 1 to 2
</code></pre>
<p>この例では、木箱のスタックが3つあります。
スタック1は2つの木箱からなります。木箱<code>Z</code>は下にあり、木箱<code>N</code>は上にあります。
スタック2は3つの木箱からなります。下から上に、木箱 <code>M</code>, <code>C</code>, <code>D</code> です。
最後に、スタック3は1つの箱<code>P</code>からなります。</p>
<p>続きに、再配置手順が示されています。
手順の各ステップで、ある量の木箱が1つのスタックから別のスタックに移動されます。
上記の再配置手順の最初のステップでは、1つの木箱がスタック2からスタック1に移動され、
その結果次の構成になります。</p>
<pre><code>[D]        
[N] [C]    
[Z] [M] [P]
 1   2   3 
</code></pre>
<p>第2ステップでは、3つの木箱がスタック1からスタック3に移動します。
木箱は<strong>一度にひとつ</strong>ずつ運ばれるので、
結果として最初の木箱(<code>D</code>)は2つめ3つめの木箱の下に移されます。</p>
<pre><code>        [Z]
        [N]
    [C] [D]
    [M] [P]
 1   2   3
</code></pre>
<p>次に、両方の木箱がスタック2からスタック1に運ばれます。
ここでも木箱は一度に1つずつ移動されるため、木箱<code>C</code>は木箱<code>M</code>の下になります。</p>
<pre><code>        [Z]
        [N]
[M]     [D]
[C]     [P]
 1   2   3
</code></pre>
<p>最後に、1つの木箱がスタック1からスタック2に移動されます。</p>
<pre><code>        [Z]
        [N]
        [D]
[C] [M] [P]
 1   2   3
</code></pre>
<p>小人たちは、<strong>最後にどの木箱が各スタックの一番上になるか</strong>を知る必要があります。
この例では、一番上の木箱はスタック1では<code>C</code>、スタック2は<code>M</code>、スタック3は<code>Z</code>になため、
これらを組み合わせて、エルフに<code>CMZ</code>とメッセージを送る必要があります。</p>
<p><strong>再配置手順が完了した後、各スタックの一番上にある木箱は何ですか？</strong></p>
<!--
<details><summary>解説</summary><div>

ファイルを読み込んだら、前半と後半が空行で区切られているので、これで切り分け、空行は除く。

```haskell
(ls1, _:ls2) <- break null . lines <$> readFile "input.txt"
```

前半のスタックの絵は、スタックごとに、上を前にしたリストで取り出したい。
これは `Data.List.transpose` で転置したあと、必要な行だけ抜き出すことでできる。
（一番右のスタックが最大でない場合、行末を揃えるために空白を追加する必要がある。自分は不要だった。）
なお、前半の最後はスタック位置を表すだけで不要なので捨てる。

取り出したスタックの初期状態は、この後の手続き的な更新に備えて、
スタック番号をキーにした `IntMap` に入れておく。

```haskell
let ls1t = transpose $ init ls1
let m0 = IM.fromAscList $ zip [1..] $ map (dropWhile (' ' ==) . (ls1t !!)) [1,5..33]
```

ファイル後半の手順書は、3つの数を抜き出すだけでよい。

```haskell
parse :: String -> (Int,Int,Int)
parse xs = (read w1, read w2, read w3)
  where
    (_:w1:_:w2:_:w3:_) = words xs
```

ひとつの指示(a,b,c)を実行するには、スタックbから要素をひとつずつ取り出してスタックcに乗せることをa回繰り返す。

```haskell
step1 :: IM.IntMap String -> (Int,Int,Int) -> IM.IntMap String
step1 m1 (a,b,c) = IM.insert c imc $ IM.insert b imb m1
  where
    move 0 xs ys = (xs,ys)
    move k (x:xs) ys = move (pred k) xs (x:ys)
    (imb, imc) = move a (m1 IM.! b) (m1 IM.! c)
```

これを全ての行について実行した結果のスタックから、先頭要素を全て順に取り出したものが答えである。

```haskell
body step = do
  (ls1, _:ls2) <- break null . lines <$> readFile "input.txt"
  let ls1t = transpose $ init ls1
  let m0 = IM.fromAscList $ zip [1..] $ map (dropWhile (' ' ==) . (ls1t !!)) [1,5..33]
  let mZ = foldl step m0 $ map parse ls2
  putStrLn $ map head $ IM.elems mZ

main1 = body step1
```

</div></details>
-->
<h1 id="パート2-33"><a class="header" href="#パート2-33">パート2</a></h1>
<p>クレーンのオペレーターが木枠を巧みに再配置するのを見ていると、
手順があなたの予測とは違った進み方をしていることに気付きます。</p>
<p>クレーンの側面の文字に泥がかぶっていたので、さっと拭き取ります。
クレーンはCrateMover 9000ではありません。これは<strong>CrateMover 9001</strong>です。</p>
<p>CrateMover 9001は、多くの新しくエキサイティングな機能で有名です：
エアコン、革張りのシート、追加のカップホルダー、
そして<strong>複数の木箱を一度に持ち上げて移動する機能</strong>。</p>
<p>上記の例をもう一度考えます。木箱は同じ構成で始まります。</p>
<pre><code>    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 
</code></pre>
<p>単一の木箱をスタック2からスタック1に移動すると、以前と同じように動作します。</p>
<pre><code>[D]        
[N] [C]    
[Z] [M] [P]
 1   2   3 
</code></pre>
<p>しかし、スタック1からスタック3に3つの木箱を移動させる動作は、
これらの移動された3つの木箱<strong>順序が同じまま</strong>であることを意味し、次の新しい構成になります。</p>
<pre><code>        [D]
        [N]
    [C] [Z]
    [M] [P]
 1   2   3
</code></pre>
<p>次に、両方の木箱がスタック2からスタック1に移動され、<strong>順序も保持</strong>されます。</p>
<pre><code>        [D]
        [N]
[C]     [Z]
[M]     [P]
 1   2   3
</code></pre>
<p>最後に1つの木箱がスタック1からスタック2に移されます。今回移動されるのは木箱<code>C</code>です。</p>
<pre><code>        [D]
        [N]
        [Z]
[M] [C] [P]
 1   2   3
</code></pre>
<p>この例では、CrateMover 9001が木箱をまったく異なる順序 <code>MCD</code> に配置しています。</p>
<p>再配置プロセスが完了する前に、シミュレーションを更新して、
小人が最後の物資を降ろす準備をして待つべき場所を把握できるようにします。
<strong>再配置手順が完了した後、各スタックの一番上にある木箱は何ですか？</strong></p>
<!--
<details><summary>解説</summary><div>

スタックの要素をひとつずつ移動させる代わりに、
指定された個数分だけ一度に、同じ順で移す。

```haskell
step2 :: IM.IntMap String -> (Int,Int,Int) -> IM.IntMap String
step2 m1 (a,b,c) = IM.insert c imc $ IM.insert b imb2 m1
  where
    (imb1, imb2) = splitAt a (m1 IM.! b)
    imc = imb1 ++ m1 IM.! c

main2 = body step2
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-日目-チューニングのトラブル"><a class="header" href="#6-日目-チューニングのトラブル">6 日目: チューニングのトラブル</a></h1>
<p>準備がようやく完了しました。
あなたは小人たちと徒歩でキャンプを出発し、スターフルーツの果樹園に向けて進み始めます。</p>
<p>密集した下草の中を移動していると、小人の1人が携帯<strong>装置</strong>を渡してくれます。
彼はそれが多くの素晴らしい機能を持っていると言いますが、今セットアップする最も重要なものは<strong>通信システム</strong>です.</p>
<p>しかし、あなたは信号ベースのシステムを扱った経験が豊富
（[2016/6][2016/25][2019/7][2019/9][2019/16][2021/25]）
だと聞いたので、
彼は他の小人に、彼らの故障したデバイスを1つ渡しても大丈夫だと確信させました。
もちろんあなたは簡単にそれを直せるでしょう。</p>
<p>コントのようなタイミングで、その装置はカラフルな火花をいくらか放ちます。</p>
<p>小人と通信できるようにするには、<strong>装置が小人の信号にロックオン</strong>する必要があります。
信号は、装置が一度に1つずつ受信する、一見ランダムな文字列です。</p>
<p>通信システムを修正するには、データストリームから<strong>パケット開始マーカー</strong>を検出する
サブルーチンをデバイスに追加する必要があります。
小人が使用しているプロトコルでは、パケットの開始は、<strong>全て異なる4文字の列</strong>によって示されます。</p>
<p>装置はサブルーチンにデータストリームバッファ（パズル入力）を送信します。
サブルーチンは、受信した直近4文字が全て異なっている最初の位置を特定する必要があります。
具体的には、バッファの先頭から最初の4文字マーカーの末尾までの文字数を報告する必要があります。</p>
<p>例えば、次のデータストリーム バッファを受け取ったとします：</p>
<pre><code>mjqjpqmgbljsphdztnvjfqwrcgsmlb
</code></pre>
<p>最初の3文字 (<code>mjq</code>) が受信された後、マーカーを見つけるのに十分な文字がまだ受信されていません。
最初にマーカーが発生する可能性があるのは4文字めが受信された後で、
すると最新の4文字は <code>mjqj</code> となります。
<code>j</code> が繰り返されているため、これはマーカーではありません。</p>
<p>最初にマーカーが現れるるのは<strong>7文字め</strong>が到着した後です。
そのとき、直近で受け取った4文字は <code>jpqm</code> であり、これは全てが異なります。
この場合、7文字が処理された後に最初のパケット開始マーカーが完成するため、
サブルーチンは値7を報告する必要があります。</p>
<p>次にいくつかの例を示します。</p>
<ul>
<li><code>bvwbjplbgvbhsrlpgdmjqwftvncz</code> : 最初のマーカーは5文字後</li>
<li><code>nppdvjthqldpwncqszvftbrmjlhg</code> : 最初のマーカーは6文字後</li>
<li><code>nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg</code> : 最初のマーカーは10文字後</li>
<li><code>zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw</code> : 最初のマーカーは11文字後</li>
</ul>
<p><strong>最初のパケット開始マーカーが検出されるまでに、何文字を処理する必要がありますか？</strong></p>
<!--
<details><summary>解説</summary><div>

全ての位置から開始した4文字の並びを作るには、`Data.List.Split.divvy` も使えるが、
`map (take 4) . tails` でできる。

これを `nub` しても4文字のままであるものの先頭がいくつめかを数え、文字の長さ分補正する。

なぜか、マーカーの長さをパラメータ化しておいてみる。

```haskell
main1 = readFile "input.txt" >>= print . detect 4

detect :: Int -> String -> Int
detect k = (k +) . length . takeWhile id . map ((k >) . length . nub . take k) . tails
```

</div></details>
-->
<h1 id="パート2-34"><a class="header" href="#パート2-34">パート2</a></h1>
<p>装置の通信システムはパケットを正しく検出していますが、まだ正しく動きません。
<strong>メッセージ</strong>も探す必要があるようです。</p>
<p><strong>メッセージ開始マーカー</strong>は、パケット開始マーカーと同じですが、4文字ではなく<strong>異なる14文字</strong>で構成される点が異なります。</p>
<p>上記の全ての例のメッセージ開始マーカーの最初の位置は次のとおりです。</p>
<ul>
<li><code>mjqjpqmgbljsphdztnvjfqwrcgsmlb</code> : 最初のマーカーは19文字後</li>
<li><code>bvwbjplbgvbhsrlpgdmjqwftvncz</code> : 最初のマーカーは23文字後</li>
<li><code>nppdvjthqldpwncqszvftbrmjlhg</code> : 最初のマーカーは23文字後</li>
<li><code>nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg</code> : 最初のマーカーは29文字後</li>
<li><code>zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw</code> : 最初のマーカーは26文字後</li>
</ul>
<p><strong>最初のメッセージ開始マーカーが検出されるまでに、何文字を処理する必要がありますか？</strong></p>
<!--
<details><summary>解説</summary><div>

パラメータ化しておいたので、それを変更するだけ。

```haskell
main2 = readFile "input.txt" >>= print . detect 14
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-日目-デバイスに空き容量がありません"><a class="header" href="#7-日目-デバイスに空き容量がありません">7 日目: デバイスに空き容量がありません</a></h1>
<p>遠征が進むにつれて、鳥のさえずりや雨滴が葉に当たる音が聞こえます。
時折、遠くでもっと大きな音が聞こえることさえあります。
どれくらい大きな動物が現れるのでしょう？</p>
<p>小人があなたにくれた装置には、通信システム以外にも問題があります。
システムアップデートを実行しようとすると、次のようになります。</p>
<pre><code>$ system-update --please --pretty-please-with-sugar-on-top
Error: No space left on device
</code></pre>
<p>おそらく、いくつかのファイルを削除することで、
アップデートのための空き容量を確保できるでしょう。</p>
<p>ファイルシステムをあちこち調べて状況を評価し、
結果の端末出力 (パズルの入力) を保存します。
それは例えば次のようなものです：</p>
<pre><code>$ cd /
$ ls
dir a
14848514 b.txt
8504156 c.dat
dir d
$ cd a
$ ls
dir e
29116 f
2557 g
62596 h.lst
$ cd e
$ ls
584 i
$ cd ..
$ cd ..
$ cd d
$ ls
4060174 j
8033020 d.log
5626152 d.ext
7214296 k
</code></pre>
<p>ファイルシステムは、ファイル（単なるデータ）とディレクトリ（他のディレクトリやファイルを含むことができる）の木で構成されます。
一番外側のディレクトリは <code>/</code> と呼ばれます。
ファイルシステムをナビゲートし、ディレクトリを出入りして、現在いるディレクトリの内容を一覧表示できます。</p>
<p>端末出力内で、 <code>$</code> で始まる行は<strong>実行したコマンド</strong>です。
これは最近のコンピュータと非常によく似ています。</p>
<ul>
<li><code>cd</code> は<strong>ディレクトリの変更</strong>を意味します。
これは現在のディレクトリを変更しますが、具体的な結果は引数によって異なります。
<ul>
<li><code>cd x</code> 1レベル<strong>中に入り</strong>ます。
現在のディレクトリで <code>x</code> という名前のディレクトリを探し、それを現在のディレクトリにします。</li>
<li><code>cd ..</code> 1レベル<strong>外に出</strong>ます。
現在のディレクトリを含むディレクトリを見つけ、そのディレクトリを現在のディレクトリにします。</li>
<li><code>cd /</code> 現在のディレクトリを最も外側のディレクトリに切り替えます。</li>
</ul>
</li>
<li><code>ls</code> <strong>リスト</strong>を意味します。現在のディレクトリに直接含まれる全てのファイルとディレクトリを出力します。
<ul>
<li><code>123 abc</code> は、現在のディレクトリに <code>abc</code> という名前で大きさ <code>123</code> のファイルが含まれていることを意味します。</li>
<li><code>dir xyz</code> は、現在のディレクトリに <code>xyz</code> という名前のディレクトリが含まれていることを意味します。</li>
</ul>
</li>
</ul>
<p>上記の例のコマンドと出力から、ファイルシステムが視覚的に次のようになっていることがわかります。</p>
<pre><code>- / (dir)
  - a (dir)
    - e (dir)
      - i (file, size=584)
    - f (file, size=29116)
    - g (file, size=2557)
    - h.lst (file, size=62596)
  - b.txt (file, size=14848514)
  - c.dat (file, size=8504156)
  - d (dir)
    - j (file, size=4060174)
    - d.log (file, size=8033020)
    - d.ext (file, size=5626152)
    - k (file, size=7214296)
</code></pre>
<p>ここには4つのディレクトリがあります。
<code>/</code> （最外のディレクトリ）、<code>a</code> と <code>d</code> (<code>/</code>にある) と <code>e</code>(<code>a</code> にある) です。
これらのディレクトリには、さまざまな大きさのファイルも含まれています。</p>
<p>ディスクがいっぱいなので、あなたの最初の一手はきっと、
削除するのに適したディレクトリを見つけることです。
これを行うには、各ディレクトリの<strong>合計サイズ</strong>を求める必要があります。
ディレクトリの合計サイズは、直接的または間接的に含まれるファイルのサイズの合計です。
（ディレクトリ自体は、固有のサイズを持っているとは見なしません。）</p>
<p>上記のディレクトリの合計サイズは次のようになります。</p>
<ul>
<li>ディレクトリ <code>e</code> の合計サイズは<strong>584</strong>です。
というのは、それがサイズ584のファイル<code>i</code>だけを持っており、他のディレクトリがないためです。</li>
<li>ディレクトリ <code>a</code> には、ファイル<code>f</code>(サイズ29116)、<code>g</code>(サイズ2557)、<code>h.lst</code>(サイズ 62596)が含まれており、
さらにファイル<code>i</code>を間接的に持つ（<code>j</code>を持つ<code>e</code>を<code>a</code>は含む）ため、合計サイズは<strong>94853</strong>です。</li>
<li>ディレクトリ <code>d</code> の合計サイズは24933642です。</li>
<li>最も外側のディレクトリである <code>/</code> には全てのファイルが含まれます。
その合計サイズは48381165で、これは全てのファイルのサイズの合計です。</li>
</ul>
<p>まず、合計サイズが<strong>100000以下</strong>のディレクトリをすべて見つけてから、
それらの合計サイズの合計を計算します。
上記の例では、そのようなディレクトリは <code>a</code> と <code>e</code> です。
それらの合計サイズの合計は <strong>95437</strong> (94853 + 584) です。
（この例のように、この手順はファイルを複数回勘定します！）</p>
<p>合計サイズが100000以下の全てのディレクトリを見つけます。
<strong>これらのディレクトリの合計サイズの合計はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

`cd`コマンドはカレントディレクトリを変更する。
`ls`コマンドの結果は、カレントディレクトリにあるファイルの容量リストが続くことを意味する。
存在しないディレクトリに`cd`することはないと仮定する。（エラーメッセージの形式が説明されていないため。）
同じディレクトリで複数回`ls`する可能性は気に掛けておく。

ディレクトリごとにそこに含まれるファイルの容量の合計が知りたいが、
ディレクトリが入れ子になっていることも配慮しないといけない。
そこで、ディレクトリやファイルの完全パス名を名前のの文字列の（逆順の）リストで表現し、
完全パス名にそのファイルの容量を対応付けたペアのリストから、そのマップを作ることで重複を払拭する。

カレントディレクトリという状態を持ちまわすため、`mapAccumL`を用いる。
ファイル容量を報告しない行もあるので、出力は`Maybe`で包む。

```haskell
import qualified Data.Map as M
import Data.List
import Data.Maybe

parseFile :: [String] -> M.Map [String] Int
parseFile = M.fromList . catMaybes . snd . mapAccumL step []
  where
    step :: [String] -> String -> ([String], Maybe ([String], Int))
    step dir l =
      case words l of
        ["$", "cd", ".."] -> (tail dir, Nothing)
        ["$", "cd", "/"] -> ([], Nothing)
        ["$", "cd", d] -> (d:dir, Nothing)
        ["$", "ls"] -> (dir, Nothing)
        ["dir", _] -> (dir, Nothing)
        [n, fn] -> (dir, Just (fn:dir, read n))
        _ -> error $ "unexpected" ++ l
```

このマップの対応リストを取り出し、キーの`tails . tail`について容量をばらまいて足し合わせると、
全てのディレクトリについて、それが直接的または間接的に含むファイル容量のマップが作れる。

```haskell
accumlate :: M.Map [String] Int -> M.Map [String] Int
accumlate m = M.fromListWith (+)
  [(p, sz) | (path, sz) <- M.assocs m, p <- tails (tail path)]
```

ここから100000以下の容量を抜き出し、合計する。

```haskell
main1 = body1 "input.txt"

body1 fn = readFile fn >>= print . sum . filter (100000 >=) . M.elems . accumlate . parseFile . lines
```

</div></details>
-->
<h1 id="パート2-35"><a class="header" href="#パート2-35">パート2</a></h1>
<p>これで、削除するディレクトリを選択する準備が整いました。</p>
<p>ファイルシステムで利用できる合計ディスク容量は<strong>70,000,000</strong>です。
アップデートを実行するには、少なくとも<strong>30,000,000</strong>の空き使用容量が必要です。
アップデートを実行するのに<strong>十分なスペースを解放する</strong>、削除できるディレクトリを見つける必要があります。</p>
<p>上の例では、最も外側のディレクトリの合計サイズ（すなわち使用済み領域の合計）は48381165です。
これは、現在の空き容量が21618835であることを意味しますが、
これはアップデートに必要とされる30000000に足りません。
従って、更新を実行するには、合計サイズが8381165以上のディレクトリをひとつ削除する必要があります。</p>
<p>これを実現するには、次の選択肢があります。</p>
<ul>
<li>ディレクトリ <code>e</code> を削除すると、未使用領域が584だけ増えます。</li>
<li>ディレクトリ <code>a</code> を削除すると、未使用領域が94853だけ増えます。</li>
<li>ディレクトリ <code>d</code> を削除すると、未使用領域が24933642だけ増えます。</li>
<li>ディレクトリ <code>/</code> を削除すると、未使用領域が48381165だけ増えます。</li>
</ul>
<p>ディレクトリ<code>e</code>と<code>a</code>はどちらも小さすぎます。
それらを削除しても、十分なスペースが解放されません。
一方、ディレクトリ<code>d</code>とディレクトリ<code>/</code>はどちらも十分に大きいです。
これらの中から、最小の<code>d</code>を選択し、未使用スペースを24933642だけ増やします。</p>
<p>削除した場合に、
アップデートを実行するのに十分なスペースをファイルシステム上で解放する
最小のディレクトリを見つけます。
<strong>そのディレクトリの合計サイズはどれだけですか？</strong></p>
<!--
<details><summary>解説</summary><div>

間接的に含むものも入れた、各ディレクトリの容量マップは上で作った。
そのマップにおいて、`/` すなわち `[] :: [String]` に割り当てられた値が現在の総使用量。
\\(70,000,000 - root の使用量 + 解放容量 \geq 30,000,000\\)
すなわち
\\(解放容量 \geq rootの使用量 - 40,000,000\\)
を満たす最小の容量をマップから探す。

```haskell
main2 = body2 "input.txt"

body2 fn = do
  m <- accumlate . parseFile . lines <$> readFile fn
  let limit = m M.! [] - 40000000
  print . minimum . filter (limit <=) . M.elems $m
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="8日目-樹上の木の家"><a class="header" href="#8日目-樹上の木の家">8日目: 樹上の木の家</a></h1>
<p>遠征隊は、格子状に注意深く植えられた背の高い木の独特の区画に出くわします。
小人たちは、以前の遠征で、森林再生の取り組みとしてこれらの木を植えたと説明しています。
今、彼らはこれがツリーハウスに適した場所であるかどうかに興味を持っています.</p>
<p>まず、ツリーハウスを<strong>隠す</strong>のに十分な樹木がここにあるかどうかを判断します。
これを行うには、行または列に沿ってまっすぐ見たときに、<strong>グリッドの外側から見える</strong>木の数を数える必要があります。</p>
<p>小人は既に<a href="https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AF%E3%83%83%E3%83%89%E3%83%AD%E3%83%BC%E3%82%BF%E3%83%BC">ドローン</a>を発進させ、
それぞれの木の高さの地図を生成しています（パズル入力）。例えば：</p>
<pre><code>30373
25512
65332
33549
35390
</code></pre>
<p>それぞれの木は数字1文字で表されます。その値が木の高さです。
ここで<code>0</code>は最も短く、<code>9</code>が最も高いです。</p>
<p>ひとつの木に関して、その木とグリッドの外周までの間にある他の全ての木がその木<strong>よりも低い</strong>とき、
その木は<strong>外から見える</strong>状態です。
同じ行または列にある木のみを考慮します。
つまり、その木から上、下、左、右だけを見てください。</p>
<p>グリッドの端にある全ての木は<strong>見えます</strong>。
これらはすでに端にあるため、視界を遮る木はありません。
この例では、これにより考慮すべき木として<strong>内部の9本</strong>のみが残ります。</p>
<ul>
<li>左上の<code>5</code>は左と上から<strong>見えます</strong>。
（右や下からは見えません、途中に高さ<code>5</code>の他の木があるからです。）</li>
<li>上中央の<code>5</code>は上と右から見えます。</li>
<li>右上の<code>1</code>はどの方向からも見えません。
それが見えるようにするには、それと外周までの間は高さ0の木だけでないといけません。</li>
<li>左中央の<code>5</code>は<strong>見えます</strong>が、右からのみです。</li>
<li>中心の<code>3</code>はどの方向からも見えません。
それが見えるようにするには、それと外周までの間は高さ2以下の木だけでないといけません。</li>
<li>右中央の3は右から<strong>見えます</strong>。</li>
<li>一番下の行では、中央の5は<strong>見えます</strong>が、3と4は見えません。</li>
</ul>
<p>端にある16本の木が見え、その他に内部にある木の5本が見えるので、
この配置では合計で21本の木が見えます。</p>
<p>あなたの地図について考えてください。
<strong>グリッドの外から見える木は何本ありますか？</strong></p>
<!--
<details><summary>解説</summary><div>

地図データを読み込んだら、行ごとに分け、地図の高さと幅も数えておく。

```haskell
dss <- lines <$> readFile "input.txt"
let h = length dss
let w = length $ head dss
```

ひとつの方向から見たときの木の高さの列があるとき、
前から順にそれらが見えるかどうかを判定するには、
手前までの最大値よりも自分が高いかどうかを比較すればよい。
ただし先頭については、それより手前の最大値が求められない点に注意する。

```haskell
check :: Ord a => [a] -> [Bool]
check xs = True : zipWith (<>) (scanl1 max xs) (tail xs)
```

`dss`に対して、
それぞれに`check`をそのまま適用すると左から、`reverse`してから適用すると右から、
`transpose`した結果へそれぞれに適用すると上から、さらに`reverse`すると下から、
見えるかどうかの判定結果が得られる。

木のそれぞれがいずれかの方向から見えるかどうかは、
この4方向からの結果のいずれかで見えればよいので、
`accumArray`でこれを足し合わせて数える。

```haskell
tdss = transpose dss
arr = accumArray (||) False ((1,1),(h,w)) $
  [((i,j), True) | (i,ds) <- zip [1..] dss , (j,True) <- zip [1..] (check ds)] ++
  [((i,j), True) | (i,ds) <- zip [1..] dss , (j,True) <- zip [w, pred w..] (check $ reverse ds)] ++
  [((i,j), True) | (j,ds) <- zip [1..] tdss, (i,True) <- zip [1..] (check ds)] ++
  [((i,j), True) | (j,ds) <- zip [1..] tdss, (i,True) <- zip [h, pred h..] (check $ reverse ds)]
```

この配列の中の `True` の個数が答えである。

```haskell
length . filter id . elems $ arr
```

</div></details>
-->
<h1 id="パート2-36"><a class="header" href="#パート2-36">パート2</a></h1>
<p>視界を覆う木の量に満足している小人たちは、ツリーハウスを建てるのに最適な場所だけが知りたいです。
彼らはたくさんの<strong>木</strong>を見たいと思っています。</p>
<p>ひとつの木に対して、そこからの見通しを測定するには、その木から上、下、左、右を見ます。
外周に到達した場合、または対象の木と同じ高さまたはそれよりも高い最初の木に到達した場合に停止します。
（木が端にある場合、少なくとも1つの見通しは零になります。）</p>
<p>小人たちは、上記の規則で見つかったものよりも背の高い遠くの木を気にしません。
提案されたツリーハウスには、乾燥を保つために大きな「ひさし」が付いているため、
いずれにせよツリーハウスより高いところを見ることはできません。</p>
<p>上の例で、2 行目中央の<code>5</code>を考えてみましょう：</p>
<pre><code>30 3 73
25[5]12
65 3 32
33 5 49
35 3 90
</code></pre>
<ul>
<li>見上げると、その視界は遮られていません。それは（高さ3の）1本の木を見ることができます。</li>
<li>左を見ると、その視界はすぐに遮られます。木は1本（高さ5、すぐ隣）のみを見ることができます。</li>
<li>右を見ると、その視界は遮られていません。木が2本見えます。</li>
<li>見下ろすと、その視界は最終的に遮られます。
2本の木を見ることができます（高さ3が1本、次に視界を遮る高さ5の木）。</li>
</ul>
<p>木の<strong>景観スコア</strong>は、4つの方向のそれぞれの見通しを<strong>掛け合わせる</strong>ことによって求められます。
この木の場合、その値は4（\(1 \times 1 \times 2 \times 2\)の掛け算により求められます）です。</p>
<p>しかし、もっとうまくやることができます：
4行目の真ん中にある高さ5の木を考えてみましょう：</p>
<pre><code>30 3 73
25 5 12
65 3 32
33[5]49
35 3 90
</code></pre>
<ul>
<li>見上げると、その視界は2本めの木で遮られています（高さ5の別の木によって）。</li>
<li>左を見ると、その視界は遮られていません。2本の木が見えます。</li>
<li>見下ろしても、視界も遮られません。1本の木が見えます。</li>
<li>右を見ると、その視界は2本めの木で遮られています (高さ9の巨木によって）。</li>
</ul>
<p>この木の景観スコアは8 \((2 \times 2 \times 1 \times 2)\) です。
ここがツリーハウスの理想の場所です。</p>
<p>マップ上のそれぞれの木を調べてください。
<strong>いずれかの木で達成される最大の景観スコアはいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

ある木から外周までの高さの列があるとき、その方向の見通しは、
その高さ以上になるまでの木の本数であるが、視界を遮ったその木も数える。
しかし、外周まで遮られずに視界が達したとき、数える木がないので、この二つを区別する必要がある。

```haskell
viewscore (x:xs) =
  case span (x >) xs of
    (as,[ ]) -> length as
    (as,_:_) -> succ $ length as
```

`reverse`を高速化するテクニックで、要素をひとつずつ移動させる内部関数を立てた。

```haskell
reverse xs = rev [] xs
  where
    rev ys [] = ys
    rev ys (x:xs) = rev (x:ys) xs
```

これと同様にして、一列の木の並びに対して、全ての木のそこから右とそこから左の見通しを同時に計算できる。

```haskell
part2sub ys [] = []
part2sub ys (x:xs) = viewscore ys * viewscore xs : part2sub (x:ys) xs
  where
    count zs = case span (x >) zs of
      (as,[]) -> length as
      (as,_ ) -> succ $ length as
```

あとは、全ての行と、パート1同様に`transpose`を用いて全ての列についてこれを行い、
結果を掛け合わせて最大値を見つける。

```haskell
part2 h w dss = maximumBy (compare `on` snd) . assocs $ arr
  where
    tdss = transpose dss
    arr = accumArray (*) 1 ((1,1),(h,w)) $
      [((i,j), s) | (i,ds) <- zip [1..] dss , (j,s) <- zip [1..] $ part2sub [] ds] ++
      [((i,j), s) | (j,ds) <- zip [1..] tdss, (i,s) <- zip [1..] $ part2sub [] ds]
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="9日目-吊り橋"><a class="header" href="#9日目-吊り橋">9日目: 吊り橋</a></h1>
<p>この吊り橋は、あなたが歩くと軋みます。
どれほど古いものなのか、あなたの体重を支えられるかどうかも怪しいです。</p>
<p>とはいえ、小人の体重を支えるぶんには大丈夫なようです。
橋は、あなたのはるか眼下の巨大な川によって切り開かれた峡谷にまたがっています。</p>
<p>あなたは慎重に足を踏み入れます。それにより、ロープは伸びてねじれます。
あなたは、ロープの物理をモデル化して気を紛らわせることにしました。
踏んではいけない場所を見つけることができるかもしれません。</p>
<p>両端に結び目があるロープを考えます。
これらの結び目は、ロープの<strong>頭</strong>と<strong>尾</strong>を示しています。
頭が尻尾から十分に離れると、尾は頭の方に引っ張られます。</p>
<p><a href="https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%A9%E3%83%B3%E3%82%AF%E9%95%B7">プランク長</a>
に関する漠然とした推論により、2次元グリッド上の結び目の位置をモデル化できるはずです。
すると、頭結び目の<strong>仮想的な一連の動き</strong>（パズルの入力）に従うことで、
<strong>尾</strong>がどのように動くかを決定できます。</p>
<p>前述のプランク長により、ロープはきわめて短くする必要があります。
実際、頭(<code>H</code>)と尾(<code>T</code>)は<strong>常に接触している</strong>必要があります。
（角で接している場合と、重なり合っている場合も、接触していると見なします。）</p>
<pre><code>....
.TH.
....

....
.H..
..T.
....

...
.H. (H は T に重なっている)
...
</code></pre>
<p>頭が尻尾から2歩上、下、左、右にある場合、尻尾もその方向に1歩移動して、十分に近い状態を保つ必要があります。</p>
<pre><code>.....    .....    .....
.TH.. -&gt; .T.H. -&gt; ..TH.
.....    .....    .....

...    ...    ...
.T.    .T.    ...
.H. -&gt; ... -&gt; .T.
...    .H.    .H.
...    ...    ...
</code></pre>
<p>それ以外の場合、頭と尾が接しておらず、同じ行または列にない場合、尾は常に1ステップ斜めに移動して追いつきます。</p>
<pre><code>.....    .....    .....
.....    ..H..    ..H..
..H.. -&gt; ..... -&gt; ..T..
.T...    .T...    .....
.....    .....    .....

.....    .....    .....
.....    .....    .....
..H.. -&gt; ...H. -&gt; ..TH.
.T...    .T...    .....
.....    .....    .....
</code></pre>
<p>頭が一連の動きに追従するときに、尾がどこに行くのかを理解する必要があります。
頭と尾の両方が同じ位置から始まり、重なり合っていると仮定します。</p>
<p>例えば：</p>
<pre><code>R 4
U 4
L 3
D 1
R 4
D 1
L 5
R 2
</code></pre>
<p>この一連の動作により、頭が<strong>右</strong>に4歩移動し、次に4歩<strong>上</strong>に移動し、
次に3歩<strong>左</strong>に移動し、次に1歩<strong>下</strong>に移動します。
各ステップの後、ステップによって頭が尾に隣接していない場合は、尾の位置を更新する必要があります。
視覚的には、これらの動きは次のように表せます。
（<code>s</code>は開始位置を示す印で、参照点です。）</p>
<pre><code>== 初期状態 ==

......
......
......
......
H.....  (H は T, s と重なっている)

== R 4 ==

......
......
......
......
TH....  (T は s と重なっている)

......
......
......
......
sTH...

......
......
......
......
s.TH..

......
......
......
......
s..TH.

== U 4 ==

......
......
......
....H.
s..T..

......
......
....H.
....T.
s.....

......
....H.
....T.
......
s.....

....H.
....T.
......
......
s.....

== L 3 ==

...H..
....T.
......
......
s.....

..HT..
......
......
......
s.....

.HT...
......
......
......
s.....

== D 1 ==

..T...
.H....
......
......
s.....

== R 4 ==

..T...
..H...
......
......
s.....

..T...
...H..
......
......
s.....

......
...TH.
......
......
s.....

......
....TH
......
......
s.....

== D 1 ==

......
....T.
.....H
......
s.....

== L 5 ==

......
....T.
....H.
......
s.....

......
....T.
...H..
......
s.....

......
......
..HT..
......
s.....

......
......
.HT...
......
s.....

......
......
HT....
......
s.....

== R 2 ==

......
......
.H....  (H は T と重なっている)
......
s.....

......
......
.TH...
......
s.....
</code></pre>
<p>ロープのシミュレーションを実施すると、
<strong>尾が少なくとも一度訪れた</strong>全ての位置を数えることができます。
この図では、<code>s</code>は今回も開始位置（これは尾も訪問している）、
<code>#</code>は尾が訪問したその他の位置を印しています。</p>
<pre><code>..##..
...##.
.####.
....#.
s###..
</code></pre>
<p>したがって、13箇所が、尾が少なくとも一度訪れた位置です。</p>
<p>完全に架空の一連の動作をシミュレーションしてください。
<strong>ロープの尾が少なくとも一度訪れる位置は何か所ですか？</strong></p>
<!--
<details><summary>解説</summary><div>

- 頭は4近傍で1ずつだけ移動する。
- 尾は頭と横軸縦軸ともに差が1までなら許容される。（動かない）
- いずれかの軸はずれておらず、もう一方の軸だけ2ずれた場合、そのずれを1修正して4近傍に移動する。
- 両方の軸がずれた場合、両方について補正をかける。

この規則に合うように、頭の位置と尾の位置から、尾の新しい位置を求める計算を定義する。

```haskell
follow (tx,ty) (hx,hy)
  | abs dx <= 1 && abs dy <= 1 = (tx,ty)
  | dx == 0 = (tx, ty1)
  | dy == 0 = (tx1, ty)
  | otherwise = (tx1, ty1)
  where
    dx = hx - tx
    dy = hy - ty
    tx1 = tx + signum dx
    ty1 = ty + signum dy
```

あとは、ファイルを読み込み、頭の位置の系列を作る
尾を追尾させ、その座標を集合に入れて、要素数を数える。

```haskell
import qualified Data.Set as S

main1 = body1 "input.txt"
test1 = body1 "test.txt"

body1 fn = readFile fn >>= print . compute1 . lines

compute1 :: [String] -> Int
compute1 ls = S.size $ S.fromList tailPoss
  where
    headPoss =
      scanl add (0,0) $
      concatMap ((\[d,n] -> replicate (read n) (delta $ head d)) . words) ls
    tailPoss = scanl follow (0,0) headPoss

add (x,y) (z,w) = (x+z, y+w)

delta 'U' = (0,-1)
delta 'D' = (0, 1)
delta 'L' = (-1,0)
delta 'R' = ( 1,0)
```

</div></details>
-->
<h1 id="パート2-37"><a class="header" href="#パート2-37">パート2</a></h1>
<p>ロープがプツリと切れる！
突然、川はあなたがこれまでに見たことのあるよりもはるかに近づいています。
橋はまだそこにありますが、千切れたロープの一部は、空中を落下しつつあるあなたに向かって鞭打っています!</p>
<p>ロープの動きが速すぎて掴めません。
叩かれるのを避けるために体を反らせる方法を選択するのに数秒しかありません。
幸いなことに、シミュレーションを拡張して、より長いロープに対応できます。</p>
<p>結び目が2つではなく、<strong>10</strong>個の結び目で構成されるロープをシミュレーションする必要があります。
結び目のひとつはやはりロープの頭で、一連の動きに従って動きます。
ロープの続きにある結び目はそれぞれ、前と同じ規則を使用して、その直前の結び目に従います。</p>
<p>上記の例と同じ一連の動きを使用しますが、
結び目を<code>H</code>,<code>1</code>,<code>2</code>,…,<code>9</code>と印すと、動きは次のようになります。</p>
<pre><code>== 初期状態 ==

......
......
......
......
H.....  (H は 1, 2, 3, 4, 5, 6, 7, 8, 9, s と重なっている)

== R 4 ==

......
......
......
......
1H....  (1 は 2, 3, 4, 5, 6, 7, 8, 9, s と重なっている)

......
......
......
......
21H...  (2 は 3, 4, 5, 6, 7, 8, 9, s と重なっている)

......
......
......
......
321H..  (3 は 4, 5, 6, 7, 8, 9, s と重なっている)

......
......
......
......
4321H.  (4 は 5, 6, 7, 8, 9, s と重なっている)

== U 4 ==

......
......
......
....H.
4321..  (4 は 5, 6, 7, 8, 9, s と重なっている)

......
......
....H.
.4321.
5.....  (5 は 6, 7, 8, 9, s と重なっている)

......
....H.
....1.
.432..
5.....  (5 は 6, 7, 8, 9, s と重なっている)

....H.
....1.
..432.
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

== L 3 ==

...H..
....1.
..432.
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

..H1..
...2..
..43..
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

.H1...
...2..
..43..
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

== D 1 ==

..1...
.H.2..
..43..
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

== R 4 ==

..1...
..H2..
..43..
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

..1...
...H..  (H は 2 と重なっている)
..43..
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

......
...1H.  (1 は 2 と重なっている)
..43..
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

......
...21H
..43..
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

== D 1 ==

......
...21.
..43.H
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

== L 5 ==

......
...21.
..43H.
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

......
...21.
..4H..  (H は 3 と重なっている)
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

......
...2..
..H1..  (H は 4と、1 は 3 と重なっている)
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

......
...2..
.H13..  (1 は 4 と重なっている)
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

......
......
H123..  (2 は 4 と重なっている)
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

== R 2 ==

......
......
.H23..  (H は 1 と、2 は 4 と重なっている)
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

......
......
.1H3..  (H は 2, 4 と重なっている)
.5....
6.....  (6 は 7, 8, 9, s と重なっている)
</code></pre>
<p>さて、新たな尾<code>9</code>が訪れる位置を追跡する必要があります。
この例では、尻尾は決して動かないため、1箇所を訪問するだけです。
ただし<strong>注意してください</strong>。
以前よりも多くの種類の動きが可能になるため、
あなたのシミュレーションによるロープと上のロープを視覚的に比較することをお勧めします。</p>
<p>より大きな例を次に示します。</p>
<pre><code>R 5
U 8
L 8
D 3
R 17
D 10
L 25
U 20
</code></pre>
<p>これらの動作は次のようになります (個々のステップは示されていません)。</p>
<pre><code>== 初期状態 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........H..............  (H は 1, 2, 3, 4, 5, 6, 7, 8, 9, s と重なっている)
..........................
..........................
..........................
..........................
..........................

== R 5 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........54321H.........  (5 は 6, 7, 8, 9, s と重なっている)
..........................
..........................
..........................
..........................
..........................

== U 8 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
................H.........
................1.........
................2.........
................3.........
...............54.........
..............6...........
.............7............
............8.............
...........9..............  (9 は s と重なっている)
..........................
..........................
..........................
..........................
..........................

== L 8 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
........H1234.............
............5.............
............6.............
............7.............
............8.............
............9.............
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
..........................

== D 3 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
.........2345.............
........1...6.............
........H...7.............
............8.............
............9.............
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
..........................

== R 17 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
................987654321H
..........................
..........................
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
..........................

== D 10 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........s.........98765
.........................4
.........................3
.........................2
.........................1
.........................H

== L 25 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
H123456789................

== U 20 ==

H.........................
1.........................
2.........................
3.........................
4.........................
5.........................
6.........................
7.........................
8.........................
9.........................
..........................
..........................
..........................
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
..........................
</code></pre>
<p>こうして、尾(<code>9</code>)は36箇所（<code>s</code>を含む）を少なくとも一度訪問します。</p>
<pre><code>..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
#.........................
#.............###.........
#............#...#........
.#..........#.....#.......
..#..........#.....#......
...#........#.......#.....
....#......s.........#....
.....#..............#.....
......#............#......
.......#..........#.......
........#........#........
.........########.........
</code></pre>
<p>結び目の10個ある長いロープの一連の動作をシミュレーションします。
<strong>ロープの尾が少なくとも一度訪れる位置は何か所ですか？</strong></p>
<!--
<details><summary>解説</summary><div>

「前の結び目の位置を追尾した列を作る」という計算を9回重ねて実行するように変更する。

```haskell
main2 = body2 "input.txt"
test2 = body2 "test.txt"
test3 = body2 "test2.txt"

body2 fn = readFile fn >>= print . S.size . compute2 . lines

compute2 :: [String] -> S.Set (Int,Int)
compute2 ls = S.fromList tailPoss
  where
    headPoss =
      scanl add (0,0) $
      concatMap ((\[d,n] -> replicate (read n) (delta $ head d)) . words) ls
    knot xys = scanl follow (0,0) xys
    tailPoss = iterate knot headPoss !! 9
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="10日目-ブラウン管-crt"><a class="header" href="#10日目-ブラウン管-crt">10日目: ブラウン管 (CRT)</a></h1>
<p>ロープを避け、川に飛び込み、岸まで泳ぎます。</p>
<p>小人は上流で彼らと再会することについて何かを叫んでいますが、
川の流れが騒がしすぎて彼らが何を言っているのか正確にはわかりません。
彼らは橋を渡り終え、視界から消えます。</p>
<p>小人があなたの携帯端末の通信システムを機能させることを優先した理由こそ、
このような状況に違いありません。
リュックから取り出してみると、画面の大きなひび割れからゆっくりと水が流れ出ていて、
すぐにはあまり役に立たないことがわかります。</p>
<p><strong>そうでもない！</strong>
つまり、あなたは装置のビデオシステムの代替品を設計できるからです！
それは、正確な<strong>クロック回路</strong>で駆動される、
ある種の<a href="https://ja.wikipedia.org/wiki/%E3%83%96%E3%83%A9%E3%82%A6%E3%83%B3%E7%AE%A1">ブラウン管</a>画面と
簡単なCPUのようです。
クロック回路は一定の速さで時を刻みます。それぞれの刻みを<strong>サイクル</strong>と呼びます。</p>
<p>まず、CPUから送信されている信号を理解することから始めます。
CPUには単一のレジスタ<code>X</code>があります。これは値<code>1</code>で始まります。
CPUは次の2つの命令のみをサポートします。</p>
<ul>
<li><code>addx V</code> 完了するまでに<strong>2サイクル</strong>かかります。
2サイクル<strong>後</strong>、<code>X</code>レジスタは値<code>V</code>だけ増加します。
（<code>V</code>は負の値になることもあります。）</li>
<li><code>noop</code> 完了するまでに<strong>1サイクル</strong>かかります。それ以外の効果はありません。</li>
</ul>
<p>CPUは、プログラム（パズル入力）にあるこれらの命令を使用して、
どういうわけか、何を描画するかを画面に伝えます。</p>
<p>次の小さなプログラムを考えましょう：</p>
<pre><code>noop
addx 3
addx -5
</code></pre>
<p>このプログラムの実行は次のように進行します。</p>
<ul>
<li>最初のサイクルの開始時に、<code>noop</code>命令の実行が開始されます。
最初のサイクルでは、<code>X</code>は<code>1</code>です。
最初のサイクルの後、<code>noop</code>命令は何もせずに実行を終了します。</li>
<li>2番目のサイクルの開始時に、<code>addx 3</code>命令の実行が開始されます。
2番目のサイクル中は、<code>X</code>はまだ<code>1</code>です。</li>
<li>3番目のサイクルでは、<code>X</code>はまだ<code>1</code>です。
3番目のサイクルの後、<code>addx 3</code>命令は実行を終了し、<code>X</code>は<code>4</code>に設定されます。</li>
<li>4番目のサイクルの開始時に、<code>addx -5</code>命令の実行が開始されます。
4番目のサイクルの間、<code>X</code>はまだ<code>4</code>です。</li>
<li>5番目のサイクルの間、<code>X</code>はまだ<code>4</code>です。
5番目のサイクルの後、<code>addx -5</code>命令は実行を終了し、<code>X</code>は<code>-1</code>に設定されます。</li>
</ul>
<p>実行中にレジスタ<code>X</code>の値を観察することで、何かを学ぶことができるかもしれません。
ここでは、20番目のサイクルとその後40サイクルごと
（つまり、20番目、60番目、100番目、140番目、180番目、220番目のサイクル）の信号強度
（サイクル数に<code>X</code>レジスタの値を乗じた値）を考えてみましょう。</p>
<p>例えば、次のもう少し大きいプログラムを考えてみましょう：</p>
<pre><code>addx 15
addx -11
addx 6
addx -3
addx 5
addx -1
addx -8
addx 13
addx 4
noop
addx -1
addx 5
addx -1
addx 5
addx -1
addx 5
addx -1
addx 5
addx -1
addx -35
addx 1
addx 24
addx -19
addx 1
addx 16
addx -11
noop
noop
addx 21
addx -15
noop
noop
addx -3
addx 9
addx 1
addx -3
addx 8
addx 1
addx 5
noop
noop
noop
noop
noop
addx -36
noop
addx 1
addx 7
noop
noop
noop
addx 2
addx 6
noop
noop
noop
noop
noop
addx 1
noop
noop
addx 7
addx 1
noop
addx -13
addx 13
addx 7
noop
addx 1
addx -33
noop
noop
noop
addx 2
noop
noop
noop
addx 8
noop
addx -1
addx 2
addx 1
noop
addx 17
addx -9
addx 1
addx 1
addx -3
addx 11
noop
noop
addx 1
noop
addx 1
noop
noop
addx -13
addx -19
addx 1
addx 3
addx 26
addx -30
addx 12
addx -1
addx 3
addx 1
noop
noop
noop
addx -9
addx 18
addx 1
addx 2
noop
noop
addx 9
noop
noop
noop
addx -1
addx 2
addx -37
addx 1
addx 3
noop
addx 15
addx -21
addx 22
addx -6
addx 1
noop
addx 2
addx 1
noop
addx -10
noop
noop
addx 20
addx 1
addx 2
addx 2
addx -6
addx -11
noop
noop
noop
</code></pre>
<p>興味のある信号強度は、次のように求められます：</p>
<ul>
<li>20番目のサイクルでは、 レジスタ<code>X</code>の値は<code>21</code>であるため、信号強度は\(20 \times 21 = 420\)です。
(20番目のサイクルは二つめの<code>addx -1</code>の途中で起き、
このときのレジスタ<code>X</code>の値は、開始値の<code>1</code>と、この位置までの全ての<code>addx</code>命令の値を足し合わせた値となります。
\(1 + 15 - 11 + 6 - 3 + 5 - 1 - 8 + 13 + 4 = 21\)</li>
<li>60番目のサイクルでは、レジスタ<code>X</code>の値は<code>19</code>であるため、信号強度は\(60 \times 19 = 1140\)です。</li>
<li>100番目のサイクルでは、レジスタ<code>X</code>の値は<code>18</code>であるため、信号強度は\(100 \times 18 = 1800\)です。</li>
<li>140番目のサイクルでは、レジスタ<code>X</code>の値は<code>21</code>であるため、信号強度は\(140 \times 21 = 2940\)です。</li>
<li>180番目のサイクルでは、レジスタ<code>X</code>の値は<code>16</code>であるため、信号強度は\(180 \times 16 = 2880\)です。</li>
<li>220番目のサイクルでは、レジスタ<code>X</code>の値は<code>18</code>であるため、信号強度は\(220 \times 18 = 3960\)です。</li>
</ul>
<p>これらの信号強度の合計は<strong>13140</strong>です。</p>
<p>20回目、60回目、100回目、140回目、180回目、220回目のサイクルの信号強度を求めます。
<strong>これらの6つの信号強度の合計はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

命令列を行ごとに区切って与える。
命令列によって、時間が流れてXの値が変化していく。
次のクロックの開始時のXの値を生成するループを作る。

```haskell
loop :: Int -> [String] -> [Int]
loop x (cs:css) =
  case words cs of
    ["noop"] -> x : loop x css
    ["addx",arg] -> let x1 = x + read arg in x : x1 : loop x1 css
loop x [] = [x]
```

必要な時刻のレジスタ値を抜き出して答えを計算する。

```haskell
body1 fn = do
  ls <- lines <$> readFile fn
  let xs = 0 : loop 1 ls
  print $ sum $ map (\i -> i * xs !! pred i) [20,60..220]

main1 = body1 "input.txt"
```

</div></details>
-->
<h1 id="パート2-38"><a class="header" href="#パート2-38">パート2</a></h1>
<p><code>X</code>レジスタが<a href="https://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%97%E3%83%A9%E3%82%A4%E3%83%88_(%E6%98%A0%E5%83%8F%E6%8A%80%E8%A1%93)">スプライト</a>の水平位置を制御しているようです。
具体的には、スプライトの幅は3ピクセルで、レジスタ<code>X</code>はそのスプライトの<strong>中央</strong>の水平位置を設定します。
（このシステムでは、「垂直位置」のようなものはありません。
CRTが現在描画している場所にスプライトの水平位置がピクセルを置くとき、
それらのピクセルが描画されます。）</p>
<p>あなたはCRTのピクセルを数えます: 幅40ピクセル、高さ6ピクセルです。
このCRT画面は、ピクセルの一番上の行を左から右に描画し、次にその下の行というように描画します。
各行の左端のピクセルは位置<code>0</code>にあり、各行の右端のピクセルは位置<code>39</code>にあります。</p>
<p>CPUと同様に、CRTはクロック回路と密接に結びついています。
CRTは<strong>各サイクルで1つのピクセルを描画します</strong>。
画面の各ピクセルを<code>#</code>で表して、
各行の最初と最後のピクセルが描画されるサイクルは次のとおりです。</p>
<pre><code>Cycle   1 -&gt; ######################################## &lt;- Cycle  40
Cycle  41 -&gt; ######################################## &lt;- Cycle  80
Cycle  81 -&gt; ######################################## &lt;- Cycle 120
Cycle 121 -&gt; ######################################## &lt;- Cycle 160
Cycle 161 -&gt; ######################################## &lt;- Cycle 200
Cycle 201 -&gt; ######################################## &lt;- Cycle 240
</code></pre>
<p>したがって、 CPU命令とCRT描画操作のタイミングを慎重に調整することで、
各ピクセルが描画された瞬間にスプライトが表示されるかどうかを決定できるはずです。
3つのピクセルのうちの1つが現在描画されているピクセルになるようにスプライトが配置された場合、
画面は<strong>点灯している</strong>ピクセル (<code>#</code>) を生成します。
そうでない場合、画面はピクセルを<strong>暗いまま</strong> (<code>.</code>) にします。</p>
<p>上の大きな例の最初の数ピクセルは、次のように描画されます。</p>
<pre><code>Sprite position: ###.....................................

Start cycle   1: begin executing addx 15
During cycle  1: CRT draws pixel in position 0
Current CRT row: #

During cycle  2: CRT draws pixel in position 1
Current CRT row: ##
End of cycle  2: finish executing addx 15 (Register X is now 16)
Sprite position: ...............###......................

Start cycle   3: begin executing addx -11
During cycle  3: CRT draws pixel in position 2
Current CRT row: ##.

During cycle  4: CRT draws pixel in position 3
Current CRT row: ##..
End of cycle  4: finish executing addx -11 (Register X is now 5)
Sprite position: ....###.................................

Start cycle   5: begin executing addx 6
During cycle  5: CRT draws pixel in position 4
Current CRT row: ##..#

During cycle  6: CRT draws pixel in position 5
Current CRT row: ##..##
End of cycle  6: finish executing addx 6 (Register X is now 11)
Sprite position: ..........###...........................

Start cycle   7: begin executing addx -3
During cycle  7: CRT draws pixel in position 6
Current CRT row: ##..##.

During cycle  8: CRT draws pixel in position 7
Current CRT row: ##..##..
End of cycle  8: finish executing addx -3 (Register X is now 8)
Sprite position: .......###..............................

Start cycle   9: begin executing addx 5
During cycle  9: CRT draws pixel in position 8
Current CRT row: ##..##..#

During cycle 10: CRT draws pixel in position 9
Current CRT row: ##..##..##
End of cycle 10: finish executing addx 5 (Register X is now 13)
Sprite position: ............###.........................

Start cycle  11: begin executing addx -1
During cycle 11: CRT draws pixel in position 10
Current CRT row: ##..##..##.

During cycle 12: CRT draws pixel in position 11
Current CRT row: ##..##..##..
End of cycle 12: finish executing addx -1 (Register X is now 12)
Sprite position: ...........###..........................

Start cycle  13: begin executing addx -8
During cycle 13: CRT draws pixel in position 12
Current CRT row: ##..##..##..#

During cycle 14: CRT draws pixel in position 13
Current CRT row: ##..##..##..##
End of cycle 14: finish executing addx -8 (Register X is now 4)
Sprite position: ...###..................................

Start cycle  15: begin executing addx 13
During cycle 15: CRT draws pixel in position 14
Current CRT row: ##..##..##..##.

During cycle 16: CRT draws pixel in position 15
Current CRT row: ##..##..##..##..
End of cycle 16: finish executing addx 13 (Register X is now 17)
Sprite position: ................###.....................

Start cycle  17: begin executing addx 4
During cycle 17: CRT draws pixel in position 16
Current CRT row: ##..##..##..##..#

During cycle 18: CRT draws pixel in position 17
Current CRT row: ##..##..##..##..##
End of cycle 18: finish executing addx 4 (Register X is now 21)
Sprite position: ....................###.................

Start cycle  19: begin executing noop
During cycle 19: CRT draws pixel in position 18
Current CRT row: ##..##..##..##..##.
End of cycle 19: finish executing noop

Start cycle  20: begin executing addx -1
During cycle 20: CRT draws pixel in position 19
Current CRT row: ##..##..##..##..##..

During cycle 21: CRT draws pixel in position 20
Current CRT row: ##..##..##..##..##..#
End of cycle 21: finish executing addx -1 (Register X is now 20)
Sprite position: ...................###..................
</code></pre>
<p>プログラムを最後まで実行させると、CRTは次の映像を生成します。</p>
<pre><code>##..##..##..##..##..##..##..##..##..##..
###...###...###...###...###...###...###.
####....####....####....####....####....
#####.....#####.....#####.....#####.....
######......######......######......####
#######.......#######.......#######.....
</code></pre>
<p>あなたのプログラムによって与えられた画像をレンダリングします。
<strong>CRTに表示される8つの大文字は何ですか？</strong></p>
<!--
<details><summary>解説</summary><div>

時刻 \\(t\\) のスキャン位置が光るかどうかは、時刻 \\(t-1\\) のレジスタの値で定まる。
スキャン位置 \\((t - 1) \bmod 40\\) と
レジスタの値の差が \\(\pm 1\\) に収まっているとき、ピクセルは光る。

```haskell
import Data.List.Split

body2 fn = do
  ls <- lines <$> readFile fn
  let xs = 1 : loop 1 ls
  let ps = zipWith sprite [0..] xs
  mapM_ putStrLn $ chunksOf 40 ps

sprite t x
  | pred x <= tm && tm <= succ x = '#'
  | otherwise = ' '
  where
    tm = mod t 40

main2 = body2 "input.txt"
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="11日目-サルインザミドル中間猿攻撃"><a class="header" href="#11日目-サルインザミドル中間猿攻撃">11日目: サル・イン・ザ・ミドル（中間猿攻撃）</a></h1>
<p>ようやく川を遡り始めると、リュックが思ったよりもずっと軽いことに気づきます。
ちょうどその時、リュックの荷物のひとつが頭上を飛んでいきます。
サルはあなたの無くし物で<a href="https://en.wikipedia.org/wiki/Keep_away">Keep Away</a>をして遊んでいます！</p>
<p>荷物を取り戻すには、サルがどこに荷物を投げるかを予測できる必要があります。
注意深い観察の結果、サルは<strong>それぞれの荷物に対するあなたの心配度</strong>に基づいて行動していることに気付きました。</p>
<p>それぞれのサルが現在持っている荷物、それらの荷物に対するあなたの心配度、
心配度に基づいてサルがどのように決定を下すかについて、
あなたは何やらメモを取りました（パズル入力）。
例えば：</p>
<pre><code>Monkey 0:
  Starting items: 79, 98
  Operation: new = old * 19
  Test: divisible by 23
    If true: throw to monkey 2
    If false: throw to monkey 3

Monkey 1:
  Starting items: 54, 65, 75, 74
  Operation: new = old + 6
  Test: divisible by 19
    If true: throw to monkey 2
    If false: throw to monkey 0

Monkey 2:
  Starting items: 79, 60, 97
  Operation: new = old * old
  Test: divisible by 13
    If true: throw to monkey 1
    If false: throw to monkey 3

Monkey 3:
  Starting items: 74
  Operation: new = old + 3
  Test: divisible by 17
    If true: throw to monkey 0
    If false: throw to monkey 1
</code></pre>
<p>それぞれのサルはいくつかの属性を持ちます。</p>
<ul>
<li><code>Starting items</code> サルが現在持っている荷物のそれぞれの<strong>心配度</strong>の、サルがそれを検分する順番のリストです。</li>
<li><code>Operation</code> サルが荷物を検分することで、あなたの心配度がどのように変化するかを示しています。
（例えば <code>new = old * 5</code> とあるとき、
サルが荷物を検分した後の心配度が、検査前の心配度の5倍になることを意味します。）</li>
<li><code>Test</code> は、サルがあなたの心配度を使用して、次にどこに荷物を投げるかを決定する方法を示しています。
<ul>
<li><code>If true</code> テストが真になるときに荷物がどうなるかを示します。</li>
<li><code>If false</code> テストが偽の場合に荷物がどうなるかを示します。</li>
</ul>
</li>
</ul>
<p>サルが荷物を検分した後、あなたの心配度に対してTestをする前に、
サルの検分が荷物を駄目にせずに済んだというあなたの安堵が、
あなたの心配度を<strong>3で割り</strong>、最も近い整数に切り捨てます。
（訳注：「近い」でなく床関数での切り捨て）</p>
<p>サルは順に荷物を検分して投げます。
あるサルの番では、そのサルが持っている全ての荷物を一度にひとつずつ、リストにある順に、
検分しては投げます。
サル<code>0</code>が最初に、次にサル<code>1</code>というように、全てのサルに順番が回るまで続けます。
全てのサルに一度順番が回る過程を<strong>ラウンド</strong>（一巡）と呼びます。</p>
<p>サルが別のサルに荷物を投げると、その荷物は受け取ったサルのリストの<strong>末尾</strong>に入ります。
あるサルが開始時にリストに荷物がない状態であったとしても、
順番が回ってきたときには検分して投げる荷物を大量に持っていることになる可能性があります。
サルが自分の番の開始時に荷物を持っていない場合、そのサルの番はそれで終わりです。</p>
<p>上記の例では、最初のラウンドは次のように進行します。</p>
<pre><code>Monkey 0:
  Monkey inspects an item with a worry level of 79.
    Worry level is multiplied by 19 to 1501.
    Monkey gets bored with item. Worry level is divided by 3 to 500.
    Current worry level is not divisible by 23.
    Item with worry level 500 is thrown to monkey 3.
訳：
サル 0:
  サルが心配度79の荷物を検分します。
  心配度に19を掛けて1501になります。
  サルが荷物に飽きました。心配度は3で割って500になります。
  現在の心配度は23で割り切れません。
  心配度500の荷物がサル3に投げられます。
</code></pre>
<p>続き</p>
<pre><code>  Monkey inspects an item with a worry level of 98.
    Worry level is multiplied by 19 to 1862.
    Monkey gets bored with item. Worry level is divided by 3 to 620.
    Current worry level is not divisible by 23.
    Item with worry level 620 is thrown to monkey 3.
Monkey 1:
  Monkey inspects an item with a worry level of 54.
    Worry level increases by 6 to 60.
    Monkey gets bored with item. Worry level is divided by 3 to 20.
    Current worry level is not divisible by 19.
    Item with worry level 20 is thrown to monkey 0.
  Monkey inspects an item with a worry level of 65.
    Worry level increases by 6 to 71.
    Monkey gets bored with item. Worry level is divided by 3 to 23.
    Current worry level is not divisible by 19.
    Item with worry level 23 is thrown to monkey 0.
  Monkey inspects an item with a worry level of 75.
    Worry level increases by 6 to 81.
    Monkey gets bored with item. Worry level is divided by 3 to 27.
    Current worry level is not divisible by 19.
    Item with worry level 27 is thrown to monkey 0.
  Monkey inspects an item with a worry level of 74.
    Worry level increases by 6 to 80.
    Monkey gets bored with item. Worry level is divided by 3 to 26.
    Current worry level is not divisible by 19.
    Item with worry level 26 is thrown to monkey 0.
Monkey 2:
  Monkey inspects an item with a worry level of 79.
    Worry level is multiplied by itself to 6241.
    Monkey gets bored with item. Worry level is divided by 3 to 2080.
    Current worry level is divisible by 13.
    Item with worry level 2080 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 60.
    Worry level is multiplied by itself to 3600.
    Monkey gets bored with item. Worry level is divided by 3 to 1200.
    Current worry level is not divisible by 13.
    Item with worry level 1200 is thrown to monkey 3.
  Monkey inspects an item with a worry level of 97.
    Worry level is multiplied by itself to 9409.
    Monkey gets bored with item. Worry level is divided by 3 to 3136.
    Current worry level is not divisible by 13.
    Item with worry level 3136 is thrown to monkey 3.
Monkey 3:
  Monkey inspects an item with a worry level of 74.
    Worry level increases by 3 to 77.
    Monkey gets bored with item. Worry level is divided by 3 to 25.
    Current worry level is not divisible by 17.
    Item with worry level 25 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 500.
    Worry level increases by 3 to 503.
    Monkey gets bored with item. Worry level is divided by 3 to 167.
    Current worry level is not divisible by 17.
    Item with worry level 167 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 620.
    Worry level increases by 3 to 623.
    Monkey gets bored with item. Worry level is divided by 3 to 207.
    Current worry level is not divisible by 17.
    Item with worry level 207 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 1200.
    Worry level increases by 3 to 1203.
    Monkey gets bored with item. Worry level is divided by 3 to 401.
    Current worry level is not divisible by 17.
    Item with worry level 401 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 3136.
    Worry level increases by 3 to 3139.
    Monkey gets bored with item. Worry level is divided by 3 to 1046.
    Current worry level is not divisible by 17.
    Item with worry level 1046 is thrown to monkey 1.
</code></pre>
<p>第1ラウンドの後、サルはそれぞれ次の心配度の荷物を持っています：</p>
<pre><code>Monkey 0: 20, 23, 27, 26
Monkey 1: 2080, 25, 167, 207, 401, 1046
Monkey 2: 
Monkey 3: 
</code></pre>
<p>サル<code>2</code>と<code>3</code>は、このラウンドの終了時に荷物を持っていません。
彼らはどちらもラウンド中に全ての荷物を検分し、ラウンドが終了する前にそれらを全て投げました。</p>
<p>この過程は、さらに数ラウンド続きます。</p>
<pre><code>After round 2, the monkeys are holding items with these worry levels:
第2ラウンドの後にサルたちが持つ荷物の心配度：
Monkey 0: 695, 10, 71, 135, 350
Monkey 1: 43, 49, 58, 55, 362
Monkey 2: 
Monkey 3: 

After round 3, the monkeys are holding items with these worry levels:
Monkey 0: 16, 18, 21, 20, 122
Monkey 1: 1468, 22, 150, 286, 739
Monkey 2: 
Monkey 3: 

After round 4, the monkeys are holding items with these worry levels:
Monkey 0: 491, 9, 52, 97, 248, 34
Monkey 1: 39, 45, 43, 258
Monkey 2: 
Monkey 3: 

After round 5, the monkeys are holding items with these worry levels:
Monkey 0: 15, 17, 16, 88, 1037
Monkey 1: 20, 110, 205, 524, 72
Monkey 2: 
Monkey 3: 

After round 6, the monkeys are holding items with these worry levels:
Monkey 0: 8, 70, 176, 26, 34
Monkey 1: 481, 32, 36, 186, 2190
Monkey 2: 
Monkey 3: 

After round 7, the monkeys are holding items with these worry levels:
Monkey 0: 162, 12, 14, 64, 732, 17
Monkey 1: 148, 372, 55, 72
Monkey 2: 
Monkey 3: 

After round 8, the monkeys are holding items with these worry levels:
Monkey 0: 51, 126, 20, 26, 136
Monkey 1: 343, 26, 30, 1546, 36
Monkey 2: 
Monkey 3: 

After round 9, the monkeys are holding items with these worry levels:
Monkey 0: 116, 10, 12, 517, 14
Monkey 1: 108, 267, 43, 55, 288
Monkey 2: 
Monkey 3: 

After round 10, the monkeys are holding items with these worry levels:
Monkey 0: 91, 16, 20, 98
Monkey 1: 481, 245, 22, 26, 1092, 30
Monkey 2: 
Monkey 3: 

...

After round 15, the monkeys are holding items with these worry levels:
Monkey 0: 83, 44, 8, 184, 9, 20, 26, 102
Monkey 1: 110, 36
Monkey 2: 
Monkey 3: 

...

After round 20, the monkeys are holding items with these worry levels:
Monkey 0: 10, 12, 14, 26, 34
Monkey 1: 245, 93, 53, 199, 115
Monkey 2: 
Monkey 3: 
</code></pre>
<p>一度に全てのサルを追跡することは不可能です。
荷物を取り戻す望みを繋ぐには、<strong>最も活発な2匹</strong>のサルに集中する必要があります。
20ラウンドにわたってそれぞれのサルが<strong>荷物を検分した合計回数</strong>を数えます。</p>
<ul>
<li>サル0は荷物を101回検分しました</li>
<li>サル1は荷物を 95回検分しました</li>
<li>サル2は荷物を  7回検分しました</li>
<li>サル3は荷物を105回検分しました</li>
</ul>
<p>この例では、最も活発な2匹のサルが荷物を101回と105回検査しました。
この状況でのいたずら（<strong>monkey business</strong>）の度合いは、
これらを乗算することで<strong>10605</strong>と求めることができます。</p>
<p>サルが20ラウンドにわたって検分した荷物の数を数えて、どのサルを追いかけるべきかを特定します。
<strong>20ラウンドの物投げサルの悪ふざけの後、いたずらの度合いはいくつですか？</strong>
（原文 stuff-slinging simian shenanigans 物を投げるサルのいたずら）</p>
<!--
<details><summary>解説</summary><div>

実際のパズル入力でもサルはたかだか8匹なので、データはファイルから読み込みせずに手作業でプログラムに直す。
サルを表すデータ型を定義する。

```haskell
type WorryLevel = Int
data Monkey = Monkey
  { si  :: [WorryLevel]              -- Starting items
  , op  :: WorryLevel -> WorryLevel  -- Operation
  , tst :: WorryLevel                -- testの除数
  , t   :: Int                       -- 割り切れるときに投げる先
  , f   :: Int }                     -- 割り切れないときに投げる先

testData =
  [ Monkey [79, 98]         (19 *) 23 2 3
  , Monkey [54, 65, 75, 74] (6 +)  19 2 0
  , Monkey [79, 60, 97]     (^ 2)  13 1 3
  , Monkey [74]             (3 +)  17 0 1
  ]
```

激しく状態変化が起きるので、命令型言語が似合っている内容なのは否めない。
その近似として、IOモナドの中で、`IOArray` を用いて状況を表現する。
サルの持ち物リストは `Data.Sequence` で扱う。

```haskell
import Control.Monad
import Data.Array.IO
import qualified Data.Sequence as Q
import Data.Foldable
import Data.List

phase1 :: [Monkey] -> IO ()
phase1 ms =
  do
-- サルの持ち物リストの配列
    qv <- newListArray (0, nM) $ map (Q.fromList . si) ms :: IO (IOArray Int (Q.Seq WorryLevel))
-- 荷物を検分した回数カウンタ配列
    cv <- newArray (0, nM) 0 :: IO (IOArray Int Int)
-- 20ラウンド繰り返す
    forM_ [1..20] (\round -> do
-- それぞれのサルに順番を回す
      forM_ (zip [0..] ms) (\(i, m) -> do
-- 持ち物リストを読み出す
        q <- readArray qv i
-- これは全て投げるのでリストを空にする
        writeArray qv i Q.empty
-- 検分した回数を増やす
        readArray cv i >>= writeArray cv i . (Q.length q +)
-- それぞれの荷物について
        forM_ (toList q) (\item -> do
-- 心配度はサル固有の計算の後3で割る
            let item1 = div (op m item) 3
-- 割り切れるかどうかで送り先jを決める
            let j = if mod item1 (tst m) == 0 then t m else f m
-- そのサルの持ち物リストの末尾に追加する
            readArray qv j >>= writeArray qv j . (Q.|> item1)
            )
        )
-- (確認用) ラウンド終了後の持ち物リスト
      print ("round ", round)
      md <- getElems qv
      mapM_ print md
      )
-- いたずら度を算出
    cnts <- getElems cv
    print $ product $ take 2 $ sortBy (flip compare) cnts
  where
    nM = pred $ length ms
```

IOモナドですることで、デバッグ出力も容易にできた。

</div></details>
-->
<h1 id="パート2-39"><a class="header" href="#パート2-39">パート2</a></h1>
<p>あなたは荷物を取り返せないのではないかと心配になってきました。
実際、猿の検分が荷物に損傷を与えなかったというあなたの安堵は、
<strong>あなたの心配度が3で割られることをもはや引き起こさない</strong>ほど心配しています。</p>
<p>残念ながら、その安堵は、あなたの心配度が<strong>途方もないレベル</strong>に達するのを防いでいた全てでした。
<strong>心配度を管理できるようにする別の方法</strong>を見つける必要があるでしょう。</p>
<p>この相場で、あなたはサルたちに<strong>非常に長い間</strong>、どうにか<strong>10000ラウンド</strong>我慢することになります。</p>
<p>これらの新しい規則で、10000ラウンド後のいたずら度を把握できます。
上記と同じ例を使用します。</p>
<ul>
<li>第1ラウンドの後
<ul>
<li>サル0は荷物を2回検分しました</li>
<li>サル1は荷物を4回検分しました</li>
<li>サル2は荷物を3回検分しました</li>
<li>サル3は荷物を6回検分しました</li>
</ul>
</li>
<li>20ラウンド後
<ul>
<li>サル0は荷物を 99回検分しました</li>
<li>サル1は荷物を 97回検分しました</li>
<li>サル2は荷物を  8回検分しました</li>
<li>サル3は荷物を103回検分しました</li>
</ul>
</li>
<li>1000ラウンド後
<ul>
<li>サル0は荷物を5204回検分しました</li>
<li>サル1は荷物を4792回検分しました</li>
<li>サル2は荷物を 199回検分しました</li>
<li>サル3は荷物を5192回検分しました</li>
</ul>
</li>
</ul>
<pre><code>== After round 2000 ==
Monkey 0 inspected items 10419 times.
Monkey 1 inspected items 9577 times.
Monkey 2 inspected items 392 times.
Monkey 3 inspected items 10391 times.

== After round 3000 ==
Monkey 0 inspected items 15638 times.
Monkey 1 inspected items 14358 times.
Monkey 2 inspected items 587 times.
Monkey 3 inspected items 15593 times.

== After round 4000 ==
Monkey 0 inspected items 20858 times.
Monkey 1 inspected items 19138 times.
Monkey 2 inspected items 780 times.
Monkey 3 inspected items 20797 times.

== After round 5000 ==
Monkey 0 inspected items 26075 times.
Monkey 1 inspected items 23921 times.
Monkey 2 inspected items 974 times.
Monkey 3 inspected items 26000 times.

== After round 6000 ==
Monkey 0 inspected items 31294 times.
Monkey 1 inspected items 28702 times.
Monkey 2 inspected items 1165 times.
Monkey 3 inspected items 31204 times.

== After round 7000 ==
Monkey 0 inspected items 36508 times.
Monkey 1 inspected items 33488 times.
Monkey 2 inspected items 1360 times.
Monkey 3 inspected items 36400 times.

== After round 8000 ==
Monkey 0 inspected items 41728 times.
Monkey 1 inspected items 38268 times.
Monkey 2 inspected items 1553 times.
Monkey 3 inspected items 41606 times.

== After round 9000 ==
Monkey 0 inspected items 46945 times.
Monkey 1 inspected items 43051 times.
Monkey 2 inspected items 1746 times.
Monkey 3 inspected items 46807 times.

== After round 10000 ==
Monkey 0 inspected items 52166 times.
Monkey 1 inspected items 47830 times.
Monkey 2 inspected items 1938 times.
Monkey 3 inspected items 52013 times.
</code></pre>
<p>10000ラウンド後、最も活発な 2 匹のサルは52166回と52013回、荷物を検分しました。
これらを掛け合わせると、この状況でのいたずら度は<strong>2713310158</strong>です。</p>
<p>荷物が検分された後に、心配度が3で割られることはなくなりました。
心配度を管理できるように保つ別の方法を見つける必要があります。
パズル入力の初期状態からやり直すと、
<strong>10000ラウンド後のいたずら度はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

ラウンド回数を指定できるように `phase1` を改造して実行すると結果が例と食い違う。
`Int`がオーバーフローしている。
`type WorryLevel = Integer` とすると、1000回の結果がいつまでも求められない。
心配度をそのまま扱うと、途方もない桁数になってしまう。

全てのサルが、投げる先の判定を「特定の数で割り切れるかどうか」で行っていることに注目する。
つまり、それらの数で割り切れる値かどうかだけが正しく判断できればよい。

そこで心配度を、
サル全員の割る数の最小公倍数（もしくは全ての掛けた数）を法にしたモジュロ整数
で扱うように修正する。`WorryLevel`は`Int`のままで構わない。

コメントを付けたところだけが `phase1` からの変更部分。

```haskell
phase2 :: [Monkey] -> Int -> IO ()
phase2 ms times =
  do
    qv <- newListArray (0, nM) $ map (Q.fromList . si) ms :: IO (IOArray Int (Q.Seq WorryLevel))
    cv <- newArray (0, nM) 0 :: IO (IOArray Int Int)
-- ラウンド回数は引数で指定
    forM_ [1..times] (\round -> do
      forM_ (zip [0..] ms) (\(i, m) -> do
        q <- readArray qv i
        readArray cv i >>= writeArray cv i . (Q.length q +)
        writeArray qv i Q.empty
        forM_ (toList q) (\item -> do
-- 心配度は3で割らないが、モジュロをとる
            let item1 = mod (op m item) base
            let j = if mod item1 (tst m) == 0 then t m else f m
            readArray qv j >>= writeArray qv j . (Q.|> item1)
            )
        )
      )
    cnts <- getElems cv
    print cnts
    print $ product $ take 2 $ sortBy (flip compare) cnts
  where
    nM = pred $ length ms
-- 法にするための最小公倍数を求める
    base = foldl1 lcm $ map tst ms
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><!-- 五時之丞 いいなそれ。 如之丈 なんだが。-->
<h1 id="12-日目-山登りアルゴリズム"><a class="header" href="#12-日目-山登りアルゴリズム">12 日目: 山登りアルゴリズム</a></h1>
<p>あなたは携帯機器を使用して小人と連絡を取ろうとしましたが、
あなたが辿っている川は位置が低すぎて適切な信号を受信できませんでした。</p>
<p>機器に周辺領域の高さ地図を要求します（パズル入力）。
高さ地図は、グリッドに分割された上空から見た周辺地域を示しています。
グリッドの各正方形の標高は、1 つの小文字で示されます。
ここで <code>a</code> は最低の標高、<code>b</code> は次に低い標高、というように最高の標高 <code>z</code> まで続きます。</p>
<p>高さ地図には他に、現在の位置 (<code>S</code>) と最良の信号を受信できる位置 (<code>E</code>) の印も含まれています。
現在の位置 (<code>S</code>) は標高 <code>a</code> を持ち、
最高の信号を受信できるはずの場所 (<code>E</code>) は標高 <code>z</code> を持ちます。</p>
<p>あなたは <code>E</code> に到達したいのですが、エネルギーを節約するために、
できるだけ<strong>少ないステップ数で</strong>到達する必要があります。
各ステップでは、ちょうど1マス上下左右に移動できます。
登山用具を取り出さなくても済むように、目的地のマスの標高は、
現在のマスの標高より<strong>たかだか1だけ高くなる</strong>ならば許されます。
つまり、現在の標高が <code>m</code> の場合、標高 <code>n</code> に進むことはできますが、標高 <code>o</code> に進むことはできません。
（これは、目的のマスの標高が現在のマスの標高よりもずっと低くなる方は構わないことも意味しています。）</p>
<p>例えば：</p>
<pre><code>Sabqponm
abcryxxl
accszExk
acctuvwj
abdefghi
</code></pre>
<p>ここでは、左上隅から始めます。あなたの目的地は真ん中近くです。
下または右に移動することから始めることもできますが、
最終的には一番下の <code>e</code> に向かう必要があります。
そこから、螺旋状に進むことで目的地へ行くことができます。</p>
<pre><code>v..v&lt;&lt;&lt;&lt;
&gt;v.vv&lt;&lt;^
.&gt;vv&gt;E^^
..v&gt;&gt;&gt;^^
..&gt;&gt;&gt;&gt;&gt;^
</code></pre>
<p>上の図における記号は、上 (<code>^</code>)、下 (<code>v</code>)、左 (<code>&lt;</code>)、右 (<code>&gt;</code>)に移動してそのマスから出る経路であることを示します。
最良の信号を受信できるはずの場所はここでも <code>E</code> で示され、<code>.</code> は訪問されないマスの印です。</p>
<p>この経路は、31ステップで目的地に到達します。これは可能な限り少ない数です。</p>
<p><strong>現在の位置から最適な信号を受信できる場所に移動するのに必要な最小のステップ数はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

幅優先探索で、出発地点から到達できたマスに到達済みの印を書き込んでいく。
目的地のマスが書き込まれたところで繰り返しを終了する。
これをするためには、到達済みフラグの、書き換え可能な二次元配列が必要。
さらに、標高地図もランダムアクセスしたいので二次元配列に保存する。

地図は行ごとの文字列のリストとして読み込む。

```haskell
phase1 fn = do
  ls <- lines <$> readFile fn
  ...
```

ここから、`S`の位置と`E`の位置を見つけておく。

```haskell
phase1 fn = do
  ...
  let [spos] = locate 'S' ls
  let [epos] = locate 'E' ls
  ...

locate v xss = [(i,j) | (i,xs) <- zip [1..] xss, (j,x) <- zip [1..] xs, v == x]
```

標高地図の二次元配列を作る際は、`S`と`E`はその標高に置き換える。

```haskell
import Data.Array.Unboxed

phase1 fn = do
  ...
  let w = length (head ls)
  let h = length ls
  let a2z = listArray ((1,1),(h,w)) $ map se2az $ concat ls :: UArray (Int,Int) Char
  ...

se2az 'S' = 'a'
se2az 'E' = 'z'
se2az  c  =  c
```

フラグの二次元配列の初期値は到達済みを `True` とする。

```haskell
import Data.Array.IO

phase1 fn = do
  ...
  da <- newArray ((1,1),(h,w)) False :: IO (IOUArray (Int,Int) Bool)
  ...
```

これらを利用して、幅優先探索を行う。
未処理の地点のリストをひとつずつ消費し、そこが到達済みなら捨てる。
未到達なら、到達済みとチェックし、その周辺4地点の標高が+1までに収まっていれば、
次に調査するべき地点のリストに加える。
処理する地点のリストが尽きたら、
距離を1増やして、次に調査するべき地点のリストを処理する地点のリストに持ち替えて繰り返す。
目的地の距離が判明した時点で終了する。

```haskell
import Data.Ix

phase1 fn = do
  ...
  loopWrap a2z da epos spos >>= print

loopWrap :: UArray (Int, Int) Char -> IOUArray (Int,Int) Bool -> (Int,Int) -> (Int,Int) -> IO Int
loopWrap a2z da epos spos = loop 0 [spos] []
  where
    bnds = bounds a2z
    loop :: Int -> [(Int,Int)] -> [(Int,Int)] -> IO Int
    loop _ [] [] = error "cannot reach to E"
    loop cnt [] qs = loop (succ cnt) qs []
    loop cnt (p:ps) qs =
      do
        b <- readArray da p
        if b then loop cnt ps qs else do
          writeArray da p True
          if p == epos then return cnt else do
            let h1 = succ $ a2z ! p
            qs1 <- foldM (\qs d -> do
              let q = add p d
              if not (inRange bnds q) || h1 < a2z ! q then return qs else do
                d <- readArray da q
                return $ if d then qs else q:qs
              ) qs deltas
            loop cnt ps qs1
```

</div></details>
-->
<h1 id="パート2-40"><a class="header" href="#パート2-40">パート2</a></h1>
<p>丘を上っていくとき、小人がここをハイキングコースにしようとしているのではないかとあなたは訝しみました。
ただし、この出発地点はあまり風光明媚ではありません。
おそらく、より良い出発点を見つけることができるでしょう。</p>
<p>ハイキング中の運動を最大限にするために、コースはできるだけ低い標高、つまり <code>a</code> から始める必要があります。
目的地はやはり<code>E</code> と印されたマスです。
ただし、コースはやはり最も近道である必要があります。
つまり、目的地に到達するためのステップ数は最小で済ませてください。
したがって、標高 <code>a</code> である任意のマスから、<code>E</code> と印されたマスまでの最短経路を見つける必要があります。</p>
<p>上記の例をもう一度考えてみましょう。</p>
<pre><code>Sabqponm
abcryxxl
accszExk
acctuvwj
abdefghi
</code></pre>
<p>ここで、開始位置には6つの選択肢があります。
（<code>a</code> と印された5つと、高度 <code>a</code> にあると見なされる <code>S</code> と印されたマス）
左下のマスから始めると、最も早くゴールに到達できます。</p>
<pre><code>...v&lt;&lt;&lt;&lt;
...vv&lt;&lt;^
...v&gt;E^^
.&gt;v&gt;&gt;&gt;^^
&gt;^&gt;&gt;&gt;&gt;&gt;^
</code></pre>
<p>この経路は、可能な限り少ない手順である<strong>29</strong>ステップで目的地に到達します。</p>
<p><strong>標高 <code>a</code> の任意のマスから出発して、最良の信号を受信できる場所に移動するのに必要な最小ステップ数はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

幅優先探索の動作を少し修正する。

- `E`の地点から出発する。
- 移動できる地点の標高の判断が逆になる。
- 新たに到達した地点の標高が初めて `a` であったとき、その距離が答えである。

```haskell
phase2 fn = do
  ...
  loop2Wrap a2z da epos >>= print

loop2Wrap :: UArray (Int, Int) Char -> IOUArray (Int,Int) Bool -> (Int,Int) -> IO Int
loop2Wrap a2z da epos = loop 0 [epos] []
  where
    bnds = bounds a2z
    loop :: Int -> [(Int,Int)] -> [(Int,Int)] -> IO Int
    loop _ [] [] = error "cannot reach to height 'a'"
    loop cnt [] qs = loop (succ cnt) qs []
    loop cnt (p:ps) qs =
      do
        b <- readArray da p
        if b then loop cnt ps qs else do
          writeArray da p True
          if a2z ! p == 'a' then return cnt else do
            let h1 = pred $ a2z ! p
            qs1 <- foldM (\qs d -> do
              let q = add p d
              if not (inRange bnds q) || h1 > a2z ! q then return qs else do
                d <- readArray da q
                return $ if d then qs else q:qs
              ) qs deltas
            loop cnt ps qs1
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="13日目-救難信号"><a class="header" href="#13日目-救難信号">13日目: 救難信号</a></h1>
<p>丘を登り、再び小人との接触を試みます。
ところが、代わりに、予期していなかった信号を受信します：<strong>遭難信号</strong>です。</p>
<p>携帯機器はまだ正常に動作していないようです。
遭難信号からのパケットが<strong>間違った順序</strong>でデコードされました。
メッセージを復号するには、受信したパケットのリスト（パズルの入力）を並べ替える必要があります。</p>
<p>リストはパケットの対で構成されています。対は空白行で区切られます。
<strong>正しい順序になっているパケットの対の個数</strong>を特定する必要があります。</p>
<p>例えば：</p>
<pre><code>[1,1,3,1,1]
[1,1,5,1,1]

[[1],[2,3,4]]
[[1],4]

[9]
[[8,7,6]]

[[4,4],4,4]
[[4,4],4,4,4]

[7,7,7,7]
[7,7,7]

[]
[3]

[[[]]]
[[]]

[1,[2,[3,[4,[5,6,7]]]],8,9]
[1,[2,[3,[4,[5,6,0]]]],8,9]
</code></pre>
<p>パケットデータは、リストと整数で構成されます。
各リストは <code>[</code> で始まり <code>]</code> で終わり、0個以上のカンマ区切りの値（整数または別のリスト）を含みます。
各パケットは常にリストであり、一行にひとつが示されています。</p>
<p>2つの値を比較するとき、ひとつめの値を<strong>左</strong>と呼び、ふたつめの値を<strong>右</strong>と呼びます。
そして：</p>
<ul>
<li><strong>両方の値が整数</strong>である場合、<strong>小さい方の整数</strong>が先にくる必要があります。
左の整数が右の整数より小さい場合、入力は正しい順序です。
左の整数が右の整数より大きい場合、入力は正しい順序ではありません。
さもなくば、入力は同じ整数です。入力の次の部分のチェックを続けます。</li>
<li><strong>両方の値がリスト</strong>である場合は、
各リストの最初の値を比較し、次に2番目の値を比較し、以下同様に続けます。
左のリストが先に要素を使い果たした場合、入力は正しい順序です。
右のリストが先に要素を使い果たした場合、入力は正しい順序ではありません。
リストが同じ長さで、比較によって順序が決定されない場合は、入力の次の部分のチェックを続けます。</li>
<li>いずれか<strong>一方の値だけが整数</strong>である場合は、
その整数を唯一の値として含むリストに変換してから、比較を再試行します。
例えば、<code>[0,0,0]</code> と <code>2</code> を比較する場合、右の値を <code>[2]</code> （<code>2</code>を持つリスト）に変換します。
比較の結果は代わりに <code>[0,0,0]</code> と <code>[2]</code> を比較することで得られます。</li>
</ul>
<p>これらの規則を用いて、例のどの対が正しい順序であるかを判断できます。</p>
<pre><code>== Pair 1 ==
- Compare [1,1,3,1,1] vs [1,1,5,1,1]
  - Compare 1 vs 1
  - Compare 1 vs 1
  - Compare 3 vs 5
    - Left side is smaller, so inputs are in the right order
訳：
- 比較 [1,1,3,1,1] vs [1,1,5,1,1]
  - 比較 1 vs 1
  - 比較 1 vs 1
  - 比較 3 vs 5
    - 左が小さいので、入力は正しい順序

== Pair 2 ==
- Compare [[1],[2,3,4]] vs [[1],4]
  - Compare [1] vs [1]
    - Compare 1 vs 1
  - Compare [2,3,4] vs 4
    - Mixed types; convert right to [4] and retry comparison
      種類が混ざっているので、右を [4] に変換して再比較
    - Compare [2,3,4] vs [4]
      - Compare 2 vs 4
        - Left side is smaller, so inputs are in the right order
          左が小さいので、入力は正しい順序

== Pair 3 ==
- Compare [9] vs [[8,7,6]]
  - Compare 9 vs [8,7,6]
    - Mixed types; convert left to [9] and retry comparison
    - Compare [9] vs [8,7,6]
      - Compare 9 vs 8
        - Right side is smaller, so inputs are not in the right order

== Pair 4 ==
- Compare [[4,4],4,4] vs [[4,4],4,4,4]
  - Compare [4,4] vs [4,4]
    - Compare 4 vs 4
    - Compare 4 vs 4
  - Compare 4 vs 4
  - Compare 4 vs 4
  - Left side ran out of items, so inputs are in the right order
    左の要素が尽きたので、入力は正しい順序

== Pair 5 ==
- Compare [7,7,7,7] vs [7,7,7]
  - Compare 7 vs 7
  - Compare 7 vs 7
  - Compare 7 vs 7
  - Right side ran out of items, so inputs are not in the right order

== Pair 6 ==
- Compare [] vs [3]
  - Left side ran out of items, so inputs are in the right order

== Pair 7 ==
- Compare [[[]]] vs [[]]
  - Compare [[]] vs []
    - Right side ran out of items, so inputs are not in the right order

== Pair 8 ==
- Compare [1,[2,[3,[4,[5,6,7]]]],8,9] vs [1,[2,[3,[4,[5,6,0]]]],8,9]
  - Compare 1 vs 1
  - Compare [2,[3,[4,[5,6,7]]]] vs [2,[3,[4,[5,6,0]]]]
    - Compare 2 vs 2
    - Compare [3,[4,[5,6,7]]] vs [3,[4,[5,6,0]]]
      - Compare 3 vs 3
      - Compare [4,[5,6,7]] vs [4,[5,6,0]]
        - Compare 4 vs 4
        - Compare [5,6,7] vs [5,6,0]
          - Compare 5 vs 5
          - Compare 6 vs 6
          - Compare 7 vs 0
            - Right side is smaller, so inputs are not in the right order
</code></pre>
<p><strong>正しい順序になっている</strong>対の番号は何ですか？
（最初の対の番号は1、2番目の対の番号は2というように続きます。）
上記の例では、正しい順序の対は1, 2, 4, 6 です。
これらの番号の合計は<strong>13</strong>です。</p>
<p>どのパケットの対が正しい順序になっているかを判定します。
<strong>それらの対の番号の合計はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

このパケット、すなわち何段でも入れ子にできる整数のリストを表すデータ型を定義する。
順序をもつので `Ord` 型クラスに入れるために、`Eq` は自動導出させる。
整数とリストの比較が独特なので、`Ord` は自動導出できない。
また、見た目どおりに表示するように `Show` に入れる（オプション）。

```haskell
data Packet = PInt Int | PList [Packet] deriving Eq

instance Ord Packet where
  compare (PInt x) (PInt y) = compare x y
  compare (PList xs) (PList ys) = compare xs ys
  compare x@(PInt _) (PList ys) = compare [x] ys
  compare (PList xs) y@(PInt _) = compare xs [y]

instance Show Packet where
  showsPrec p (PInt n) = showsPrec p n
  showsPrec p (PList ps) = showChar '[' . foldr (.) (showChar ']') (intersperse (showChar ',') (map shows ps))
```

パーサは `Text.Parsec` を用いて手早く作る。

```haskell
import Text.Parsec
import Text.Parsec.String

pPacket :: Parser Packet
pPacket =
  PInt . read <$> many1 digit
  <|>
  PList <$> between (char '[') (char ']') (Text.Parsec.sepBy parsePacket (char ','))
```

あとは計算するだけ。下から上に読むワンライナー。

```haskell
import Data.List.Split (chunksOf)

phase1a fn =
  print . sum . map fst .                        -- その順序を取り出し、合計して、出力
  filter (\(i,[l,r]) -> l < r) .                 -- 正しい順序のものだけ取り出し
  zip [1..] .                                    -- 番号を付け
  chunksOf 2 .                                   -- 対ごとにリストに切り分け
  map (fromRight undefined . parse pPacket "") . -- それぞれパーサにかけて、Rightを外し
  filter (not . null) .                          -- 空行を飛ばし
  lines =<<                                      -- 行ごとに分け
  readFile fn                                    -- ファイルを読み込み
```

</div></details>
-->
<h1 id="パート2-41"><a class="header" href="#パート2-41">パート2</a></h1>
<p>あとは、<strong>全ての</strong>パケットを正しい順序に並べるだけです。
受信したパケットのリストの空白行は無視してください。</p>
<p>遭難信号プロトコルは、2つの追加の<strong>分割パケット</strong>（下記）を含めることも必要です。</p>
<pre><code>[[2]]
[[6]]
</code></pre>
<p>前と同じ規則を使用して、全てのパケット ー
受信したパケットのリストにあるパケットと2つの分割パケット ー
を正しい順序に揃えます。</p>
<p>上記の例では、パケットを正しい順序に並べた結果は次のようになります。</p>
<pre><code>[]
[[]]
[[[]]]
[1,1,3,1,1]
[1,1,5,1,1]
[[1],[2,3,4]]
[1,[2,[3,[4,[5,6,0]]]],8,9]
[1,[2,[3,[4,[5,6,7]]]],8,9]
[[1],4]
[[2]]                       &lt;---
[3]
[[4,4],4,4]
[[4,4],4,4,4]
[[6]]                       &lt;---
[7,7,7]
[7,7,7,7]
[[8,7,6]]
[9]
</code></pre>
<p>その後、分割パケットを見つけます。
この救難信号の<strong>復号鍵</strong>を見つけるには、2つの分割パケットの位置を求め、それらを乗算する必要があります。
（最初のパケットは位置1、2番目のパケットは位置2、と続きます。）
この例では、分割パケットは<strong>10番目</strong>と<strong>14番目</strong>であるため、復号鍵は<strong>140</strong>です。</p>
<p>全てのパケットを正しい順序に揃えてください。
<strong>遭難信号の復号鍵はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

パケット列に直すところまでは上と同じで、必要な計算を続ける。

```haskell
import Data.List

phase2 fn =
  do
    packets <-map (fromRight undefined . parse pPacket "") . filter (not . null) . lines <$> readFile fn
    let ps = sort $ div1 : div2 : packets
    let Just l1 = elemIndex div1 ps
    let Just l2 = elemIndex div2 ps
    print $ succ l1 * succ l2

Right div1 = parse parsePacket "" "[[2]]"
Right div2 = parse parsePacket "" "[[6]]"
```

よく考えてみると、\\(O(\log N)\\) かけてソートをする必要すらなくて、
分割パケットよりも小さいパケットの個数を2度数えるだけで、
\\(O(N)\\)で答えは算出できる。

```haskell
import Data.List

phase2 fn =
  do
    packets <-map (fromRight undefined . parse pPacket "") . filter (not . null) . lines <$> readFile fn
    let ps = div1 : div2 : packets
    let l1 = length $ filter (div1 >=) ps
    let l2 = length $ filter (div2 >=) ps
    print $ l1 * l2

Right div1 = parse parsePacket "" "[[2]]"
Right div2 = parse parsePacket "" "[[6]]"
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="14-日目-降り積もる砂"><a class="header" href="#14-日目-降り積もる砂">14 日目: 降り積もる砂</a></h1>
<p>（原題：Regolith Reservoir）</p>
<p>遭難信号があなたを巨大な滝へと導きます！
実際、ちょっと待ってください。信号は滝そのものから来ているように見えますが、そんなはずはありません。
ただし、滝の<strong>後ろ</strong>に続く小道に気付きます。</p>
<p>訂正：救難信号があなたを巨大な滝の後ろに導きます！
ここには大規模な洞窟系があるようで、信号は間違いなく奥へと誘っています。</p>
<p>地下深くへと進み始めると、一瞬地面が揺れるのを感じます。
砂が洞窟に流れ込み始めます！
砂の行き先を即座に把握しないと、あっという間に閉じ込められてしまうでしょう。</p>
<p>幸いなことに、落下する物質の経路を分析することに慣れている([2018/17])経験がここで役に立ちます。
あなたの頭上に広がっている洞窟の、垂直な2次元断面をスキャンすると（パズル入力）、
ほとんどが<strong>空洞</strong>で、<strong>岩</strong>でできた構造物があることがわかりました。</p>
<p>スキャンは、硬い岩でできた構造の経路をなぞり、経路の形状を形成するx,y座標列を報告します。
ここで<code>x</code>は右方向の距離を表し、<code>y</code>は下方向の距離を表します。
スキャンにおいて、ひとつの経路が1行のテキストとして示されています。
各経路の最初の座標の後、各座標は、前の座標から引かれる水平または垂直の直線の終点を示します。
例を示します：</p>
<pre><code>498,4 -&gt; 498,6 -&gt; 496,6
503,4 -&gt; 502,4 -&gt; 502,9 -&gt; 494,9
</code></pre>
<p>このスキャンは、岩の経路が2つあることを意味します。
最初の経路は2つの直線で構成され、2番目の経路は3つの直線で構成されます。
（具体的には、最初の経路は498,4から498,6の岩の列と、498,6から496,6の別の岩の列で構成されます。）</p>
<p>座標500,0から砂が洞窟に流れ込んでいます。</p>
<p>岩を<code>#</code>、空気を<code>.</code>、砂の噴出口を<code>+</code>で描くと、次のようになります。</p>
<pre><code>
  4     5  5
  9     0  0
  4     0  3
0 ......+...
1 ..........
2 ..........
3 ..........
4 ....#...##
5 ....#...#.
6 ..###...#.
7 ........#.
8 ........#.
9 #########.
</code></pre>
<p>砂は<strong>一度に1単位ずつ</strong>生成され、次の砂の単位は、前の砂の単位が<strong>停止する</strong>まで生成されません。
1単位の砂は、あなたのスキャンにおいて1マス分の空洞を埋めるのに十分な大きさです。</p>
<p>1単位の砂は、可能であれば常に<strong>1段下に</strong>落ちます。
すぐ下のマスが（岩や砂によって）塞がれている場合、その1単位の砂は代わりに<strong>1つ左斜め下</strong>に移動しようとします。
そのマスがふさがっている場合、砂は代わりに<strong>1つ右斜め下</strong>に移動しようとします。
砂は可能な限り動き続け、各ステップで下に移動しようとし、できなければ左下、次に右下に移動しようとします。
3つの可能な目的地が全て塞がっている場合、砂は<strong>停止</strong>し、移動しなくなります。
その時点で、次の砂の単位が噴出孔から生成されます。</p>
<p>従って、静止した砂を<code>o</code>と描画すると、最初の砂の単位は単にまっすぐに落ちてから停止します。</p>
<pre><code>......+...
..........
..........
..........
....#...##
....#...#.
..###...#.
........#.
......o.#.
#########.
</code></pre>
<p>次に、2番目の砂の単位がまっすぐ下に落下し、最初の砂の上に着地してから、その左に止まります。</p>
<pre><code>......+...
..........
..........
..........
....#...##
....#...#.
..###...#.
........#.
.....oo.#.
#########.
</code></pre>
<p>合計5単位の砂が停止した後、次のパターンが形成されます。</p>
<pre><code>......+...
..........
..........
..........
....#...##
....#...#.
..###...#.
......o.#.
....oooo#.
#########.
</code></pre>
<p>合計 22 単位の砂の後:</p>
<pre><code>......+...
..........
......o...
.....ooo..
....#ooo##
....#ooo#.
..###ooo#.
....oooo#.
...ooooo#.
#########.
</code></pre>
<p>最後に、砂はもう2単位だけが静止できます。</p>
<pre><code>......+...
..........
......o...
.....ooo..
....#ooo##
...o#ooo#.
..###ooo#.
....oooo#.
.o.ooooo#.
#########.
</code></pre>
<p>上に示した砂<strong>24</strong>単位全てが静止すると、それ以降の全ての砂は底から流れ出し、無限の虚無に落ちます。
興味のある人のために、新しい砂が永遠に落ちる前にたどる道を<code>~</code>で以下に示します：</p>
<pre><code>.......+...
.......~...
......~o...
.....~ooo..
....~#ooo##
...~o#ooo#.
..~###ooo#.
..~..oooo#.
.~o.ooooo#.
~#########.
~..........
~..........
~..........
</code></pre>
<p>あなたのスキャン結果を使用して、落下する砂をシミュレーションします。
<strong>砂が下の深淵に流れ込み始める前に、何単位の砂が静止しますか？</strong></p>
<!--
<details><summary>解説</summary><div>

最後の例でわかるように、構造より1マス左右に広げた範囲をシミュレーションして、
奈落に落ちた砂を観測したところで止めればよい。
停止した砂を書き込んでマップが変更されていくので、命令型の二次元配列が適している。

</div></details>
-->
<h1 id="パート2-42"><a class="header" href="#パート2-42">パート2</a></h1>
<p>スキャンを読み間違えたことに気付きます。
スキャンの底に無限の空白はありません ー そこには床があり、あなたはその上に立っています！</p>
<p>床をスキャンする時間がないため、床は無限の水平線であり、
その<code>y</code>座標はあなたのスキャン内の<strong>最大の<code>y</code>座標に2を加えた</strong>ものであると想定します。</p>
<p>上の例では、最大の<code>y</code>座標は<code>9</code>であるため、床は<code>y=11</code>にあります。
（これは、スキャンに<code>-infinity,11 -&gt; infinity,11</code>という追加の岩の経路が含まれているようなものです。）
床を追加すると、上の例は次のようになります。</p>
<pre><code>        ...........+........
        ....................
        ....................
        ....................
        .........#...##.....
        .........#...#......
        .......###...#......
        .............#......
        .............#......
        .....#########......
        ....................
&lt;-- etc #################### etc --&gt;
</code></pre>
<p>安全に立っていられる場所を見つけるには、砂の単位が500,0で停止することで
噴出口を完全に塞いで、洞窟への砂の流入を止めるまでの砂の落下をシミュレーションする必要があります。
上の例では、93単位の砂が静止した後、状況は最終的に次のようになります。</p>
<pre><code>............o............
...........ooo...........
..........ooooo..........
.........ooooooo.........
........oo#ooo##o........
.......ooo#ooo#ooo.......
......oo###ooo#oooo......
.....oooo.oooo#ooooo.....
....oooooooooo#oooooo....
...ooo#########ooooooo...
..ooooo.......ooooooooo..
#########################
</code></pre>
<p>あなたのスキャンを使用して、砂の噴出口が塞がれるまで落下する砂をシミュレーションします。
<strong>何単位の砂が静止しますか？</strong></p>
<!--
<details><summary>解説</summary><div>

やはり図からわかるように、噴出口から斜めに進んだ位置までしか砂は移動できないので、
床までの高さ分、`x=500` から±した範囲をシミュレーションすればよい。

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-日目-ビーコン除外領域"><a class="header" href="#15-日目-ビーコン除外領域">15 日目: ビーコン除外領域</a></h1>
<p>あなたが遭難信号に導かれて地下トンネルの広大な迷宮に足を踏み入れたとき、再び地面が鳴り響くのを感じます。
それらを全て調べる時間はありませんが、調べる必要もありません。
あなたのリュックには、
元は行方不明になった小人を見つけるために作られたらしい、
散開させることができる<strong>センサー</strong>のセットが入っています。</p>
<p>センサーはそれほど強力ではありませんが、問題ありません。
あなたの携帯機器は、遭難信号の発信源に十分に、
センサーシステムが有効な距離まで近づいていることを示しています。
リュックから緊急センサーシステムを取り出し、上部にある大きなボタンを押すと、
センサー群がトンネル内各所へ高速に展開されます。</p>
<p>センサーは、適切な読み取りができると思われる地点を見つけると、
固い表面に自身を固定し、最も近い信号源<strong>ビーコン</strong>の監視を開始します。
センサーとビーコンは常に整数座標に存在します。
各センサーは自分の位置を認識しており、<strong>ビーコンの位置を正確に特定</strong>できます。
ただし、センサーは、マンハッタン距離[pedia]で測って
<strong>センサーに最も近い</strong>ビーコンひとつにしかロックオンできません。
（2つのビーコンからセンサーまでの距離が同じになることはありません。）</p>
<p>センサーが自身の位置と最も近いビーコンを報告するのにそれほど時間はかかりません。
（パズルの入力）
例えば：</p>
<pre><code>Sensor at x=2, y=18: closest beacon is at x=-2, y=15
Sensor at x=9, y=16: closest beacon is at x=10, y=16
Sensor at x=13, y=2: closest beacon is at x=15, y=3
Sensor at x=12, y=14: closest beacon is at x=10, y=16
Sensor at x=10, y=20: closest beacon is at x=10, y=16
Sensor at x=14, y=17: closest beacon is at x=10, y=16
Sensor at x=8, y=7: closest beacon is at x=2, y=10
Sensor at x=2, y=0: closest beacon is at x=2, y=10
Sensor at x=0, y=11: closest beacon is at x=2, y=10
Sensor at x=20, y=14: closest beacon is at x=25, y=17
Sensor at x=17, y=20: closest beacon is at x=21, y=22
Sensor at x=16, y=7: closest beacon is at x=15, y=3
Sensor at x=14, y=3: closest beacon is at x=15, y=3
Sensor at x=20, y=1: closest beacon is at x=15, y=3
</code></pre>
<p>さて、位置<code>2,18</code>のセンサーを考えてみましょう。
それに最も近いビーコンは<code>-2,15</code>にあります。
<code>9,16</code>にあるのセンサーに対して、それに最も近いビーコンは<code>10,16</code>にあります。</p>
<p>センサーを<code>S</code>、ビーコンを<code>B</code>として描画すると、
上記のセンサーとビーコンの配置は次のようになります。</p>
<pre><code>               1    1    2    2
     0    5    0    5    0    5
 0 ....S.......................
 1 ......................S.....
 2 ...............S............
 3 ................SB..........
 4 ............................
 5 ............................
 6 ............................
 7 ..........S.......S.........
 8 ............................
 9 ............................
10 ....B.......................
11 ..S.........................
12 ............................
13 ............................
14 ..............S.......S.....
15 B...........................
16 ...........SB...............
17 ................S..........B
18 ....S.......................
19 ............................
20 ............S......S........
21 ............................
22 .......................B....
</code></pre>
<p>ただし、これは必ずしもエリア内の全てのビーコンの包括的な地図ではありません。
各センサーは最も近いビーコンのみを識別するため、
センサーがビーコンを検出したとき、そのセンサーからその距離またはより近い位置に他のビーコンがないことがわかります。
たまたま、どのセンサーに対しても最も近いビーコンではないビーコンがまだ存在する可能性があります。
<code>8,7</code> のセンサーを考えてみましょう：</p>
<pre><code>               1    1    2    2
     0    5    0    5    0    5
-2 ..........#.................
-1 .........###................
 0 ....S...#####...............
 1 .......#######........S.....
 2 ......#########S............
 3 .....###########SB..........
 4 ....#############...........
 5 ...###############..........
 6 ..#################.........
 7 .#########S#######S#........
 8 ..#################.........
 9 ...###############..........
10 ....B############...........
11 ..S..###########............
12 ......#########.............
13 .......#######..............
14 ........#####.S.......S.....
15 B........###................
16 ..........#SB...............
17 ................S..........B
18 ....S.......................
19 ............................
20 ............S......S........
21 ............................
22 .......................B....
</code></pre>
<p>このセンサーに最も近いビーコンは <code>2,10</code> にあるため、
その距離またはより近い位置（<code>#</code> とマークされた位置）にはビーコンがないことがわかります。</p>
<p>検出されたビーコンはいずれも遭難信号を生成していないようです。
そのため、遭難ビーコンがどこに<strong>ない</strong>かを調べる必要があります。
ここでは、話を単純にするために、
ある1列の中で、ビーコンが存在する可能性のない位置を数えることにします。</p>
<p>そこで、上記の例のようなビーコンとセンサーの配置があり、
<code>y=10</code> の行について、ビーコンが存在する可能性のない位置を数えたいとします。
その行の近くにあるすべてのセンサーが覆っている領域は次のようになります。</p>
<pre><code>                 1    1    2    2
       0    5    0    5    0    5
 9 ...#########################...
10 ..####B######################..
11 .###S#############.###########.
</code></pre>
<p>この例では、<code>y=10</code> の行に、ビーコンが存在できない位置が <code>26</code> 箇所あります。
先ほどあなたが発進させたセンサーからの報告を参照してください。
<strong><code>y=2000000</code> の行で、ビーコンが存在しえない位置はいくつありますか？</strong></p>
<!--
<details><summary>解説</summary><div>

```haskell
```

</div></details>
-->
<h1 id="パート2-43"><a class="header" href="#パート2-43">パート2</a></h1>
<p>あなたの携帯機器は、付近のビーコンから遭難信号が発信されていることを示しています。
どのセンサーも遭難ビーコンを検出していませんが、
遭難ビーコンの<code>x,y</code>座標はどちらも<code>0</code>より小さくなく<code>4000000</code>より大きくないことは確実です。</p>
<p>遭難ビーコンの信号を抽出するには、<strong>同調周波数</strong>を決定する必要があります。
これは、その <code>x</code> 座標に <code>4000000</code> を掛けてから、その <code>y</code> 座標を加算することによって得られます。</p>
<p>上記の例では、探索空間はもっと小さくなっています。<code>x</code>と<code>y</code>の座標はどちらも最大<code>20</code>です。
この縮小された検索領域では、ビーコンが存在しうる位置は <code>x=14, y=11</code> の一か所だけです。
この遭難ビーコンの同調周波数は <code>56000011</code> です。</p>
<p>遭難ビーコンの存在可能な唯一の位置を見つけてください。
<strong>その同調周波数はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

```haskell
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="16-日目-好火山性ゾウ目"><a class="header" href="#16-日目-好火山性ゾウ目">16 日目: 好火山性ゾウ目</a></h1>
<p>（原題 Proboscidea Volcanium
好熱好酸性古細菌の学名 Thermoplasma volcanium に Proboscidea 長鼻目、別名ゾウ目 をはめ込んで
学名っぽくしたゾウ語と思われる。）</p>
<p>センサーによりあなたを遭難信号の発信源に到達しました。
それは、小人があなたに渡したものと同じような、また別の携帯機器です。
ただし、周りに小人はいません。
代わりに、機器を象が取り囲んでいます！
彼らはこのトンネルの中で迷子になり、
その中の1頭が遭難信号をオンにする方法を見つけたに違いありません。</p>
<p>地面が再びうなります。今回はさらに激しいです。ここは一体、何の洞窟なのでしょう？
携帯機器で洞窟をスキャンします。大部分が火成岩、いくらかの火山灰、高圧のガス、マグマで構成されています…
これは単なる洞窟ではありません、火山です！</p>
<p>すぐに、ゾウをここから連れ出してください。
あなたの装置は、火山が噴火するまであと<strong>30分</strong>と推定しているため、来た道を戻る時間はありません。</p>
<p>他の選択肢を探すために洞窟をスキャンした結果、パイプと圧力開放<strong>バルブ</strong>のネットワークを発見しました。
どうしてそんなシステムが火山にあるのかはわかりませんが、文句を言っている時間はありません。
機器は、各バルブを開放した場合の<strong>流量</strong>（1分あたりの圧力）と、
バルブ間を移動するために使用できるトンネルに関する報告（パズル入力）を生成します。</p>
<p>あなたとゾウが現在立っている空間にも、<code>AA</code> とラベル付けられたバルブがあります。
1つのバルブを開くのに1分、あるバルブから別のバルブへのトンネルをたどるのに1分かかると見積もりました。
あなたが開放できる最大の圧力はどれだけでしょう？</p>
<p>たとえば、次のスキャン出力があるとします。</p>
<pre><code>Valve AA has flow rate=0; tunnels lead to valves DD, II, BB
Valve BB has flow rate=13; tunnels lead to valves CC, AA
Valve CC has flow rate=2; tunnels lead to valves DD, BB
Valve DD has flow rate=20; tunnels lead to valves CC, AA, EE
Valve EE has flow rate=3; tunnels lead to valves FF, DD
Valve FF has flow rate=0; tunnels lead to valves EE, GG
Valve GG has flow rate=0; tunnels lead to valves FF, HH
Valve HH has flow rate=22; tunnel leads to valve GG
Valve II has flow rate=0; tunnels lead to valves AA, JJ
Valve JJ has flow rate=21; tunnel leads to valve II
</code></pre>
<p>すべてのバルブは始めは<strong>閉じて</strong>います。
あなたは最初バルブ<code>AA</code>の位置にいますが、それは壊れているか、詰まっているか、何かでしょう。
その流量は<code>0</code>であるため、バルブを開けても意味がありません。
しかし、1分かけてバルブ<code>BB</code>に移動し、さらに1分かけてバルブを開くことができます。
そうすることで、残りの**<code>28</code>分間に<code>13</code>の流量で圧力が開放され、
最終的に合計で\(28 \times 13 = 364\)の圧力が開放されます。
次の3分めでバルブ<code>CC</code>に移動し、4分めでバルブを開き、<strong><code>26</code>分間</strong>流量<code>2</code>での追加の圧力開放ができ、
結果としてバルブ<code>CC</code>により合計<code>52</code>の圧力を開放できます。</p>
<p>このようにしてトンネルを進んでいくと、30分経過するまでに多くのバルブまたは全てのバルブを開けるかもしれません。
ただし、できるだけ多くの圧力を解放する必要があるため、順序だてて行う必要があります。
次のアプローチを考えます：</p>
<pre><code>== Minute 1 ==
No valves are open.
You move to valve DD.

== Minute 2 ==
No valves are open.
You open valve DD.

== Minute 3 ==
Valve DD is open, releasing 20 pressure.
You move to valve CC.

== Minute 4 ==
Valve DD is open, releasing 20 pressure.
You move to valve BB.

== Minute 5 ==
Valve DD is open, releasing 20 pressure.
You open valve BB.

== Minute 6 ==
Valves BB and DD are open, releasing 33 pressure.
You move to valve AA.

== Minute 7 ==
Valves BB and DD are open, releasing 33 pressure.
You move to valve II.

== Minute 8 ==
Valves BB and DD are open, releasing 33 pressure.
You move to valve JJ.

== Minute 9 ==
Valves BB and DD are open, releasing 33 pressure.
You open valve JJ.

== Minute 10 ==
Valves BB, DD, and JJ are open, releasing 54 pressure.
You move to valve II.

== Minute 11 ==
Valves BB, DD, and JJ are open, releasing 54 pressure.
You move to valve AA.

== Minute 12 ==
Valves BB, DD, and JJ are open, releasing 54 pressure.
You move to valve DD.

== Minute 13 ==
Valves BB, DD, and JJ are open, releasing 54 pressure.
You move to valve EE.

== Minute 14 ==
Valves BB, DD, and JJ are open, releasing 54 pressure.
You move to valve FF.

== Minute 15 ==
Valves BB, DD, and JJ are open, releasing 54 pressure.
You move to valve GG.

== Minute 16 ==
Valves BB, DD, and JJ are open, releasing 54 pressure.
You move to valve HH.

== Minute 17 ==
Valves BB, DD, and JJ are open, releasing 54 pressure.
You open valve HH.

== Minute 18 ==
Valves BB, DD, HH, and JJ are open, releasing 76 pressure.
You move to valve GG.

== Minute 19 ==
Valves BB, DD, HH, and JJ are open, releasing 76 pressure.
You move to valve FF.

== Minute 20 ==
Valves BB, DD, HH, and JJ are open, releasing 76 pressure.
You move to valve EE.

== Minute 21 ==
Valves BB, DD, HH, and JJ are open, releasing 76 pressure.
You open valve EE.

== Minute 22 ==
Valves BB, DD, EE, HH, and JJ are open, releasing 79 pressure.
You move to valve DD.

== Minute 23 ==
Valves BB, DD, EE, HH, and JJ are open, releasing 79 pressure.
You move to valve CC.

== Minute 24 ==
Valves BB, DD, EE, HH, and JJ are open, releasing 79 pressure.
You open valve CC.

== Minute 25 ==
Valves BB, CC, DD, EE, HH, and JJ are open, releasing 81 pressure.

== Minute 26 ==
Valves BB, CC, DD, EE, HH, and JJ are open, releasing 81 pressure.

== Minute 27 ==
Valves BB, CC, DD, EE, HH, and JJ are open, releasing 81 pressure.

== Minute 28 ==
Valves BB, CC, DD, EE, HH, and JJ are open, releasing 81 pressure.

== Minute 29 ==
Valves BB, CC, DD, EE, HH, and JJ are open, releasing 81 pressure.

== Minute 30 ==
Valves BB, CC, DD, EE, HH, and JJ are open, releasing 81 pressure.
</code></pre>
<p>このアプローチにより、このバルブ配置で30分間で可能な最も多くの圧力<code>1651</code>を開放できます。</p>
<p>30分で最大の圧力を開放する手順を探してください。
<strong>あなたが開放できる最大の圧力はどれだけですか？</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="18-日目-沸騰する岩"><a class="header" href="#18-日目-沸騰する岩">18 日目: 沸騰する岩</a></h1>
<p>（原題 Boiling Boulders で頭韻）</p>
<p>あなたとゾウたちはついに新鮮な空気にたどり着きました。
活発に噴火しているように見える、大きな火山のふもと近くに出ました！
幸いなことに、溶岩はあなたから離れて海に向かって流れているようです。</p>
<p>溶岩のかけらがまだあなたに向かって放出されているので、洞窟の出口にもうしばらく避難していることにします。
洞窟の外では、溶岩が池に流れ着くのが見え、溶岩が固まるシューという大きな音が聞こえます。</p>
<p>溶岩の特定の組成とそれが冷える速度によっては、<a href="https://ja.wikipedia.org/wiki/%E9%BB%92%E6%9B%9C%E7%9F%B3">黒曜石</a>ができている可能性があります！
冷却速度は溶岩の液滴の表面積に基づいているはずなので、溶岩の飛沫があなたのそばを通り過ぎるときにすばやくスキャンします（パズルの入力）。</p>
<p>溶岩の移動速度が速いため、スキャンはあまりうまくいきません。
その解像度は非常に低く、その結果、<strong>3次元グリッド上の1x1x1の立方体</strong>で溶岩滴の形状を近似し、
それぞれがその<code>x,y,z</code>座標として与えられます。</p>
<p>表面積を概算するには、別の立方体に直に接していない各立方体の側面の数を数えます。
したがって、スキャン結果が <code>1,1,1</code> と <code>2,1,1</code> のような2つの隣接する立方体のみである場合、
立方体はそれぞれ1つの側面が覆われ、5つの側面が露出し、側面の合計表面積は<code>10</code>になります。</p>
<p>より大きな例を示します。</p>
<pre><code>2,2,2
1,2,2
3,2,2
2,1,2
2,3,2
2,2,1
2,2,3
2,2,4
2,2,6
1,2,5
3,2,5
2,1,5
2,3,5
</code></pre>
<p>上記の例では、別の立方体に直に接していない全ての側面を数えると、総表面積は<strong>64</strong>です。</p>
<p><strong>あなたのスキャンでは、溶岩滴の表面積はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

読み込みは手抜きする。

```haskell
type XYZ = (Int,Int,Int)

parse :: String -> XYZ
parse s = read $ '(' : s ++ ")"
```

それぞれの座標軸について最小値と最大値を取り出し、
その周囲1マスまでを3次元配列で普通にボクセル表現する。

それぞれのマスについて、面で接する上下左右前後の8マスが空虚なら表面積として数え、
他のボクセルがあるときは数えない。

```haskell
import Data.Array

getLH :: (XYZ -> Int) -> [XYZ] -> (Int,Int)
getLH f cs = (pred $ minimum vs, succ $ maximum vs)
  where
    vs = map f cs

neighbors :: XYZ -> [XYZ]
neighbors (x,y,z) = [(pred x,y,z),(x,pred y,z),(x,y,pred z)
                    ,(succ x,y,z),(x,succ y,z),(x,y,succ z)]

compute1 :: [XYZ] -> Int
compute1 xyzs = length
    [() | xyz <- xyzs, xyz1 <- neighbors xyz, not $ arr ! xyz1]
  where
    (xL,xH) = getLH (\(x,_,_) -> x) xyzs
    (yL,yH) = getLH (\(_,y,_) -> y) xyzs
    (zL,zH) = getLH (\(_,_,z) -> z) xyzs
    arr = accumArray (||) False ((xL,yL,zL),(xH,yH,zH)) [(xyz,True) | xyz <- xyzs]

phase1 fn = print . compute1 . map parse . lines =<< readFile fn
```

</div></details>
-->
<h2 id="パート2-44"><a class="header" href="#パート2-44">パート2</a></h2>
<p>あなたの計算はどこかおかしいようです。
冷却速度が影響するのは外部表面積ですが、
あなたの計算には溶岩滴に封じ込められた気泡の表面積も含まれていました。</p>
<p>代わりに、溶岩の液滴が池に転がり落ちるときに水と蒸気が到達できる立方体の側面だけを考えてください。
蒸気は可能な限り拡大し、溶岩の液滴の外側にある空気を完全に追い出しますが、斜めに拡大することはありません。</p>
<p>上記の大い方の例では、ちょうど1つの立方体の気泡（座標<code>2,2,5</code>にある）が溶岩滴内に閉じ込められているため、
溶岩滴の外表面積は<strong>58</strong>です。</p>
<p><strong>あなたのスキャンでは、溶岩滴の外表面積はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

`(xL,yL,zL)` は外側であることが保証される。
この位置から水を塗り広げて、溶岩に衝突した回数がすなわち外表面積である。
塗り広げのため、更新のできる命令型配列が必要である。
配列の要素は、0が未処理、1が溶岩、2が水とする。

```haskell
import Data.Array.IO
import Control.Monad

phase2 fn = print =<< compute2 . map parse . lines =<< readFile fn

compute2 :: [XYZ] -> IO Int
compute2 cs =
  do
    arr <- newArray bnds 0 :: IO (IOArray XYZ Int)
    forM_ cs $ \xyz -> writeArray arr xyz 1
    loop 0 arr [(xL,yL,zL)]
  where
    (xL,xH) = getLH (\(x,_,_) -> x) cs
    (yL,yH) = getLH (\(_,y,_) -> y) cs
    (zL,zH) = getLH (\(_,_,z) -> z) cs
    bnds = ((xL,yL,zL),(xH,yH,zH))
```

塗りつぶしは、後で探索するべきマスの位置をスタックで持ちまわす。

```haskell
    loop :: Int -> IOArray XYZ Int -> [XYZ] -> IO Int
    loop cnt _ [] = return cnt
    loop cnt arr (xyz:xyzs) =
      do
        v <- readArray arr xyz
        case v of
          1 -> loop (succ cnt) arr xyzs  -- 溶岩に当たったのでカウント++
          2 -> loop cnt arr xyzs         -- 既に水があるので何もしない
          0 ->                           -- 初めて到達。水が流れ込む
            do
              writeArray arr xyz 2
              loop cnt arr $ filter (inRange bnds) (neighbors xyz) ++ xyzs
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-日目-サルの算数"><a class="header" href="#21-日目-サルの算数">21 日目: サルの算数</a></h1>
<p><a href="2022/./day11.html">サル</a>が戻ってきました！
あなたは、サルがまたあなたの持ち物を盗もうとするのではないかと心配になりますが、
彼らはただ自分たちの縄張りを守るために、
さまざまな猿の声をあなたに浴びせているだけのようです。</p>
<!--
hold one's ground 自分の立場を守る, (反対などに対して)一歩も引かない.
という訳語があるが、ここはそういう成句ではない感じ。
-->
<p>最終的に、象の1頭が、あなたが猿の言葉を話さないことに気づき、通訳をしにやってきます。
彼らはあなたが果樹園を見つけようとしていると話しているのを耳にした、ということがわかりました。
サルの出す<strong>なぞなぞ</strong>に答えられれば、近道を教えてくれるそうです。</p>
<p>それぞれのサルに、役割が与えられました。
それは、<strong>特定の数字叫ぶ</strong>か、<strong>数学演算の結果を叫ぶ</strong>かのどちらかです。
数を叫ぶサルはすべて、最初から自分の数を知っています。
しかし、算術演算のサルは、他の2匹のサルが数を叫ぶのを待つ必要があり、
その2匹のサルも<strong>また</strong>他のサルを待っている可能性があります。</p>
<p>あなたの仕事は、サルが自分で答えを見つける前に、
<strong><code>root</code>という名前のサルが叫ぶ数を算出する</strong>ことです。</p>
<p>例えば：</p>
<pre><code>root: pppw + sjmn
dbpl: 5
cczh: sllz + lgvd
zczc: 2
ptdq: humn - dvpt
dvpt: 3
lfqf: 4
humn: 5
ljgn: 2
sjmn: drzm * dbpl
sllz: 4
pppw: cczh / lfqf
lgvd: ljgn * ptdq
drzm: hmdt - zczc
hmdt: 32
</code></pre>
<p>各行は、サルの名前、コロン、そしてそのサルの役割が書いてあります。</p>
<ul>
<li>数ひとつだけが書かれているとき、そのサルの役割は単にその数を叫ぶことです。</li>
<li><code>aaaa + bbbb</code> のような役割は、サル<code>aaaa</code>とサル<code>bbbb</code>が自分の数を叫ぶのを待って、
それら二つの数の和を叫ぶことを意味します。</li>
<li><code>aaaa - bbbb</code> は、サル<code>aaaa</code>の数引く<code>bbbb</code>の数を叫ぶことを意味します。</li>
<li>役割 <code>aaaa * bbbb</code> は<code>aaaa</code>の数に<code>bbbb</code>の数を掛けたものを叫びます。</li>
<li>役割 <code>aaaa / bbbb</code> は<code>aaaa</code>の数を<code>bbbb</code>の数で割った値を叫びます。（訳注：端数切り捨て）</li>
</ul>
<p>したがって、上記の例では、サル <code>drzm</code> はサル <code>hmdt</code> と <code>zczc</code> がそれぞれの数を叫ぶのを待つ必要があります。
幸いなことに、<code>hmdt</code> と <code>zczc</code> は共に単に数を叫ぶだけの役割を持っているので、
即座にそれをします。<code>32</code> と <code>2</code> です。
そしてサル <code>drzm</code> は <code>32</code> から <code>2</code> を引くことで、自分の数 <code>30</code> を叫ぶことができます。</p>
<p>すると、サル <code>sjmn</code> はその数のひとつ（<code>drzm</code> からの <code>30</code>）を持ち、
またもうひとつの数（<code>5dbpl</code> からの <code>5</code>）を既に持っています。
<code>30</code> に <code>5</code> を掛けることで、自分の数 <code>150</code> を叫ぶことができます。</p>
<p>この手順は <code>root</code> が数 <code>152</code> を叫ぶまで続きます。</p>
<p>ただし、あなたの実際の状況には、かなり多くのサルが関係しています。
<strong>サル <code>root</code> が叫ぶ数はいくつでしょう？</strong></p>
<details><summary>解説</summary><div>
<p>遅延評価を活かして、サルの名前をキー、叫ぶ数を値とする<code>Map</code>を構成する。
計算をするサルは、依存するサルの叫ぶ値を、その<code>Map</code>を介して受け取る。</p>
<pre><code class="language-haskell">import qualified Data.Map as M

compute1 :: String -&gt; Int
compute1 co = m M.! "root"
  where
    m = M.fromList $ map (parse . words) $ lines co
    parse [key, num] = (init key, read num)
    parse [key, m1, op:_, m2] = (init key, funof op (m M.! m1) (m M.! m2))

funof '+' = (+)
funof '-' = (-)
funof '*' = (*)
funof '/' = div

test1 = readFile  "test.txt" &gt;&gt;= print . compute1
main1 = readFile "input.txt" &gt;&gt;= print . compute1
</code></pre>
</div></details>
<h1 id="パート2-45"><a class="header" href="#パート2-45">パート2</a></h1>
<p>サル→ゾウ→人間の間の何らかの誤訳のせいで、なぞなぞのいくつかの重要な詳細を誤解しているようです。</p>
<p>第一に、あなたは <code>root</code> という名前のサルの任務を間違えました。
具体的には、間違った算術演算と受け取りました。
サル <code>root</code> の正しい動作は <code>=</code> です。
これは、やはり2つの数を（前と同じ2匹のサルから）聞きますが、
2つの数が<strong>一致する</strong>かどうかを確認することを意味します。</p>
<p>第二に、あなたは <code>humn</code> から始まる任務の行について、間違ったサルを割り当てました。
それはサルではありません ー <strong>あなた</strong>です。
実際のところ、あなた自身の任務も間違えました。
<code>root</code> の同値性判定に合格するには、<strong>あなたがどの数を叫ぶ</strong>必要があるかを見つけ出す必要があります。
（あなたの入力の <code>humn:</code> の続きにある数は、今や無意味です。）</p>
<p>上の例では、<code>root</code> の同値性判定に合格するために叫ばなければならない数は<code>301</code>です。
（これにより、<code>root</code> は両方のサルから同じ数 <code>150</code> を得ます。）</p>
<p><strong><code>root</code>の同値性判定に合格するために、あなたはどんな数を叫びますか？</strong></p>
<details><summary>解説</summary><div>
解説
<p>パート1では、木の根 <code>root</code> の方から、親ノードが子ノードの名前を知っていて、その値を取得していた。</p>
<p>パート2では、<code>humn</code> を根として、<code>humn</code>から<code>root</code>までの経路は今までと辿る向きおよび計算を逆向きにして、
<code>root</code>の両辺が等しい値になるために、<code>humn</code>側の子がとるべき値を求める計算を、<code>humn</code> まで繋げる。
そのため、二分木の全ての方向について、ノードの値を求められる必要がある。</p>
<p>例えば、一つの式 <code>one: two + three</code> は、全ての方向から見たときのそのノードのとる（べき）値を定義している。
<code>root</code> を根とした木で、<code>one</code>の親を <code>parent</code> とするとき、</p>
<div class="table-wrapper"><table><thead><tr><th>向き</th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>上から</td><td>oneをparentから見た値は</td><td>twoをoneから見た値</td><td>＋</td><td>threeをoneから見た値</td></tr>
<tr><td>左下から</td><td>oneをtwoから見た値は</td><td>parentをoneから見たの値</td><td>ー</td><td>threeをoneから見た値</td></tr>
<tr><td>右下から</td><td>oneをthreeから見たの値は</td><td>parentをoneから見た値</td><td>ー</td><td>twoをoneから見たの値</td></tr>
</tbody></table>
</div>
<p>となる。他の演算についても同様である。また <code>root</code> に関しては、<code>root: left = right</code> としたとき（演算子は無視する）</p>
<div class="table-wrapper"><table><thead><tr><th>向き</th><th></th><th></th></tr></thead><tbody>
<tr><td>左下から</td><td>rootをleftから見た値は</td><td>rightをrootから見たの値</td></tr>
<tr><td>右下から</td><td>rootをrightから見た値は</td><td>leftをrootから見たの値</td></tr>
</tbody></table>
</div>
<p>とすればよい。</p>
<p>これを実現するために、パート1での<code>Map</code>のキーを、サルの名前に加えて、誰から見たときか、で拡張する。
なお、数を叫ぶ任務のサルは親からしか参照されることはない。
このとき、任務の定義 <code>one: two + three</code>, <code>four: 5</code> を見ただけでは、<code>parent</code> の名前がわからないので、
それを先に取り出しておく。</p>
<pre><code class="language-haskell">compute2 :: String -&gt; Int
compute2 co = m M.! (parent M.! "humn", "humn")
  where
    wls = map words $ lines co
    parent = M.fromList $ concatMap parseParent wls
    parseParent [key, m1, _, m2] = [(m1, init key),(m2, init key)]
    parseParent _ = []
-- m M.! (w,wFrom) : wをwFromから見たときの値
    m = M.fromList $ concatMap parse wls
    parse (w:ws) =
      case ws of
        [num] -&gt; [((w1,wP), read num)]
        [wL,_,wR] | w1 == "root" -&gt; [((w1,wL), m M.! (wR,w1)),((w1,wR), m M.! (wL,w1))]
        [wL,'+':_,wR] -&gt; [((w1,wP), m M.! (wL,w1) + m M.! (wR,w1))
                         ,((w1,wL), m M.! (wP,w1) - m M.! (wR,w1))        -- w1(wL) = wP - wR
                         ,((w1,wR), m M.! (wP,w1) - m M.! (wL,w1))]       -- w1(wR) = wP - wL
        [wL,'-':_,wR] -&gt; [((w1,wP), m M.! (wL,w1) - m M.! (wR,w1))
                         ,((w1,wL), m M.! (wP,w1) + m M.! (wR,w1))        -- w1(wL) = wP + wR
                         ,((w1,wR), m M.! (wL,w1) - m M.! (wP,w1))]       -- w1(wR) = wL - wP
        [wL,'*':_,wR] -&gt; [((w1,wP), m M.! (wL,w1) * m M.! (wR,w1))
                         ,((w1,wL), m M.! (wP,w1) `div` m M.! (wR,w1))    -- w1(wL) = wP / wR
                         ,((w1,wR), m M.! (wP,w1) `div` m M.! (wL,w1))]   -- w1(wR) = wP / wL
        [wL,'/':_,wR] -&gt; [((w1,wP), m M.! (wL,w1) `div` m M.! (wR,w1))
                         ,((w1,wL), m M.! (wP,w1) * m M.! (wR,w1))        -- w1(wL) = wP * wR
                         ,((w1,wR), m M.! (wL,w1) `div` m M.! (wP,w1))]   -- w1(wR) = wL / wP
        _ -&gt; error $ "never" ++ show (w:ws)
      where
        w1 = init w
        wP = parent M.! w1
    parse _ = error "never"
</code></pre>
<p>このコードが求めた値が正解と無事に判定されたが、少し疑問が残る。</p>
<p>割り算が切り捨てで考えられているため、切り捨てられる分について誤差が許容され、答えが一意に定まらない可能性がある。</p>
<ul>
<li>\(2 = X / 3\) は \(X=6\) だけでなく \(X =7, 8\) でも成り立つ。<br />
一般に \(A = X / B\) は \(AB \leq X &lt; AB+B\) で成り立つ。</li>
<li>\(2 = 8 / Y\) は \(Y=4\) だけでなく \(Y = 3\) でも成り立つ。<br />
一般に \(A = B / X\) は、最小の \(X\) は \(AX + X - 1 = B\) より \(X \geq \frac{B+1}{A+1}\),
最大の\(X\)は\(AX=B\)より\(X \leq \frac{B}{A}\),
まとめると\(\lceil \frac{B+1}{A+1} \rceil \leq X \leq \lfloor \frac{B}{A} \rfloor\)
（こちらはあまり揺れないということか。）</li>
</ul>
<p>掛け算の逆で割り算をするとき、計算が合わなくなる恐れがある。</p>
<ul>
<li>\(8 = X * 3\) をナイーブに \(X = 8/3 = 2\) とやると誤り。これを満たす整数 \(X\) は存在しない。<br />
一般に、\(A = X * B\) は、\(A \bmod B = 0\) のときに限り \(X = A / B\) である。</li>
</ul>
<p>可能性のある値を集合で持つカスタム版を作成して実験してみる…
と、例について <code>[301, 302]</code> となった。301が本文に示された答え。
そして302でも確かに計算は合う。</p>
<p>本問題について <code>[3740214169961,3740214169962,3740214169963,3740214169964]</code> と
4つも答えが出てきた。これらを答えたらどうなったんだろう。</p>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2024年"><a class="header" href="#2024年">2024年</a></h1>
<p>主任歴史学者は、クリスマスのそりの大きな打ち上げにいつも出席していますが、ここ何ヶ月も誰も彼を見ていません！
最後に聞こえた噂は、彼が北極にとって歴史的に重要な場所を訪れていたということです。
上級歴史学者のグループが、彼が訪れる可能性が最も高いと思われる場所を確認する際に、あなたに同行するよう依頼しました。</p>
<p>それぞれの場所を調査すると、彼らはそれを彼らのリストにスターでマークします。彼らは、主任歴史学者は彼らが最初に見る50の場所の1つにいるに違いないと考えているので、クリスマスを救うためには、12月25日にサンタが出発する前に彼らのリストに50のスターを得る手助けをする必要があります。</p>
<p>パズルを解いてスターを集めます。アドベントカレンダーの各日に2つのパズルが利用可能になります。最初のパズルを正解すると、2番目のパズルのロックが解除されます。各パズルに1つのスターが与えられます。幸運を祈ります!</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right"></th><th style="text-align: left">タイトル</th><th style="text-align: left">ひとこと</th></tr></thead><tbody>
<tr><td style="text-align: right">1</td><td style="text-align: left">歴史学者の遁走</td><td style="text-align: left">主任歴史学者が逃げ出した行き先を推理しよう</td></tr>
<tr><td style="text-align: right">2</td><td style="text-align: left">赤鼻報告書</td><td style="text-align: left">核融合プラントの安全性を確保しよう</td></tr>
<tr><td style="text-align: right">3</td><td style="text-align: left">じっくり考える</td><td style="text-align: left">北極トボガンそり貸し店の壊れたコンピュータを何とかしよう</td></tr>
<tr><td style="text-align: right">4</td><td style="text-align: left">セレス検索</td><td style="text-align: left">セレス監視ステーションでシークワーズを解こう</td></tr>
<tr><td style="text-align: right">5</td><td style="text-align: left">印刷キュー</td><td style="text-align: left">北極印刷局で乱丁騒ぎ</td></tr>
<tr><td style="text-align: right">6</td><td style="text-align: left">守衛の闊歩</td><td style="text-align: left">北極試作スーツ製造ラボでスニーキングミッション</td></tr>
<tr><td style="text-align: right">7</td><td style="text-align: left">橋の修理</td><td style="text-align: left">ジャングルの吊り橋を修理</td></tr>
<tr><td style="text-align: right">8</td><td style="text-align: left">同一直線上での共鳴</td><td style="text-align: left">イースターバニーの毒電波発信を阻止せよ</td></tr>
<tr><td style="text-align: right">9</td><td style="text-align: left">ディスク断片化</td><td style="text-align: left">ヨコエビのディスクをデフラグ</td></tr>
<tr><td style="text-align: right">10</td><td style="text-align: left">歩いてゆこう</td><td style="text-align: left">溶岩島でハイキング</td></tr>
<tr><td style="text-align: right">11</td><td style="text-align: left">冥王星の小石</td><td style="text-align: left">冥王星の小石がどんどん増える</td></tr>
<tr><td style="text-align: right">12</td><td style="text-align: left">ガーデングループ</td><td style="text-align: left">農場の花壇に柵を立てよう</td></tr>
<tr><td style="text-align: right">13</td><td style="text-align: left">かぎ爪のある奇妙な機械</td><td style="text-align: left">熱帯島でクレーンゲーム</td></tr>
<tr><td style="text-align: right">14</td><td style="text-align: left">トイレの要塞</td><td style="text-align: left">イースターバニー本部のトイレは警備が厳重</td></tr>
<tr><td style="text-align: right">15</td><td style="text-align: left">倉庫の悩み</td><td style="text-align: left">ハダカイワシの食糧倉庫で倉庫番</td></tr>
<tr><td style="text-align: right">16</td><td style="text-align: left">トナカイ迷路</td><td style="text-align: left">トナカイオリンピックでVIP席を探す</td></tr>
<tr><td style="text-align: right">17</td><td style="text-align: left">時空間コンピュータ</td><td style="text-align: left">落ちてゆきながらアセンブラでQuine</td></tr>
<tr><td style="text-align: right">18</td><td style="text-align: left">RAM脱走</td><td style="text-align: left">北極コンピュータのメモリ空間を駆け抜けろ</td></tr>
<tr><td style="text-align: right">19</td><td style="text-align: left">リネンの配置</td><td style="text-align: left">歯車島の温泉に浸かりたい！タオルがいっぱい！</td></tr>
<tr><td style="text-align: right">20</td><td style="text-align: left">レースコンディション</td><td style="text-align: left">コンピュータの中でのレースはピコ秒の世界</td></tr>
<tr><td style="text-align: right">21</td><td style="text-align: left">キーパッドの謎</td><td style="text-align: left">トナカイ級宇宙船の中で二人羽織</td></tr>
<tr><td style="text-align: right">22</td><td style="text-align: left">猿市場</td><td style="text-align: left">ジャングルで猿がバナナが取引市場</td></tr>
<tr><td style="text-align: right">23</td><td style="text-align: left">LANパーティ</td><td style="text-align: left">EBHQでLANパーティを探せ！</td></tr>
<tr><td style="text-align: right">24</td><td style="text-align: left">こんがらがった配線</td><td style="text-align: left">ジャングルの中で論理回路の修理</td></tr>
<tr><td style="text-align: right">25</td><td style="text-align: left">AoC年代記</td><td style="text-align: left">主任の研究室に戻った我々が目にしたものは！</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="1日目歴史学者の遁走"><a class="header" href="#1日目歴史学者の遁走">1日目:歴史学者の遁走</a></h1>
<p>あなたはまだ出発しておらず、小人の上級歴史学者グループは既に問題に直面しています：今の所、彼らのチェックすべき場所のリストは白紙です。最終的に、誰かが最初にチェックするのに最適な場所は主任歴史学者の研究史であると判断します。</p>
<p>研究室になだれ込んだ皆は誰もが、主任歴史学者が実際どこにも見つからないことを確認します。
その代わりに、小人たちは歴史的に重要な場所のメモとリストの組み合わせを発見します！
これは、主任歴史学者が去る前に行っていた計画のようです。おそらくこれらのメモは、どの場所を検索するかを決定するために使用できるのでは？</p>
<p>主任の研究室では一貫して、歴史的に重要な場所は名前ではなく、場所IDと呼ばれる一意の番号でリストされています。彼らが何も見逃さないようにするために、歴史学者たちは二手に分かれ、それぞれが研究室を捜索し、場所IDの独自の完全なリストを作成しようとします。</p>
<p>ひとつだけ問題があります。ふたつのリストを並べて（パズルの入力）みると、リストがあまり似ていないことがすぐに明らかになります。歴史学者が彼らのリストを調整するのを手伝ってくれませんか?</p>
<p>例を示します：</p>
<pre><code>3   4
4   3
2   5
1   3
3   9
3   3
</code></pre>
<p>きっと、リストは少しずれているだけなのでしょう！
それを知るには、数字をペアにして、それらがどれだけ離れているかを測定します。左側のリストの最小値と右側のリストの最小値をペアにして、左側で2番目に小さい数値と右側で2番目に小さい数値をペアにします。以下同じように続けます。</p>
<p>各ペア内で、2つの数値の違いを計算します。これらの差を全て合計する必要があります。例えば、左側のリストの3と右側のリストの7をペアにすると、差は4になります。9と3をペアにすると、差は6になります。</p>
<p>上記のリスト例では、ペアと差は次のようになります：</p>
<ul>
<li>左のリストの最小値は1、右のリストの最小値は3です。それらの間の差は2です。</li>
<li>左のリストの2番目に小さい数値は2で、右のリストの2番目に小さい数値は別の3です。それらの間の差は1です。</li>
<li>両方のリストの3番目に小さい数値は3なので、それらの間の差は0です。</li>
<li>次にペアになる数値は3と4で、差は1です。</li>
<li>各リストの5番目に小さい数値は3と5で、差は2です。</li>
<li>最後に、左のリストの最大の数値は4で、右のリストの最大の数値は9です。これらは差が5あります。</li>
</ul>
<p>左のリストと右のリストの間の総合距離を求めるには、見つかったすべてのペア間の差を合計します。上の例では、これは2+1+0+1+2+5で、総合距離は11です。</p>
<p>実際の左右のリストには多くの場所IDが含まれています。リスト間の総合距離はいくつですか？</p>
<h1 id="パート2-46"><a class="header" href="#パート2-46">パート2</a></h1>
<p>あなたの分析は、誰もが恐れていたことを確認しただけです：場所IDのふたつのリストは実際には非常に異なっています。</p>
<p>それともこれらは？</p>
<p>歴史学者たちは、どのグループが間違いを犯したのか、あるいは主任の手書きのほとんどをどのように読むのかについて意見が分かれています。そんな騒動の中であなたは興味深い詳細に気づきました：多くの場所IDが両方のリストに現れている！
おそらく他の番号は場所IDではなく、字が汚くて読み間違えたのでしょう。</p>
<p>今度は、左側のリストの各数値が右側のリストに現れる頻度を正確に把握する必要があります。左側のリストの各数値に、その数値が右側のリストに現れる回数を掛け合わせて合計し、類似性スコアの合計を計算します。</p>
<p>前と同じリストの例を示します：</p>
<pre><code>3   4
4   3
2   5
1   3
3   9
3   3
</code></pre>
<p>これらのリストの例では、類似性スコアを見つける手順は次のとおりです：</p>
<ul>
<li>左のリストの最初の数値は3です。右のリストに3回現れているため、類似性スコアは3*3=9増加します。</li>
<li>左のリストの2番目の数値は4です。右のリストに1回現れているため、類似性スコアは4*1=4増加します。</li>
<li>左のリストの3番目の数値は2です。右のリストに現れていないため、類似性スコアは増加しません(2*0=0)。</li>
<li>4番目の数値1も右のリストに現れていません。</li>
<li>5番目の数値3は右のリストに3回現れています。類似性スコアは9増加します。</li>
<li>最後の数値3は右のリストに3回現れています。類似性スコアは再び9増加します。</li>
</ul>
<p>したがって、これらのリストの例では、この手順の完了時の類似性スコアは31 (9+4+0+0+9+9)です。</p>
<p>もう一度、あなたの左と右のリストを考えてみましょう。それらの類似性スコアはいくつですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2日目赤鼻報告書"><a class="header" href="#2日目赤鼻報告書">2日目：赤鼻報告書</a></h1>
<p>幸いなことに、歴史学者たちが最初に捜索したい場所は、主席歴史学者の研究室から歩いてそれほど遠くありません。</p>
<p><a href="2024/../2015/day19.html">赤鼻のトナカイ核融合/核分裂プラント</a>には主任歴史学者の痕跡はないようですが、
そこの技術者たちはあなたを見るとすぐに駆け寄ってきます。
どうやら、彼らはルドルフが電子1個から分子合成によって救われた時のことを今でも話しているようです。</p>
<p>あなたは既にここにいるので、彼らはすぐに言葉を続けます。
赤鼻原子炉からのいくつかの異常なデータを分析することについ、あなたの助力が必要なようです。</p>
<!-- 超訳 -->
<p>あなたは歴史学者たちがあなたを待っているかどうかを確認するために振り返りましたが、
彼らは既にいくつかのグループに分かれて、今は施設の隅々を捜索しているようです。
あなたは異常なデータについて手伝うことを申し出ます。</p>
<p>通常とは異なるデータ（パズルの入力）は、1行に1つのレポートを含む多数のレポートで構成されています。
各レポートは、スペースで区切られたレベルと呼ばれる数値のリストです。次に例を示します：</p>
<pre><code>7 6 4 2 1
1 2 7 8 9
9 7 6 2 1
1 3 2 4 5
8 6 4 4 1
1 3 6 7 9
</code></pre>
<p>この例のデータには、それぞれ5つのレベルを含む6つのレポートが含まれています。</p>
<p>技術者は、どのレポートが安全であるかを把握しようとしています。
赤鼻原子炉安全システムは、徐々に増加または徐々に減少するレベルしか許容しません。
したがって、次の両方に該当する場合にのみ、レポートは安全であると見なされます：</p>
<ul>
<li>レベルは全て増加しているか、すべて減少している</li>
<li>隣接するふたつのレベルは、少なくとも1、多くて3異なる</li>
</ul>
<p>上の例で、これらの規則を確認することで、レポートが安全であるか安全でないかを判断できます：</p>
<ul>
<li>7 6 4 2 1: レベルが全て1または2減少しているため<strong>安全</strong>です。</li>
<li>1 2 7 8 9: 2 7は5増加しているため<strong>危険</strong>です。</li>
<li>9 7 6 2 1: 6 2は4減少しているため<strong>危険</strong>です。</li>
<li>1 3 2 4 5: 1 3は増加していますが、3 2は減少しているため<strong>危険</strong>です。</li>
<li>8 6 4 4 1: 4 4は増加でも減少でもないため<strong>危険</strong>です。</li>
<li>1 3 6 7 9: レベルが全て1, 2, 3 のいずれかずつ増加しているため<strong>安全</strong>です。</li>
</ul>
<p>したがって、この例では、2つのレポートが安全です。</p>
<p>技術者からの異常なデータを分析します。安全なレポートはいくつありますか？</p>
<h1 id="パート2-47"><a class="header" href="#パート2-47">パート2</a></h1>
<p>技術者たちは、異常沈静装置についてあなたに話すのを忘れていたことに気づくまで、安全なレポートの数が少ないことに驚いていました。</p>
<p>異常沈静装置は原子炉に搭載されたモジュールで、原子炉の安全システムは、
それがなければ安全なレポートとなる悪いレベルを一つだけ許容することができる。
それはまるで、悪いレベルは初めからなかったかのようにする！</p>
<p>以前と同じ規則が適用されますが、安全でないレポートからひとつのレベルを削除すると安全になる場合、レポートは安全と見なされる点だけが変わります。</p>
<p>上記の例のレポートの多くが安全になりました：</p>
<ul>
<li>7 6 4 2 1: レベルを削除しなくても<strong>安全</strong>です。</li>
<li>1 2 7 8 9: どのレベルを削除しても<strong>危険</strong>なままです。</li>
<li>9 7 6 2 1: どのレベルを削除しても<strong>危険</strong>なままです。</li>
<li>1 3 2 4 5: 2番目のレベルの3を削除することで<strong>安全</strong>になります。</li>
<li>8 6 4 4 1: 3番目のレベルの4を削除することで<strong>安全</strong>になります。</li>
<li>1 3 6 7 9: レベルを削除しなくても<strong>安全</strong>です。</li>
</ul>
<p>異常沈静装置のおかげで、実際には4つのレポートが安全です！</p>
<p>異常沈静装置が安全でないレポートからレベルをひとつが削除できる状況を扱うことで、分析を更新してください。
現在、安全なレポートはいくつありますか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3日目-じっくり考える"><a class="header" href="#3日目-じっくり考える">3日目: じっくり考える</a></h1>
<p>(原文 Mull It Over : 問題の <code>mul</code> と掛けている)</p>
<p>「コンピュータに問題があり、主任歴史学者の在庫があるかどうかわかりません。
倉庫を確認していただければと思います」
と、<a href="2024/../2020/day2.html">北極トボガンそり貸し店</a>の店主が少し取り乱した様子で言いました。
歴史学者たちは倉庫の方に行きました。</p>
<p>店主はあなたのほうを向いて言いました。
「なぜ当店のコンピュータにまた問題が発生しているのか、調べては貰えませんか？」</p>
<p>コンピュータはプログラムを実行しようとしているようですが、
メモリ（あなたのパズル入力）が<strong>破損</strong>しています。
全ての命令がごちゃ混ぜになっています！</p>
<p>プログラムの目的は、単に<strong>いくつかの数値を掛け合わせる</strong>ことのようです。
これは <code>mul(X,Y)</code> のような命令で実行されます。
ここで <code>X</code>  と <code>Y</code> はそれぞれ1～3桁の数値です。
例えば <code>mul(44,46)</code> は44と46を掛けて2024という結果になります。
同様に <code>mul(123,4)</code> は123と4を掛けます。</p>
<p>ただし、プログラムのメモリが破損しているため、<strong>無視する</strong>べき無効な文字も多数あります。
これは <code>mul</code> 命令の一部のように見えてもです。
<code>mul(4*</code>, <code>mul(6,9!</code>, <code>?(12,34)</code>, or <code>mul ( 2 , 4 )</code> などの文字列では<strong>何もしません</strong>。</p>
<p>例として、次の破損したメモリの一部を考ましょう：</p>
<pre><code>xmul(2,4)%&amp;mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))
</code></pre>
<p>ハイライト表示された（されてません、原文参照）4箇所だけが実際のmul命令です。
各命令の結果を合計すると 161 $(2 \times 4 + 5 \times 5 + 11 \times 8 + 8 \times 5)$ となります。</p>
<p>破損したメモリをスキャンして、破損していない <code>mul</code> 命令を探します。
乗算の結果をすべて合計するといくつになりますか？</p>
<h1 id="パート-2"><a class="header" href="#パート-2">パート 2</a></h1>
<p>破損したメモリをスキャンすると、一部の条件文もまだ無傷なことに気付きました。
プログラム内の破損していない一部の条件文を処理すれば、より正確な結果が得られる可能性があります。</p>
<p>処理する必要がある新しい命令が2つあります：</p>
<ul>
<li><code>do()</code> 命令により、以降の <code>mul</code> 命令が<strong>有効</strong>になります。</li>
<li><code>don't()</code> 命令は以降の <code>mul</code> 命令を<strong>無効</strong>にします。</li>
</ul>
<p><strong>直近の</strong> <code>do()</code> 命令または <code>don't()</code> 命令のみが適用されます。
プログラムの開始時には、<code>mul</code> 命令は<strong>有効</strong>になっています。</p>
<p>例えば：</p>
<pre><code>xmul(2,4)&amp;mul[3,7]!^don't()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5))
</code></pre>
<p>この破損したメモリは前の例と似ていますが、
今回は <code>mul(5,5)</code> と <code>mul(11,8)</code> 命令が、それらの前に <code>don't()</code> 命令があるために<strong>無効</strong>になっています。
他の <code>mul</code> 命令は、<code>do()</code> 命令によって再度<strong>有効</strong>になる最後の命令を含め、普通に機能します。</p>
<p>今回は結果の合計は48 $(2 \times 4 + 8 \times 5)$ です。</p>
<p>新しい命令を処理します。有効になっている乗算の結果をすべて合計するといくつになりますか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4日目セレス検索"><a class="header" href="#4日目セレス検索">4日目:セレス検索</a></h1>
<p>「主任はここにいないようです。次いってみよう！」
歴史学者の1人がデバイスを取り出し、その唯一のボタンを押します。
一瞬の閃光の後、あなたは<a href="2024/../2019/day10.html">セレス監視ステーション</a>の中にいることに気づきました！</p>
<p>主任の捜索が続く中、監視ステーションに駐在している小さな小人があなたのシャツを引っ張っています。
彼女は、あなたが彼女の<a href="https://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%BC%E3%82%AF%E3%83%AF%E3%83%BC%E3%82%BA">シークワーズ</a>（あなたのパズル入力）を手伝ってくれるかどうか知りたがっています。
彼女は単語 <code>XMAS</code> それだけを見つける必要があります。</p>
<p>このシークワーズでは、単語を水平、垂直、斜め、逆方向、他の単語と重なるものも許します。
少しだけ普通でないのは、<code>XMAS</code>を一つだけ見つけるのではなく、それを全て見つける必要があります。
無関係な文字を <code>.</code> で置き換えて、<code>XMAS</code> が現れる形のいくつかを示します：</p>
<pre><code>..X...
.SAMX.
.A..A.
XMAS.S
.X....
</code></pre>
<p>実際のシークワーズは、文字でいっぱいです。
例：</p>
<pre><code>MMMSXXMASM
MSAMXMSMSA
AMXSXMAAMM
MSAMASMSMX
XMASAMXAMM
XXAMMXXAMA
SMSMSASXSS
SAXAMASAAA
MAMMMXMMMM
MXMXAXMASX
</code></pre>
<p>このシークワーズには <code>XMAS</code> が合計18個出現しています。
同じシークワーズの、<code>XMAS</code> に含まれていない文字を <code>.</code> に置き換たものを示します：</p>
<pre><code>....XXMAS.
.SAMXMS...
...S..A...
..A.A.MS.X
XMASAMX.MM
X.....XA.A
S.S.S.S.SS
.A.A.A.A.A
..M.M.M.MM
.X.X.XMASX
</code></pre>
<p>小さな小人のシークワーズを見てみましょう。<code>XMAS</code> は何個出現していますか？</p>
<h1 id="パート2-48"><a class="header" href="#パート2-48">パート2</a></h1>
<p>小人はあなたを不思議そうに見ています。やることを勘違いしていたかも？</p>
<p>シークワーズをひっくり返して説明書きを探すと、これは実際には <code>XMAS</code> パズルではないことがわかりました。
これは <code>X-MAS</code> パズルです。ふたつの <code>MAS</code> が <code>X</code> の形になっているものを見つけます。
それを達成する1つの方法は次のようなものです：</p>
<pre><code>M.S
.A.
M.S
</code></pre>
<p>上の図では、無関係な文字が再び <code>.</code> に置き換えられています。
<code>X</code> の中では、X内では、各 <code>MAS</code> は順方向または逆方向に書かれてもよいです。
これは以前と同じ例ですが、今回は全ての <code>X-MAS</code> が残してあります：</p>
<pre><code>.M.S......
..A..MSMS.
.M.S.MAA..
..A.ASMSM.
.M.S.M....
..........
S.S.S.S.S.
.A.A.A.A..
M.M.M.M.M.
..........
</code></pre>
<p>この例では、<code>X-MAS</code> が9個出現しています。</p>
<p>説明書きから裏返してシークワーズに戻して、やり直してください。
<code>X-MAS</code> は何個出現していますか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5日目印刷キュー"><a class="header" href="#5日目印刷キュー">5日目:印刷キュー</a></h1>
<p>ケレスでの捜索に満足した学者集団は、次に、地下17階の文房具の山をスキャンすることを提案します。</p>
<p>北極印刷局はクリスマスに近づくにつれてかつてないほど忙しくなり、
歴史学者たちがこの歴史的に重要な施設の捜索を続ける一方で、
<a href="2024/../2017/day1.html">非常に馴染みのあるプリンタ</a>を操作している妖精があなたを手招きしています。</p>
<p>小人はあなたが誰か思い出したのでしょう。<!-- 超訳 -->
なぜなら、彼らは新しい<strong>そりの打ち上げ安全マニュアル</strong>の更新が正しく印刷できないことを説明する時間も惜しいからです。
安全マニュアルを更新しないことは本当に悲惨なことなので、あなたは助けを申し出ます。</p>
<p>安全プロトコルは、安全マニュアルの新しいページが<strong>非常に特定の順序で</strong>印刷されなければならないことを明確に示しています。
<code>X|Y</code> という表記は、ページ番号 <code>X</code> とページ番号 <code>Y</code> の両方が更新の一部として生成される場合、
ページ番号 <code>X</code> はページ番号 <code>Y</code> の前のある時点で印刷される<strong>必要</strong>があることを意味します。</p>
<p>小人は、<strong>ページ順序の規則</strong>と各更新で生成されるページ（あなたのパズル入力）の両方がありますが、
各更新でページが正しい順序であるかどうかを判断することはできません。</p>
<p>例えば：</p>
<pre><code>47|53
97|13
97|61
97|47
75|29
61|13
75|53
29|13
97|29
53|29
61|53
97|53
61|29
47|13
75|47
97|75
47|61
75|61
47|29
75|13
53|13

75,47,61,53,29
97,61,53,29,13
75,29,13
75,97,47,61,53
61,13,29
97,13,75,29,47
</code></pre>
<p>最初のセクションでは、1行に1つずつ、<strong>ページ順序の規則</strong>を指定しています。
最初の規則 <code>47|53</code> は、更新にページ番号47とページ番号53の両方が含まれている場合、
ページ番号47はページ番号53よりも前のある時点で印刷する必要があることを意味します。
（47は必ずしも53の<strong>直前</strong>である必要はありません。他のページが53との間にあってもかまいません。）</p>
<p>2番目のセクションでは、各更新のページ番号を指定しています。
ほとんどの安全マニュアルは異なるため、更新に必要なページも異なります。
最初の更新 <code>75, 47, 61, 53, 29</code> は、
更新がページ番号 75, 47, 61, 53, 29 から構成されていることを意味します。</p>
<p>できるだけ早くプリンタを稼働させるために、
<strong>既に正しい順序になっている更新はどれか</strong>を特定することから始めます。</p>
<p>上の例では、最初の更新( <code>75,47,61,53,29</code> )は正しい順序です。</p>
<ul>
<li>75は、その他のページをより後ろに配置するルール(<code>75|47</code>, <code>75|61</code>, <code>75|53</code>, <code>75|29</code>) があるため、正しく先頭になります。</li>
<li>47は、75がその前になければならず(<code>75|47</code>)、<code>47|61</code>, <code>47|53</code>, <code>47|29</code> よりその他のページは後ろにあるべきなので、正しく2番目です。</li>
<li>61は、75と47がその前にあり(<code>75|61</code>と<code>47|61</code>)、53と29がその後にある(<code>61|53</code>と<code>61|29</code>)ため、正しく中央です。</li>
<li>53は、ページ番号29の前にあるため、正しく4番目です(<code>53|29</code>)。</li>
<li>29は残っている唯一のページであり、正しく最後です。</li>
</ul>
<p>最初の更新には一部のページ番号が含まれないため、欠落したページ番号に関する順序ルールは無視されます。</p>
<p>2回目と3回目の更新も、ルールに則った正しい順序です。
1回目の更新と同様に、全てのページ番号が含まれるわけではないため、一部の順序ルールのみが適用されます。
各更新では、欠落したページ番号を含む順序ルールは使用されません。</p>
<p>4番目の更新 <code>75,97,47,61,53</code> は正しい順序ではありません。
97の前に75が印刷され、<code>97|75</code> の規則に違反します。</p>
<p>5番目の更新 <code>61,13,29</code>  も、ルール <code>29|13</code> に違反しているため、正しい順序ではありません。</p>
<p>最後の更新 <code>97,13,75,29,47</code> は、いくつかの規則に違反しているため、正しい順序ではありません。</p>
<p>何らかの理由で、妖精は印刷される各更新の<strong>中央のページ番号</strong>も知る必要があります。
現在は正しい順序の更新のみを印刷しているため、正しい順序の各更新の中央のページ番号を見つける必要があります。
前述の例では、正しい順序の更新は次のとおりです:</p>
<pre><code>75,47,61,53,29
97,61,53,29,13
75,29,13
</code></pre>
<p>これらの中央のページ番号はそれぞれ 61, 53, 29 です。
これらのページ番号を合計すると143になります。</p>
<p>もちろん、注意が必要です。
実際の<strong>ページ順序付けルール</strong>のリストは、上記の例よりも大きく複雑です。</p>
<p>どの更新が既に正しい順序になっているかを判定します。
正しい順序の更新の中央のページ番号を合計するといくつになりますか？</p>
<h1 id="パート2-49"><a class="header" href="#パート2-49">パート2</a></h1>
<p>小人が正しい順序の更新を印刷する作業を開始している間に、残りの更新を修正する時間が少しあります。</p>
<p><strong>順序が正しくない更新</strong>それぞれについて、ページ順序ルールを使用してページ番号を正しい順序に配置します。
上の例について、順序が正しくない3つの更新とその正しい順序を次に示します：</p>
<ul>
<li><code>75,97,47,61,53</code> は <code>97,75,47,61,53</code> になります。</li>
<li><code>61,13,29</code> は <code>61,29,13</code> になります。</li>
<li><code>97,13,75,29,47</code> は <code>97,75,47,29,13</code> になります。</li>
</ul>
<p><strong>誤った順序の更新</strong>のみを選び、それらを正しく順序付けると、それらの中央のページ番号は 47, 29, 47 になります。
これらを合計すると、123になります。</p>
<p>正しい順序ではない更新を見つけます。
それらの更新だけを正しく順序付けた後、中央のページ番号を合計するといくつになりますか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6日目守衛の闊歩"><a class="header" href="#6日目守衛の闊歩">6日目：守衛の闊歩</a></h1>
<p>歴史学者たちがまたも珍妙な<a href="2024/./day4.html">装置</a>を使い、
今度は北極試作スーツ製造ラボへ飛ばされてしまいました。それも<a href="2024/../2018/day5.html">1518年</a>の！
歴史に直接アクセスできることは、歴史学者たちにとっては非常に便利だとわかりました。</p>
<p>タイム・パラドックスに気をつけなければならないのは変わらないので、
歴史学者たちが主任を捜している間、1518年の人間を避けることが重要です。
不運なことに、ラボのこの一角には<strong>守衛</strong>が一人巡視しています。</p>
<p>歴史学者たちが安全に捜索できるように、守衛が行く場所を前もって調べておきませんか？</p>
<p>まず、状況の地図（あなたのパズル入力）を作ることから始めます。例えば：</p>
<pre><code>....#.....
.........#
..........
..#.......
.......#..
..........
.#..^.....
........#.
#.........
......#...
</code></pre>
<p>この地図には、守衛の現在の位置が <code>^</code> で表示されています。
（地図の視点から見て、守衛は現在<strong>上</strong>を向いていることを文字で示しています。）
木箱、机、錬金術の釜などの<strong>障害物</strong>は <code>#</code> で表しています。</p>
<p>1518年のラボの守衛は、以下の手順に繰り返し従うという非常に厳格な巡視プロトコルに従っています：</p>
<ul>
<li>正面の目の前に何かあれば、右に90度曲がる。</li>
<li>そうでなければ、一歩前進する。</li>
</ul>
<p>上記の手順に従い、警備員は障害物（この場合は失敗したスーツの試作品の山）に到達するまで何度か上に移動します：</p>
<pre><code>....#.....
....^....#
..........
..#.......
.......#..
..........
.#........
........#.
#.........
......#...
</code></pre>
<p>守衛の眼前に障害物があるため、右を向いてから新しい方向へ直進します：</p>
<pre><code>....#.....
........&gt;#
..........
..#.......
.......#..
..........
.#........
........#.
#.........
......#...
</code></pre>
<p>別の障害物（非常に<strong>長い</strong>化学繊維の糸が何本も巻かれた糸巻き）にさしかかると、
再び右に曲がり、下へと進みます：</p>
<pre><code>....#.....
.........#
..........
..#.......
.......#..
..........
.#......v.
........#.
#.........
......#...
</code></pre>
<p>この手順がしばらく続き、守衛はやがて（万能溶剤のタンクを通り過ぎた後）地図の範囲から外れます：</p>
<pre><code>....#.....
.........#
..........
..#.......
.......#..
..........
.#........
........#.
#.........
......#v..
</code></pre>
<p>守衛の経路を予測することで、ラボ内のどのマスが巡視経路に入っているかを判定できます。
守衛の出発地点を含め、範囲から外れる前に守衛が訪れる位置を<code>X</code>で印つけます：</p>
<pre><code>....#.....
....XXXXX#
....X...X.
..#.X...X.
..XXXXX#X.
..X.X.X.X.
.#XXXXXXX.
.XXXXXXX#.
#XXXXXXX..
......#X..
</code></pre>
<p>この例では、守衛は地図上の41のマスを訪れます。</p>
<p>守衛の巡回経路を予測してください。
守衛は、地図上の範囲から外れるまでに、いくつのマスを訪れるでしょうか？</p>
<h1 id="パート2-50"><a class="header" href="#パート2-50">パート2</a></h1>
<p>歴史学者たちが守衛の巡視経路を避けはじめたとき、あなたは彼らの珍妙な装置を借りて研究室の外に出ました。
安全な貯蔵庫の中から、直近の過去数ヶ月をタイムトラベルし、
毎晩の研究所の守衛の巡回区域の状況を倉庫の壁に<a href="2024/../2018/day4.html">記録</a>しました。</p>
<p>さっきのほんの数秒後の時点へ戻ると、歴史学者たちが、
守衛の巡回区域が広すぎて、捕まることなく安全にラボを捜索することができないと説明しました。</p>
<p>幸いなことに、新たな障害物をひとつ加えるだけでは、タイムパラドックスを引き起こすことは<strong>ない</strong>と彼らは<strong>確信して</strong>います。
新しい障害物を、守衛が<strong>ループにはまり込んでしまう</strong>形で配置し、
ラボの残りの部分を安全に捜索できるようにしたいと考えています。</p>
<p>タイムパラドックスを引き起こす可能性を最も低くするために、
歴史学者たちはそのような障害物の可能な位置を<strong>全て</strong>知りたいと考えています。</p>
<p>新しい障害物は守衛の出発地点には置けません。
守衛は今そこにいて、気づいてしまうでしょう。</p>
<p>上の例では、新しい障害物があると守衛がループにはまり込んでしまう位置は<strong>6つ</strong>だけあります。
これらの6つの状況の図は、<code>O</code> で新しい障害物、<code>|</code> で守衛が上下に動く位置、
<code>-</code> で守衛が左右に動く位置、<code>+</code> で守衛が上下左右両方に動く位置を示しています。</p>
<p>候補1、守衛の出発地点の横に印刷機を置く：</p>
<pre><code>....#.....
....+---+#
....|...|.
..#.|...|.
....|..#|.
....|...|.
.#.O^---+.
........#.
#.........
......#...
</code></pre>
<p>候補2、失敗したスーツのプロトタイプの山を地図領域の右下の象限に置く：</p>
<pre><code>....#.....
....+---+#
....|...|.
..#.|...|.
..+-+-+#|.
..|.|.|.|.
.#+-^-+-+.
......O.#.
#.........
......#...
</code></pre>
<p>候補3、右下の象限にある立ち机の横に、煙突絞り構造の試作品の木箱を置く：</p>
<pre><code>....#.....
....+---+#
....|...|.
..#.|...|.
..+-+-+#|.
..|.|.|.|.
.#+-^-+-+.
.+----+O#.
#+----+...
......#...
</code></pre>
<p>候補4、左下隅に錬金術の<a href="https://retroencabulator.com/">無限エネルギー装置</a> (retroencabulator 前はテムレイサーキットと超訳した)を置く：</p>
<pre><code>....#.....
....+---+#
....|...|.
..#.|...|.
..+-+-+#|.
..|.|.|.|.
.#+-^-+-+.
..|...|.#.
#O+---+...
......#...
</code></pre>
<p>候補5：錬金術無限エネルギー装置をもう少し右に置く：</p>
<pre><code>....#.....
....+---+#
....|...|.
..#.|...|.
..+-+-+#|.
..|.|.|.|.
.#+-^-+-+.
....|.|.#.
#..O+-+...
......#...
</code></pre>
<p>Option six, put a tank of sovereign glue right next to the tank of universal solvent:</p>
<p>候補6、万能溶剤のタンクのすぐ隣に<a href="https://www.dndbeyond.com/magic-items/4756-sovereign-glue">ソベリン・グルー</a> (<a href="https://wikiwiki.jp/classicdnd/%E3%81%9D%E3%81%AE%E4%BB%96%E3%81%AE%E9%AD%94%E6%B3%95%E3%81%AE%E3%82%A2%E3%82%A4%E3%83%86%E3%83%A0/%E3%80%90%E3%82%BD%E3%83%B4%E3%83%AA%E3%83%B3%E3%83%BB%E3%82%B0%E3%83%AB%E3%83%BC%E3%80%91">強力接着剤</a>)のタンクを置く：</p>
<pre><code>....#.....
....+---+#
....|...|.
..#.|...|.
..+-+-+#|.
..|.|.|.|.
.#+-^-+-+.
.+----++#.
#+----++..
......#O..
</code></pre>
<p>守衛に気づかれずに、あなたと歴史学者たちが障害物を設置することができるならば、
何を障害物として選ぶかは特に意味はありません。
重要なのは、タイムパラドックスを最小にするものを見つけられるだけの選択肢を持つことで、
この例では6つの異なる位置を選ぶことができます。</p>
<p>新しい障害物をひとつだけ加えることで、守衛をループにはまり込ませる必要があります。
この障害物を置く位置の選択肢はいくつありますか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7日目-橋の修理"><a class="header" href="#7日目-橋の修理">7日目: 橋の修理</a></h1>
<p>歴史学者たちは、ジャングルの真ん中にある川にかかるお馴染みの<a href="2024/../2022/day9.html">吊り橋</a>へあなたを連れて行きます。
しかし、橋のこちら側には主任はいません。
もしかしたら、向こう側にいるのかもしれません。</p>
<p>橋を渡ろうとすると、修理しようとしているエンジニアの一団がいるのに気づきました。
（どうやら、わりと頻繁に壊れるようです。）
修理が終わるまで渡ることはできません。</p>
<p>あなたはどれくらいの時間がかかるか尋ねます。
エンジニアたちは、残っている作業は最終的な校正だけだと言いますが、
近くで遊んでいた若い象たちに校正方程式の演算子を全部盗まれていました！
校正を終わらせるには、
校正方程式（あなたのパズル入力）に何らかの演算子の組み合わせを当てはめることで
算出できる校正値がどれかを特定する必要があります。</p>
<p>例えば：</p>
<pre><code>190: 10 19
3267: 81 40 27
83: 17 5
156: 15 6
7290: 6 8 6 15
161011: 16 10 13
192: 17 8 14
21037: 9 7 18 13
292: 11 6 16 20
</code></pre>
<p>各行はひとつの方程式を表しています。
校正値は各行のコロンの前にあります。
残りの数値に演算子と組み合わせて校正値を算出できるかどうかを判断するのがあなたの仕事です。</p>
<p>演算子は<strong>常に左から右に</strong>評価されます。優先順位の規則には<strong>従いません</strong>。
さらに、方程式内の数値は並べ替えてはいけません。
ジャングルをちらりと見ると、<strong>足し算</strong> $(+)$ と<strong>掛け算</strong> $(\times)$ の2種類の異なる演算子を持つ象が
見えました。（訳註：見分け付くかな…）</p>
<p>上記の方程式のうち、演算子を挿入することで真にできるのは3つだけです：</p>
<ul>
<li><code>190: 10 19</code> には演算子の入る位置が1つだけあります：10と19の間です。
$+$ を選ぶと29になりますが、 $\times$ を選ぶと校正値 $(10 \times 19 = 190)$ になります。</li>
<li><code>3267: 81 40 27</code> には演算子の位置が2つあります。
演算子の4つの可能な構成のうち、<strong>2つ</strong>が右辺を校正値と一致させます：
（左から右に評価した場合） $81 + 40 \times 27$ と $81 \times 40 + 27$ はどちらも3267に等しいです！</li>
<li><code>292: 11 6 16 20</code> は正しくできる方法が1つだけあります： $11 + 6 \times 16 + 20$</li>
</ul>
<p>エンジニアたちは、真である可能性のある方程式の校正値の合計である<strong>総合校正結果</strong>が必要です。
上記の例では、上記の3つの方程式の校正値の合計は3749です。</p>
<p>どの方程式が真である可能性があるかを判断してください。それらの総合校正結果はいくつですか？</p>
<h1 id="パート2-51"><a class="header" href="#パート2-51">パート2</a></h1>
<p>エンジニアたちの表情は不安げです。
あなたが彼らに与えた総合校正結果は、安全許容範囲内から完全に外れています。
ちょうどそのとき、あなたは自分の間違いに気づきました：
隠れるのが上手な象たちが3つめの種類の演算子を持っています。</p>
<p>連結演算子 $(‖)$ は、左側と右側から与えられた数値を単一の数に結合します。
例えば $12 ‖ 345$ は12345になります。
全ての演算子はやはり左から右に評価されます。</p>
<p>さて、加算と乗算だけを使用して真にできる3つの方程式に加えて、
上記の例には演算子を挿入することで真にできる方程式がもう3つあります：</p>
<ul>
<li><code>156: 15 6</code> は連結ひとつで真にできます： $15 ‖ 6 = 156$</li>
<li><code>7290: 6 8 6 15</code> は $6 \times 8 ‖ 6 \times 15$ として真にできます。</li>
<li><code>192: 17 8 14</code> は $17 ‖ 8 + 14$ として真にできます。</li>
</ul>
<p>6つ全ての校正値（ $+$ と $\times$ のみを用いて真にできた3つと、 $‖$ も使うことで新たに真にできる3つ）
を合計すると、新しい<strong>総合校正結果は11387</strong>になります。</p>
<p>あなたの新しい象の隠れんぼスポットの知識を使って、
どの方程式が真である可能性があるかを判断してください。
それらの総合校正結果はいくつですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第8日-同一直線上での共鳴"><a class="header" href="#第8日-同一直線上での共鳴">第8日: 同一直線上での共鳴</a></h1>
<!-- Resonant Collinearity 共鳴する共線性 Kagi translate すごいな -->
<p>あなたは、極秘のイースターバニー施設の<a href="2024/../2016/day25.html">屋上</a>に出ました。</p>
<p>歴史学者たちが自分の仕事をしている間、あなたはおなじみの<strong>巨大アンテナ</strong>を見てみます。
驚くべきことにそれは、人々がクリスマスギフトとして
イースターバニー印のパチもん二流チョコレートを購入する可能性を0.1%高める信号を
発信するように再調整されているようです！考えられない！</p>
<p>都市をスキャンすると、実際にそのようなアンテナがたくさんあることがわかりました。
各アンテナは、単一の小文字アルファベット、大文字アルファベット、または数字で示される特定の<strong>周波数</strong>に設定されています。
あなたはこれらのアンテナの地図（あなたのパズル入力）を作成しました。例えば：</p>
<pre><code>............
........0...
.....0......
.......0....
....0.......
......A.....
............
............
........A...
.........A..
............
............
</code></pre>
<p>信号は、アンテナの共振周波数に基づいて特定の<strong>波腹</strong>でのみその悪影響を及ぼします。
（補足：antinode n. 【物理】 波腹《二つの波節 （node） の中間部》[株式会社研究社 新英和大辞典第6版]
ただしこの問題の内容は物理現象とはあまり関係がない。）
特に、波腹は、同じ周波数の2つのアンテナと完全に一直線上にある任意の点で発生しますが、
片方のアンテナがもう片方のアンテナの2倍の距離にあるときに限ります。
これは、同じ周波数の任意のペアのアンテナに対して、2つの波腹がそれぞれの側に1つずつ存在することを意味します。</p>
<p>したがって、周波数 <code>a</code> のこれら2つのアンテナは、 <code>#</code> で示す2つの波腹を生成します。</p>
<pre><code>..........
...#......
..........
....a.....
..........
.....a....
..........
......#...
..........
..........
</code></pre>
<p>同じ周波数の第3のアンテナを追加すると、さらにいくつかの波腹が生成されます。
理論上は波腹が4つ増えるはずですが、2つは地図の右側から外れているため、2つだけが追加されます：</p>
<pre><code>..........
...#......
#.........
....a.....
........a.
.....a....
..#.......
......#...
..........
..........
</code></pre>
<p>異なる周波数のアンテナ対は波腹を生成しません。
<code>A</code> と<code>a</code> は異なる周波数と解釈します。
ただし、アンテナが存在する場所に波腹が発生することは<strong>あります</strong>。
下の図では、唯一の周波数大文字 <code>A</code> のアンテナは波腹を生成しませんが、
その位置には周波数小文字 <code>a</code> の波腹があります。</p>
<pre><code>..........
...#......
#.........
....a.....
........a.
.....a....
..#.......
......A...
..........
..........
</code></pre>
<p>最初の例では、2つの異なる周波数を持つアンテナがあるため、
それらが作る波腹は次のように見えます。
加えて、最上部の周波数 <code>A</code> のアンテナと重なる波腹があります。</p>
<pre><code>......#....#
...#....0...
....#0....#.
..#....0....
....0....#..
.#....A.....
...#........
#......#....
........A...
.........A..
..........#.
..........#.
</code></pre>
<p>最上部の周波数 <code>A</code> のアンテナが周波数 <code>0</code> の波腹と重なるため、
地図の範囲内で波腹の発生する位置は合計14か所になります。</p>
<p>信号の影響を計算してください。
地図の範囲内で波腹の発生する位置はいくつありますか？</p>
<h1 id="パート2-52"><a class="header" href="#パート2-52">パート2</a></h1>
<p>作業を肩越しに見守っていた歴史学者の一人が、倍音共鳴の影響を計算に入れたかと尋ねました。</p>
<p>てへっ！</p>
<p>モデルを更新したところ、波腹は、同じ周波数の少なくとも2つのアンテナと完全に一直線上にある<strong>任意の格子点</strong>に、
距離は関係なしに発生することがわかりました。
これは、新しい波腹のいくつかが各アンテナの位置で発生することを意味します
（そのアンテナがその周波数の唯一のものでない限り）。</p>
<p>したがって、下図の周波数 <code>T</code> の3つのアンテナは現在、多くの波腹を生成します：</p>
<pre><code>T....#....
...T......
.T....#...
.........#
..#.......
..........
...#......
..........
....#.....
..........
</code></pre>
<p>実際には、3つの周波数 <code>T</code> のアンテナ（自身の位置）は全て、
2つのアンテナと正確に一直線上にあるため、そこまた全て波腹です！
これにより、上記の例の波腹の総数は9個になります。</p>
<p>元の例には、全てのアンテナに現れるものを含めて、現在34の波腹があります：</p>
<pre><code>##....#....#
.#.#....0...
..#.#0....#.
..##...0....
....0....#..
.#...#A....#
...#..#.....
#....#.#....
..#.....A...
....#....A..
.#........#.
...#......##
</code></pre>
<p>更新されたモデルを使用して信号の影響を計算してください。
地図の範囲内で波腹の発生する位置はいくつありますか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="9日目-ディスク断片化"><a class="header" href="#9日目-ディスク断片化">9日目: ディスク断片化</a></h1>
<p>ボタンをもう一度押すと、あなたは友好的な<a href="2024/../2021/day23.html">ヨコエビ</a>たちの馴染みのある廊下へ飛びました！
それぞれがどうにか自分用のミニ潜水艦を手に入れたのは良いことです。
歴史学者たちは、主任を探しに壁に直接突っ込むことで飛び去ります。</p>
<p>歴史学者たちが潜水艦を操縦する方法をすぐに理解した一方で、
あなたは隅でコンピュータと格闘しているヨコエビに気づきます。
彼は全てのファイルを密集させることでより連続した空き領域を作ろうとしていますが、
彼のプログラムはうまくいっていません。あなたは手伝うことを申し出ます。</p>
<p>彼は生成済みの<strong>ディスクマップ</strong>（あなたのパズル入力）を見せてくれます。例えば：</p>
<pre><code>2333133121414131402
</code></pre>
<p>ディスクマップは、ディスク上の<strong>ファイル</strong>と<strong>空き領域</strong>の配置を表現するために密な形式を使用します。
数字は、ファイルの長さと空き領域の長さを交互に示します。</p>
<p>したがって、<code>12345</code> のようなディスクマップは、1ブロックのファイル、2ブロックの空き領域、
3ブロックのファイル、4ブロックの空き領域、そして5ブロックのファイルを表します。
<code>90909</code> のようなディスクマップは、間に空きがない3つの9ブロックファイルの連続を表します。</p>
<p>ディスク上の各ファイルには、再配置される前のファイルの出現順に基づいた<strong>ID番号</strong>があります。
ID 0から始まります。
したがって、ディスクマップ <code>12345</code> には、ID 0の1ブロックファイル、ID 1の3ブロックファイル、
ID 2の5ブロックファイルの3つのファイルがあります。
各ブロックに1文字を使用し、ブロックに対して数字でファイルID、<code>.</code> で空き領域を表すと、
ディスクマップ <code>12345</code> はこれらの個々のブロックを表します：</p>
<pre><code>0..111....22222
</code></pre>
<p>上記の最初の例、<code>2333133121414131402</code> は、これらの個々のブロックを表しています：</p>
<pre><code>00...111...2...333.44.5555.6666.777.888899
</code></pre>
<p>ヨコエビは、ディスクの終端から順に、最も左の空きブロックに<code>ファイルを一度に1ブロックずつ</code>移動したいと考えています
（ファイルブロックの間に隙間がなくなるまで）。
ディスクマップ <code>12345</code> の場合、プロセスは次のようになります：</p>
<pre><code>0..111....22222
02.111....2222.
022111....222..
0221112...22...
02211122..2....
022111222......
</code></pre>
<p>最初の例はもう少し手順が必要です:</p>
<pre><code>00...111...2...333.44.5555.6666.777.888899
009..111...2...333.44.5555.6666.777.88889.
0099.111...2...333.44.5555.6666.777.8888..
00998111...2...333.44.5555.6666.777.888...
009981118..2...333.44.5555.6666.777.88....
0099811188.2...333.44.5555.6666.777.8.....
009981118882...333.44.5555.6666.777.......
0099811188827..333.44.5555.6666.77........
00998111888277.333.44.5555.6666.7.........
009981118882777333.44.5555.6666...........
009981118882777333644.5555.666............
00998111888277733364465555.66.............
0099811188827773336446555566..............
</code></pre>
<p>このファイル密集化プロセスの最終ステップは、<strong>ファイルシステムのチェックサム</strong>を更新することです。
チェックサムを計算するには、これらのブロックの位置を、それが含むファイルID番号で掛け算した結果を合計します。
最も左のブロックは位置0にあります。ブロックが空き領域である場合は計算を飛ばします。</p>
<p>最初の例を続けると、最初のいくつかのブロックの位置にそのファイルID番号を掛けた結果は
$0 \times 0 = 0, 1 \times 0 = 0, 2 \times 9 = 18, 3 \times 9 = 27, 4 \times 8 = 32, \dots$
というようになります。
この例では、チェックサムはこれらの合計の1928です。</p>
<p>ヨコエビのハードドライブを彼が望む手順を使用して密集化してください。
結果として得られるファイルシステムのチェックサムはいくつですか？
（このパズルの入力をコピー/ペーストする際は注意してください。それは非常に長い1行です。）</p>
<h1 id="パート2-53"><a class="header" href="#パート2-53">パート2</a></h1>
<p>完了すると、2つのことがすぐに明らかになりました。
まず、ディスクには確かに連続した空き領域がずっと多くあります。これはヨコエビが期待していた通りです。
次に、コンピュータの動作がずっと遅くなっています！
ファイルシステムの断片化を招くのは悪いアイデアだったのかも？</p>
<p>熱心なヨコエビは既に新しい計画を持っています：
個々のブロックを移動するのではなく、
彼はディスク上の<strong>ファイルを分けずにまるごと</strong>移動することでファイルを密集化してみたいと考えています。</p>
<p>今回は、ファイルをそれが収まるような最も左の空き領域ブロックに移動させることを試みます。
ファイルID番号が高いファイルから順に、ID番号の降順に、それぞれのファイルを一度だけ移動させることを試みます。
ファイルの左側にそのファイルを収容できる空き領域がない場合、そのファイルは移動しません。</p>
<p>上記の最初の例は、今は異なる進行をします：</p>
<pre><code>00...111...2...333.44.5555.6666.777.888899
0099.111...2...333.44.5555.6666.777.8888..
0099.1117772...333.44.5555.6666.....8888..
0099.111777244.333....5555.6666.....8888..
00992111777.44.333....5555.6666.....8888..
</code></pre>
<p>ファイルシステムのチェックサムを更新するプロセスは同じです。
今回、この例のチェックサムは2858になります。</p>
<p>最初からやり直し、この新しい方法を使ってヨコエビのハードドライブを密集化します。
結果として得られるファイルシステムのチェックサムはいくつですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10日目-歩いてゆこう"><a class="header" href="#10日目-歩いてゆこう">10日目: 歩いてゆこう</a></h1>
<p>あなたたちは空に浮かぶ島にある<a href="2024/../2023/day15.html">溶岩生産施設</a>に到着します。
他の人たちが巨大な工業複合施設を探し始めると、あなたは小さな鼻が足にぶつかるのを感じ、
下を見るとヘルメットをかぶったトナカイを見つけました。</p>
<p>トナカイは「溶岩島ハイキングガイド」という題の本を持っています。
しかし、本を開くと、そのほとんどが溶岩によって焦げていることに気づきます！
あなたがどのように手助けできるか尋ねようとしたとき、
トナカイは周囲の地域の空白の<a href="https://ja.wikipedia.org/wiki/%E5%9C%B0%E5%BD%A2%E5%9B%B3">地形図</a>（あなたのパズル入力）を持ってきて、興奮してあなたを見上げます。</p>
<p>おそらく、欠けているハイキングコースを書き込む手助けができるかもしれません。</p>
<p>地形図は、各位置の<strong>標高</strong>を<code>0</code>（最低）から<code>9</code>（最高）までのスケールで示しています。例えば：</p>
<pre><code>0123
1234
8765
9876
</code></pre>
<p>焼かれていない本の切れ端に基づいて、良いハイキングコースとは<strong>できるだけ長く</strong>
<strong>均一で徐々に上昇する傾斜を持つ</strong>ものであると判断しました。
実践的な目的のために、<strong>ハイキングコース</strong>は高さ<code>0</code>から始まり高さ<code>9</code>で終わり、
各ステップで高さがちょうど1増加する任意の経路を意味します。
ハイキングコースには斜めの移動は許されず、地図の視点から見て上、下、左、右のみです。</p>
<p>地図から目を上げると、親切にもトナカイが地図にハイキングコースを更新するために必要な鉛筆、
マーカー、定規、コンパス、ステッカーなどの小さな山を作り始めたことに気づきます。</p>
<p><strong>登山口</strong>とは、ひとつ以上のハイキングコースが始まる位置のことです。
ここではこれらの位置は常に高さ <code>0</code> になります。
ページの断片をさらに組み立てることで、登山口の<strong>スコア</strong>は、
その登山口からハイキングコースを通じて到達可能な高さ<code>9</code>の位置の個数であることがわかりました。
上の例では、左上隅にある唯一の登山口は、左下にある唯一の <code>9</code> に到達できるため、スコアは1です。</p>
<p>この登山口はスコア2です：</p>
<pre><code>...0...
...1...
...2...
6543456
7.....7
8.....8
9.....9
</code></pre>
<p>（<code>.</code> で記された位置は、これらの例を簡略化するための通行不可のタイルです。
実際の地形図には現れません。）</p>
<p>この登山口のスコアは4です。
なぜなら、登山口のすぐ左にあるものを除いて、全ての9にハイキングコースで到達できるからです：</p>
<pre><code>..90..9
...1.98
...2..7
6543456
765.987
876....
987....
</code></pre>
<p>この地形図には<strong>ふたつ</strong>の登山口があります。
最上部の登山口はスコア1、最下部の登山口はスコア2です：</p>
<pre><code>10..9..
2...8..
3...7..
4567654
...8..3
...9..2
.....01
</code></pre>
<p>大きな例を示す：</p>
<pre><code>89010123
78121874
87430965
96549874
45678903
32019012
01329801
10456732
</code></pre>
<p>この大きな例には9つの登山口があります。
登山口を読み取り順に考えて、それぞれのスコアは 5, 6, 5, 3, 1, 3, 5, 3, 5 です。
これらのスコアを合計すると、全ての登山口のスコアの合計は36になります。</p>
<p>トナカイは大はしゃぎで分度器を持ってきて、それを文具の山に加えます。
あなたの地形図上の全ての登山口のスコアの合計はいくつですか？</p>
<h1 id="パート2-54"><a class="header" href="#パート2-54">パート2</a></h1>
<p>トナカイは、ハイキングコースの地図を数分間見直した後、何かに気づき、
数分間姿を消し、最後にもう一枚の少し焦げた紙を持って戻ってきます。</p>
<p>その紙には、登山口を評価する第二の方法として<strong>評価</strong>が記載されています。
登山口の評価は、その登山口から始まる<strong>異なるハイキングコースの個数</strong>です。例えば：</p>
<pre><code>.....0.
..4321.
..5..2.
..6543.
..7..4.
..8765.
..9....
</code></pre>
<p>上の地図には登山口がひとつあります。その評価は3です。
なぜなら、その位置から始まる異なるハイキングトレイルがちょうど3つあるからです：</p>
<pre><code>.....0.   .....0.   .....0.
..4321.   .....1.   .....1.
..5....   .....2.   .....2.
..6....   ..6543.   .....3.
..7....   ..7....   .....4.
..8....   ..8....   ..8765.
..9....   ..9....   ..9....
</code></pre>
<p>評価13の登山口ひとつを持つ地図を示します：</p>
<pre><code>..90..9
...1.98
...2..7
6543456
765.987
876....
987....
</code></pre>
<p>この地図には、評価227の単一の登山口があります。
（右端の<code>9</code>に向かう121の異なるハイキングコースと、下端の<code>9</code>に向かう106のコースがあります）：</p>
<pre><code>012345
123456
234567
345678
4.6789
56789.
</code></pre>
<p>前に示した大きな例はこちらです：</p>
<pre><code>89010123
78121874
87430965
96549874
45678903
32019012
01329801
10456732
</code></pre>
<p>登山口を読み取り順に考えて、それらの評価は 20, 24, 10, 4, 1, 4, 5, 8, 5です。
この大きな例の地形図における全ての登山口の評価の合計は81です。</p>
<p>どういうわけか分かりませんが、トナカイは爪楊枝と紙の切れ端で小さな旗を作り、
それを使ってあなたの地形図上の登山口に印をつけています。
全ての登山口の評価の合計はいくつですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11日目-冥王星の小石"><a class="header" href="#11日目-冥王星の小石">11日目: 冥王星の小石</a></h1>
<p><a href="2024/../2019/day20.html">冥王星</a>の古代文明は時空を操る能力で知られており、
歴史学者たちが無限の廊下を探検している間、
あなたは物理法則を無視する奇妙な石の集まりに気づきました。</p>
<p>一見すると、それらは普通の石のように見えます：
完璧な<strong>一直線状</strong>に並べられており、それぞれの石には<strong>数</strong>が刻まれています。</p>
<p>奇妙な点は、あなたがまばたきをするたびに石が<strong>変化する</strong>ことです。</p>
<p>時には、石に刻まれた数字が変わります。
またある時には、石が<strong>二つに分かれ</strong>、他の全ての石がその完璧な一直線に場所を作るために少しずつ移動します。</p>
<p>しばらく観察していると、石が一貫した挙動を示すことがわかりました。
あなたがまばたきをするたびに、石は以下のリストの<strong>最初に当てはまる</strong>規則に従って<strong>同時に</strong>変化します：</p>
<ul>
<li>石に刻まれた数が0の場合、それは1と刻まれた石に置き換えられます。</li>
<li>石に<strong>偶数</strong>桁の数が刻まれている場合、それは<strong>二つの石</strong>に置き換えられます。
左半分の桁は新しい左の石に刻まれ、右半分の桁は新しい右の石に刻まれます。
（新しい数は余分な先頭の零を持ちません。1000は石10と0になります。）</li>
<li>他の規則が適用されない場合、石は新しい石に置き換えられます。
古い石の数に2024を掛けたものが新しい石に刻まれます。</li>
</ul>
<p>石がどのように変わっても、<strong>その順序は保持され</strong>、完璧な一直線をなします。<!-- ひっかけ --></p>
<p>あなたがまばたきをし続けると、石列はどのような展開をするでしょうか？
あなたは列のそれぞれの石に刻まれた数字をメモします（あなたのパズル入力）。</p>
<p>数 <code>0 1 10 99 999</code> が刻まれた5つの石の配置があるとき、1回まばたきをすると、石は次のように変化します：</p>
<ul>
<li>最初の石、0は1と刻まれた石になります。</li>
<li>2番目の石、1は2024倍されて2024になります。</li>
<li>3番目の石、10は1と刻まれた石と0と刻まれた石に分かれます。</li>
<li>4番目の石、99は2つの9と刻まれた石に分かれます。</li>
<li>5番目の石、999は2021976と刻まれた石に置き換えられます。</li>
</ul>
<p>したがって、1回まばたきをした後、あなたの5つの石は <code>1 2024 1 0 9 9 2021976</code> という7つの石の配置になります。</p>
<p>こちらは長い例です：</p>
<pre><code>初期配置:
125 17

1回まばたき後:
253000 1 7

2回まばたき後:
253 0 2024 14168

3回まばたき後:
512072 1 20 24 28676032

4回まばたき後:
512 72 2024 2 0 2 4 2867 6032

5回まばたき後:
1036288 7 2 20 24 4048 1 4048 8096 28 67 60 32

6回まばたき後:
2097446912 14168 4048 2 0 2 4 40 48 2024 40 48 80 96 2 8 6 7 6 0 3 2
</code></pre>
<p>この例では、6回まばたきをした後、22個の石があります。
25回まばたきをした後、55312個の石があるでしょう！</p>
<p>目の前の石の配置を考えてみてください。
25回まばたきをした後、いくつの石があるでしょうか？</p>
<h1 id="パート2-55"><a class="header" href="#パート2-55">パート2</a></h1>
<p>歴史学者たちは本当に時間がかかっています。
公平のために言えば、無限の廊下は非常に広い<strong>です</strong>。</p>
<p>合計75回まばたきをした後、いくつの石がありますか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12日目-ガーデングループ"><a class="header" href="#12日目-ガーデングループ">12日目: ガーデングループ</a></h1>
<p><a href="2024/../2023/day5.html">庭師</a>と彼の<a href="2024/../2023/day21.html">広大な農場</a>の近くで主任歴史学者を探してみませんか？
食べ物はたくさんあるので、歴史学者たちは探しがてら何かを食べています。</p>
<p>あなたは複雑な庭の区画の近くに落ち着こうとしていると、小人たちが手を貸してくれないかと尋ねてきます。
彼らは庭の区画のそれぞれの周りに柵を設置したいのですが、どれだけの柵を注文する必要があるのか、
またその費用がどれくらいになるのかがわかりません。
彼らはあなたに庭の区画の地図（あなたのパズルの入力）を渡します。</p>
<p>庭のそれぞれの区画は単一の種類の植物のみを育てており、地図上では1文字で示されています。
庭の複数の区画が同じ種類の植物を育てていて、（水平または垂直に）接触している場合、それらは<strong>領域</strong>を成します。
例えば：</p>
<pre><code>AAAA
BBCD
BBCC
EEEC
</code></pre>
<p>この4x4の配置には、（A, B, C, D, Eとラベル付けされた）5種類の植物を育てる庭の区画が含まれており、
それぞれが独自の領域に集まっています。</p>
<p>ある領域の柵のコストを正確に計算するためには、その領域の<strong>面積</strong>と<strong>周囲の長さ</strong>を知る必要があります。</p>
<p>領域の<strong>面積</strong>は、その領域に含まれる庭の区画の数です。
上の地図の種類 A, B, C の植物はそれぞれ面積4の領域にあります。
種類 E の植物は面積3の領域にあり、種類 D の植物は面積1の領域にあります。</p>
<p>庭の区画はどれも正方形であり、したがって<strong>4つの辺</strong>があります。
領域の<strong>周囲の長さ</strong>は、庭の区画の辺で、その領域内の他の区画と接していないものの数です。
種類 A および C の植物は、それぞれ周長が 10 の領域にあります。
種類 B および E の植物は、それぞれ周長が 8 の領域にあります。
孤立した D の区画はそれ自身で領域をなし、周長は 4 です。</p>
<p>上記の地図の領域の周囲は、次のように <code>-</code> と <code>|</code> を用いて、
各領域の区画の辺を視覚的に示すことによって、測定されます：</p>
<pre><code>+-+-+-+-+
|A A A A|
+-+-+-+-+     +-+
              |D|
+-+-+   +-+   +-+
|B B|   |C|
+   +   + +-+
|B B|   |C C|
+-+-+   +-+ +
          |C|
+-+-+-+   +-+
|E E E|
+-+-+-+
</code></pre>
<p>同じ種類の植物は複数の別々の領域に現れることがあり、領域は他の領域の中に現れることさえあります。
例えば：</p>
<pre><code>OOOOO
OXOXO
OOOOO
OXOXO
OOOOO
</code></pre>
<p>上の地図には<strong>5つ</strong>の領域が含まれており、そのうちの1つは全てのO型庭の区画を含み、
他の4つはそれぞれ単一のX型区画を含んでいます。</p>
<p>4つのX領域はそれぞれ面積1、周長4を持っています。
21個のO型植物を含む領域はより複雑です。
外側の縁が周長に20寄与するだけでなく、
個々のX領域との境界が周長にさらに4を加え、周長は合計36になります。</p>
<p>「現代的な」商慣行のため、領域に必要な柵の価格は、その領域の面積に周長を<strong>掛ける</strong>ことで求められます。
地図上の全ての領域の柵の<strong>総価格</strong>は、地図上の全ての領域の柵の価格を合計することで求められます。</p>
<p>最初の例では、領域 A の価格は $4 \times 10 = 40$、
領域 B の価格は $4 \times 8 = 32$、領域 C の価格は $4 \times 10 = 40$、
領域 D の価格は $1 \times 4 = 4$、領域 E の価格は $3 \times 8 = 24$ です。
したがって、最初の例の総価格は140です。</p>
<p>2番目の例では、全てのO植物がある領域の価格は $21 \times 36 = 756$ で、
4つの小さな X 領域のそれぞれの価格は $1 \times 4 = 4$ で、
総価格は 772 $(756 + 4 + 4 + 4 + 4)$ です。</p>
<p>こちらはより大きな例です：</p>
<pre><code>RRRRIICCFF
RRRRIICCCF
VVRRRCCFFF
VVRCCCJFFF
VVVVCJJCFE
VVIVCCJJEE
VVIIICJJEE
MIIIIIJJEE
MIIISIJEEE
MMMISSJEEE
</code></pre>
<p>内訳は次の通りです：</p>
<ul>
<li>R 植物の領域の価格は $12 \times 18 = 216$</li>
<li>I 植物の領域の価格は $4 \times 8 = 32$</li>
<li>C 植物の領域の価格は $14 \times 28 = 392$</li>
<li>F 植物の領域の価格は $10 \times 18 = 180$</li>
<li>V 植物の領域の価格は $13 \times 20 = 260$</li>
<li>J 植物の領域の価格は $11 \times 20 = 220$</li>
<li>C 植物の領域の価格は $1 \times 4 = 4$</li>
<li>E 植物の領域の価格は $13 \times 18 = 234$</li>
<li>I 植物の領域の価格は $14 \times 22 = 308$</li>
<li>M 植物の領域の価格は $5 \times 12 = 60$</li>
<li>S 植物の領域の価格は $3 \times 8 = 24$</li>
</ul>
<p>したがって、合計価格は1930です。</p>
<p>あなたの地図上の全ての領域の柵の合計価格はいくらですか？</p>
<h1 id="パート2-56"><a class="header" href="#パート2-56">パート2</a></h1>
<p>幸いなことに、小人たちは大量の柵を注文しようとしているので、<strong>まとめ買い割引</strong>の対象になります！</p>
<p>まとめ買い割引では、価格を計算するために周長を使用するのではなく、
各領域が持つ<strong>辺の数</strong>を使用する必要があります。
一本の真っ直ぐな柵は、その長さに関係なく、1つの辺として数えます。</p>
<p>この例を再度考えてみましょう：</p>
<pre><code>AAAA
BBCD
BBCC
EEEC
</code></pre>
<p>種類 A の植物を含む領域は4つの辺を持ち、種類 B, D, E の植物を含む領域もそれぞれ同様です。
しかし、種類 C の植物を含むかなり複雑な領域は8つの辺を持っています！</p>
<p>領域ごとの価格を領域の面積に辺の数を掛けて計算する新しい方法を使用すると、
領域 A から E の価格はそれぞれ 16, 16, 32, 4, 12 となり、合計価格は 80 になります。</p>
<p>上記の2番目の例（種類 X と O の植物でいっぱいの）は、合計価格436になります。</p>
<p>以下は、種類 E の植物でいっぱいのE字型の領域を含む地図です：</p>
<pre><code>EEEEE
EXXXX
EEEEE
EXXXX
EEEEE
</code></pre>
<p>E字型の領域は、面積17と辺12を持ち、価格は204となります。
X 型植物で満たされた2つの領域を含めて、この地図の合計価格は236になります。</p>
<p>次の地図の合計価格は368です：</p>
<pre><code>AAAAAA
AAABBA
AAABBA
ABBAAA
ABBAAA
AAAAAA
</code></pre>
<p>種類 B の植物が生い茂る2つの領域（それぞれ4辺）と、
種類 A の植物が生い茂る1つの領域（外側に4辺、内側にさらに8辺、合計12辺）があります。
種類 A の植物の領域を囲う柵を数えるときには特別な注意を払う必要があります。
柵の各部分には内側と外側があるので、
柵は領域の真ん中（2つの B 領域が斜めに接するところ）を横切って繋げることはできません。
（妖精たちがメビウス柵製作所と契約していればよかったのですが、
彼らの契約条件はあまりにも一方的でした。）</p>
<p>以前の大きな例では、現在以下のように価格が更新されています：</p>
<ul>
<li>R 植物の領域は価格 $12 \times 10 = 120$ です。</li>
<li>I 植物の領域は価格 $4 \times 4 = 16$ です。</li>
<li>C 植物の領域は価格 $14 \times 22 = 308$ です。</li>
<li>F 植物の領域は価格 $10 \times 12 = 120$ です。</li>
<li>V 植物の領域は価格 $13 \times 10 = 130$ です。</li>
<li>J 植物の領域は価格 $11 \times 12 = 132$ です。</li>
<li>C 植物の領域は価格 $1 \times 4 = 4$ です。</li>
<li>E 植物の領域は価格 $13 \times 8 = 104$ です。</li>
<li>I 植物の領域は価格 $14 \times 16 = 224$ です。</li>
<li>M 植物の領域は価格 $5 \times 6 = 30$ です。</li>
<li>S 植物の領域は価格 $3 \times 6 = 18$ です。</li>
</ul>
<p>これらを合計すると、新しい合計価格は1206になります。</p>
<p>地図上の全ての領域の柵の新しい合計価格はいくらですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13日目-かぎ爪のある奇妙な機械"><a class="header" href="#13日目-かぎ爪のある奇妙な機械">13日目: かぎ爪のある奇妙な機械</a></h1>
<p>次は、熱帯の島にあるリゾートの<a href="2024/../2020/day24.html">ロビー</a>です。
歴史学者たちは、すぐには散り散りにならず、足を止めて六角形の床タイルを賞賛しています。</p>
<p>幸運なことに、リゾートには新しいアーケードがあるようです！
クレーンゲームからいくつか景品を獲得できるかもしれませんね？</p>
<p>ここにあるクレーンゲームは少し変わっています。
クレーンを操作するためのジョイスティックや方向ボタンの代わりに、AとBとラベル付けされた2つのボタンがあります。
さらに悪いことに、遊ぶのにメダル1枚では足りません。
Aボタンを押すのに<strong>メダル3枚</strong>、Bボタンを押すのに<strong>メダル1枚</strong>かかります。</p>
<p>少しの実験で、各機械のボタンが押されるたびに、
クレーンが特定の量だけ<strong>右</strong>（X軸に沿って）および
特定の量だけ<strong>前方</strong>（Y軸に沿って）に移動するように設定されていることがわかります。</p>
<p>機械にはそれぞれ1つだけ<strong>賞品</strong>が入っています。
景品を獲得するには、クレーンをX軸とY軸の両方で景品の真上に<strong>ちょうど</strong>配置する必要があります。</p>
<p>あなたは考えます：
獲得できる景品を全て獲得するために必要な、最小限のメダル枚数はどれくらいになるか？
あなたはそれぞれの機械のボタンの動作と景品の位置のリストを作成します（あなたのパズルの入力）。
例えば：</p>
<pre><code>Button A: X+94, Y+34
Button B: X+22, Y+67
Prize: X=8400, Y=5400

Button A: X+26, Y+66
Button B: X+67, Y+21
Prize: X=12748, Y=12176

Button A: X+17, Y+86
Button B: X+84, Y+37
Prize: X=7870, Y=6450

Button A: X+69, Y+23
Button B: X+27, Y+71
Prize: X=18641, Y=10279
</code></pre>
<p>このリストは、4つの異なるクレーンゲームのボタン構成と景品の位置を説明しています。</p>
<p>今のところ、リストの最初のクレーンゲームだけを考えてください：</p>
<ul>
<li>機械のAボタンを押すと、クレーンはX軸に沿って94ミリ、Y軸に沿って34ミリ移動します。</li>
<li>Bボタンを押すと、クレーンはX軸に沿って22ミリ、Y軸に沿って67ミリ移動します。</li>
<li>景品はX=8400, Y=5400に位置しています。
これは、クレーンの初期位置から、景品と完全に位置合わせするためにX軸に沿って正確に8400ミリ、
Y軸に沿って正確に5400ミリ移動する必要があることを意味します。</li>
</ul>
<p>景品を獲得する最も安い方法は、Aボタンを80回押し、Bボタンを40回押すことです。
これにより、クレーンがX軸に沿って整列します $(80 \times 94 + 40 \times 22 = 8400)$ し、
Y軸に沿っても整列します $(80 \times 34 + 40 \times 67 = 5400)$ 。
これを行うには、Aボタンの押下にメダル $80 \times 3$ 枚、
Bボタンの押下にメダル $40 \times 1$ 枚が必要で、合計280枚になります。</p>
<p>2台目と4台目のクレーンゲームでは、AとBのボタンを押す組み合わせで景品を獲得することは決してできません。</p>
<p>3台目のクレーンゲームで景品を獲得する最も安い方法は、Aボタンを38回押し、Bボタンを86回押すことです。
これを行うと、メダルが合計200枚必要になります。</p>
<p>したがって、獲得できる景品は最大で2つです。
全ての景品（2つ）を獲得するために必要な最小のメダルは480枚です。</p>
<p>各ボタンは景品を獲得するために<strong>100回以上押される必要はない</strong>とあなたは推測しました。
そうでなければ、これを遊びたい人が誰かいるでしょうか？</p>
<p>できるだけ多くの景品を獲得する方法を考えてください。
全ての可能な景品を獲得するために必要なメダルの最小枚数はいくつですか？</p>
<h1 id="パート2-57"><a class="header" href="#パート2-57">パート2</a></h1>
<p>最初の景品を獲得しようとすると、クレーンが予想していた場所には全く近くないことに気づきます。
測定の単位変換エラーのため、全ての景品の位置は実際にはX軸とY軸の両方で10000000000000大きな値です！</p>
<p>全ての景品のXおよびY位置に10000000000000を加えてください。
この変更を行った後、上記の例は次のようになります：</p>
<pre><code>Button A: X+94, Y+34
Button B: X+22, Y+67
Prize: X=10000000008400, Y=10000000005400

Button A: X+26, Y+66
Button B: X+67, Y+21
Prize: X=10000000012748, Y=10000000012176

Button A: X+17, Y+86
Button B: X+84, Y+37
Prize: X=10000000007870, Y=10000000006450

Button A: X+69, Y+23
Button B: X+27, Y+71
Prize: X=10000000018641, Y=10000000010279
</code></pre>
<p>現在、景品を獲得できるのは2台目と4台目のクレーンゲームのみです。
残念ながら、ボタンは<strong>100回以上押す</strong>必要があります。</p>
<p>修正された景品の座標を使用して、できるだけ多くの景品を獲得する方法を考えてください。
全ての可能な景品を獲得するために必要なメダルの最小枚数はいくつですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第14日-トイレの要塞"><a class="header" href="#第14日-トイレの要塞">第14日: トイレの要塞</a></h1>
<p>歴史学者の一人がお手洗いに行きたくなりました。
運よく彼らのリストにある未訪問の場所の近くにトイレがあることを知っていたので、
皆はすぐにイースターバニー本部 (Easter Bunny Headquarters) のロビーにテレポートしました。</p>
<p>残念ながら、EBHQはあなたの最後の<a href="2024/../2016/day2.html">訪問</a>後に
<strong>再び</strong>トイレのセキュリティを「改善」したようです。
トイレの外はロボットであふれています！</p>
<p>トイレに歴史学者を安全に連れて行くためには、ロボットが将来どこにいるかを予測する方法が必要です。
幸いなことに、彼らは全てタイルの床の上を予測可能な<strong>直線</strong>で移動しているようです。</p>
<p>ロボットの現在の<strong>位置</strong> (<code>p</code>) と<strong>速度</strong> (<code>v</code>) のリストを作成しました（あなたのパズル入力）。
1行につき1台のロボットの情報を記載します。例えば：</p>
<pre><code>p=0,4 v=3,-3
p=6,3 v=-1,-3
p=10,3 v=-1,2
p=2,0 v=2,-1
p=0,0 v=1,3
p=3,0 v=-2,-2
p=7,6 v=-1,-3
p=3,0 v=-1,-2
p=9,3 v=2,3
p=7,3 v=-1,2
p=2,4 v=2,-3
p=9,5 v=-3,-3
</code></pre>
<p>各ロボットの位置は <code>p=x,y</code> の形で示され、<code>x</code> はロボットが左の壁から何タイル離れているかを、
<code>y</code> は上の壁から何タイル離れているかを表します（上から見たとき）。
したがって、<code>p=0,0</code> の位置はロボットが左上の隅にいることを意味します。</p>
<p>各ロボットの速度は <code>v=x,y</code> の形で与えられ、<code>x</code> と <code>y</code> は<strong>タイル毎秒</strong>で表されます。
正の <code>x</code> はロボットが<strong>右</strong>に移動していることを意味し、
正の <code>y</code> はロボットが<strong>下</strong>に移動していることを意味します。
したがって、<code>v=1,-2</code> の速度は、ロボットが毎秒1タイル右、2タイル上に移動することを意味します。</p>
<p>実際のトイレの外にいるロボットは、上から見ると幅101タイル、高さ103タイルの空間にいます。
しかしこの例では、ロボットは幅11タイル、高さ7タイルの空間にいます。</p>
<p>ロボットは、互いの上や下を移動するのが得意です（ばね、伸縮可能な脚、クワッドローターの組み合わせによる）、
そのため同じタイルを共有でき、互いに接触しません。
この例について、各タイル上のロボットの数を視覚化すると次のようになります：</p>
<pre><code>1.12.......
...........
...........
......11.11
1.1........
.........1.
.......1...
</code></pre>
<p>これらのロボットには、トイレの最大の安全性のための独特の機能があります：それは<strong>テレポート</strong>できることです。
ロボットが空間の端にぶつかりそうになると、代わりに<strong>反対側にテレポート</strong>し、効果的に端を回り込むことができます。
ロボット <code>p=2,4 v=2,-3</code> の最初の数秒間の様子を示します：</p>
<pre><code>初期状態:
...........
...........
...........
...........
..1........
...........
...........

1 秒後:
...........
....1......
...........
...........
...........
...........
...........

2 秒後:
...........
...........
...........
...........
...........
......1....
...........

3 秒後:
...........
...........
........1..
...........
...........
...........
...........

4 秒後:
...........
...........
...........
...........
...........
...........
..........1

5 秒後:
...........
...........
...........
.1.........
...........
...........
...........
</code></pre>
<p>歴史学者はこれ以上待てないので、ロボットを長時間シミュレートする必要はありません。
100秒後、ロボットはどこにいますか？</p>
<p>上の例では、100秒経過した後の各タイルのロボットの数は次のようになります：</p>
<pre><code>......2..1.
...........
1..........
.11........
.....1.....
...12......
.1....1....
</code></pre>
<p>最も安全な地帯を決めるには、100秒後に<strong>それぞれの象限にいるロボットの台数</strong>を数えます。
ちょうど真ん中（水平または垂直）にいるロボットは、どの象限にも含まれないため、関連するロボットは次の通りです：</p>
<pre><code>..... 2..1.
..... .....
1.... .....
           
..... .....
...12 .....
.1... 1....
</code></pre>
<p>この例では、四つの象限にはそれぞれ 1, 3, 4, 1台のロボットが含まれています。
これらを掛け合わせると、総合<strong>安全係数</strong>は12になります。</p>
<p>あなたのリストにあるロボットの動きを、幅101タイル、高さ103タイルの空間内で予測してください。
ちょうど100秒が経過した後の安全係数はいくつですか？</p>
<h1 id="パート2-58"><a class="header" href="#パート2-58">パート2</a></h1>
<p>トイレ休憩中に、誰かがこれらのロボットが北極で作られ使用されているものと非常に似ていることに気づきます。
もしそれらが同じタイプのロボットであれば、ハードコーディングされたイースターエッグを持っているはずです：
非常にまれに、ほとんどのロボットが並んで<strong>クリスマスツリーの絵</strong>を作るはずです。</p>
<p>ロボットがイースターエッグを表示するために必要な最少の経過秒数はいくつですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15日目-倉庫の悩み"><a class="header" href="#15日目-倉庫の悩み">15日目: 倉庫の悩み</a></h1>
<p>あなたは自分のミニ潜水艦の中に戻ってきました！
歴史学者たちはそれぞれ異なる方向にミニ潜水艦を操縦しています。
もしかしたら、主任もどこかに自分の潜水艦を持っているかもしれませんね？</p>
<p>あなたは上を見上げると、<a href="2024/../2021/day6.html">ハダカイワシ</a>の大群が泳いでいるのが見えます。
よく見ると、彼らはかなり不安そうです。
そこで、あなたはミニ潜水艦を操縦して、助けられるかどうか見に行きます。</p>
<p>ハダカイワシの個体数は急速に増えるため、彼らは大量の食料を必要とし、その食料はどこかに保管される必要があります。
だからこそ、彼らハダカイワシたちはロボットが従事する精巧な倉庫複合施設を建設したのです！</p>
<p>これらのハダカイワシは、自分たちの最も重要な倉庫の一つで従事するロボットの制御を失ったため、とても不安そうです！
現在、そのロボットは暴走して倉庫内で箱を押して回っており、ハダカイワシの物流や在庫管理戦略を無視しています。</p>
<p>今のところ、どのハダカイワシも予測不可能なロボットに近づいてそれを止める勇気がありません。
しかし、もしあなたがロボットの動きを予測できれば、彼らは安全な選択肢を見つけることができるかもしれません。</p>
<p>ハダカイワシは既に倉庫の地図とロボットが試みる動きのリスト（あなたのパズル入力）を持っています。
問題は、箱が移動するため、動きが失敗することがあるため、ロボットの実際の動きを予測するのが難しいことです。</p>
<p>例えば：</p>
<pre><code>##########
#..O..O.O#
#......O.#
#.OO..O.O#
#..O@..O.#
#O#..O...#
#O..O..O.#
#.OO.O.OO#
#....O...#
##########

&lt;vv&gt;^&lt;v^&gt;v&gt;^vv^v&gt;v&lt;&gt;v^v&lt;v&lt;^vv&lt;&lt;&lt;^&gt;&lt;&lt;&gt;&lt;&gt;&gt;v&lt;vvv&lt;&gt;^v^&gt;^&lt;&lt;&lt;&gt;&lt;&lt;v&lt;&lt;&lt;v^vv^v&gt;^
vvv&lt;&lt;^&gt;^v^^&gt;&lt;&lt;&gt;&gt;&gt;&lt;&gt;^&lt;&lt;&gt;&lt;^vv^^&lt;&gt;vvv&lt;&gt;&gt;&lt;^^v&gt;^&gt;vv&lt;&gt;v&lt;&lt;&lt;&lt;v&lt;^v&gt;^&lt;^^&gt;&gt;&gt;^&lt;v&lt;v
&gt;&lt;&gt;vv&gt;v^v^&lt;&gt;&gt;&lt;&gt;&gt;&gt;&gt;&lt;^^&gt;vv&gt;v&lt;^^^&gt;&gt;v^v^&lt;^^&gt;v^^&gt;v^&lt;^v&gt;v&lt;&gt;&gt;v^v^&lt;v&gt;v^^&lt;^^vv&lt;
&lt;&lt;v&lt;^&gt;&gt;^^^^&gt;&gt;&gt;v^&lt;&gt;vvv^&gt;&lt;v&lt;&lt;&lt;&gt;^^^vv^&lt;vvv&gt;^&gt;v&lt;^^^^v&lt;&gt;^&gt;vvvv&gt;&lt;&gt;&gt;v^&lt;&lt;^^^^^
^&gt;&lt;^&gt;&lt;&gt;&gt;&gt;&lt;&gt;^^&lt;&lt;^^v&gt;&gt;&gt;&lt;^&lt;v&gt;^&lt;vv&gt;&gt;v&gt;&gt;&gt;^v&gt;&lt;&gt;^v&gt;&lt;&lt;&lt;&lt;v&gt;&gt;v&lt;v&lt;v&gt;vvv&gt;^&lt;&gt;&lt;&lt;&gt;^&gt;&lt;
^&gt;&gt;&lt;&gt;^v&lt;&gt;&lt;^vvv&lt;^^&lt;&gt;&lt;v&lt;&lt;&lt;&lt;&lt;&gt;&lt;^v&lt;&lt;&lt;&gt;&lt;&lt;&lt;^^&lt;v&lt;^^^&gt;&lt;^&gt;&gt;^&lt;v^&gt;&lt;&lt;&lt;^&gt;&gt;^v&lt;v^v&lt;v^
&gt;^&gt;&gt;^v&gt;vv&gt;^&lt;&lt;^v&lt;&gt;&gt;&lt;&lt;&gt;&lt;&lt;v&lt;&lt;v&gt;&lt;&gt;v&lt;^vv&lt;&lt;&lt;&gt;^^v^&gt;^^&gt;&gt;&gt;&lt;&lt;^v&gt;&gt;v^v&gt;&lt;^^&gt;&gt;^&lt;&gt;vv^
&lt;&gt;&lt;^^&gt;^^^&lt;&gt;&lt;vvvvv^v&lt;v&lt;&lt;&gt;^v&lt;v&gt;v&lt;&lt;^&gt;&lt;&lt;&gt;&lt;&lt;&gt;&lt;&lt;&lt;^^&lt;&lt;&lt;^&lt;&lt;&gt;&gt;&lt;&lt;&gt;&lt;^^^&gt;^^&lt;&gt;^&gt;v&lt;&gt;
^^&gt;vv&lt;^v^v&lt;vv&gt;^&lt;&gt;&lt;v&lt;^v&gt;^^^&gt;&gt;&gt;^^vvv^&gt;vvv&lt;&gt;&gt;&gt;^&lt;^&gt;&gt;&gt;&gt;&gt;^&lt;&lt;^v&gt;^vvv&lt;&gt;^&lt;&gt;&lt;&lt;v&gt;
v^^&gt;&gt;&gt;&lt;&lt;^^&lt;&gt;&gt;^v^&lt;v^vv&lt;&gt;v^&lt;&lt;&gt;^&lt;^v^v&gt;&lt;^&lt;&lt;&lt;&gt;&lt;&lt;^&lt;v&gt;&lt;v&lt;&gt;vv&gt;&gt;v&gt;&lt;v^&lt;vv&lt;&gt;v^&lt;&lt;^
</code></pre>
<p>ロボット（<code>@</code>）が移動しようとするとき、もしその進路に箱（<code>O</code>）があれば、ロボットはその箱を押そうとします。
しかし、この行動がロボットまたは箱を壁（<code>#</code>）に押し込むことになる場合、ロボットを含めて何も動きません。
これらの初期位置は、ハダカイワシがあなたに渡した文書の上部にある地図に示されています。</p>
<p>文書の残りの部分では、ロボットが試みる<strong>移動</strong>（<code>^</code> は上、<code>v</code> は下、<code>&lt;</code> は左、<code>&gt;</code> は右）が順に示されています。
（移動は一つの巨大な列を形成しています。コピー＆ペーストを容易にするために複数行に分けられています。
移動列の中の改行は無視してください。）</p>
<p>手掛かりのためのもっと小さな例です：</p>
<pre><code>########
#..O.O.#
##@.O..#
#...O..#
#.#.O..#
#...O..#
#......#
########

&lt;^^&gt;&gt;&gt;vv&lt;v&gt;&gt;v&lt;&lt;
</code></pre>
<p>ロボットが与えられた移動の列を試みると、次のように箱を押し動かします：</p>
<pre><code>Initial state:
########
#..O.O.#
##@.O..#
#...O..#
#.#.O..#
#...O..#
#......#
########

Move &lt;:
########
#..O.O.#
##@.O..#
#...O..#
#.#.O..#
#...O..#
#......#
########

Move ^:
########
#.@O.O.#
##..O..#
#...O..#
#.#.O..#
#...O..#
#......#
########

Move ^:
########
#.@O.O.#
##..O..#
#...O..#
#.#.O..#
#...O..#
#......#
########

Move &gt;:
########
#..@OO.#
##..O..#
#...O..#
#.#.O..#
#...O..#
#......#
########

Move &gt;:
########
#...@OO#
##..O..#
#...O..#
#.#.O..#
#...O..#
#......#
########

Move &gt;:
########
#...@OO#
##..O..#
#...O..#
#.#.O..#
#...O..#
#......#
########

Move v:
########
#....OO#
##..@..#
#...O..#
#.#.O..#
#...O..#
#...O..#
########

Move v:
########
#....OO#
##..@..#
#...O..#
#.#.O..#
#...O..#
#...O..#
########

Move &lt;:
########
#....OO#
##.@...#
#...O..#
#.#.O..#
#...O..#
#...O..#
########

Move v:
########
#....OO#
##.....#
#..@O..#
#.#.O..#
#...O..#
#...O..#
########

Move &gt;:
########
#....OO#
##.....#
#...@O.#
#.#.O..#
#...O..#
#...O..#
########

Move &gt;:
########
#....OO#
##.....#
#....@O#
#.#.O..#
#...O..#
#...O..#
########

Move v:
########
#....OO#
##.....#
#.....O#
#.#.O@.#
#...O..#
#...O..#
########

Move &lt;:
########
#....OO#
##.....#
#.....O#
#.#O@..#
#...O..#
#...O..#
########

Move &lt;:
########
#....OO#
##.....#
#.....O#
#.#O@..#
#...O..#
#...O..#
########
</code></pre>
<p>大きい例ははるかに多くの移動があります。
ロボットがそれらの移動を終えた後、倉庫はこのようになるでしょう：</p>
<pre><code>##########
#.O.O.OOO#
#........#
#OO......#
#OO@.....#
#O#.....O#
#O.....OO#
#O.....OO#
#OO....OO#
##########
</code></pre>
<p>ハダカイワシは、独自の商品位置決定システム（Goods Positioning System 略してGPS）を使用して、箱の位置を追跡します。
箱の<strong>GPS座標</strong>は、地図の上端からの距離の100倍に、地図の左端からの距離を加えたものに等しいです。
（この手続きは壁タイルで止まらず、地図の端まで測定します。）</p>
<p>したがって、下に示す箱は、地図の上端からの距離が1、左端からの距離が4であるため、
GPS座標は $100 \times 1 + 4 = 104$ となります。</p>
<pre><code>#######
#...O..
#......
</code></pre>
<p>ハダカイワシは、ロボットが移動を終えた後の<strong>全ての箱のGPS座標の合計</strong>を知りたいと思っています。
大きな例では、全ての箱のGPS座標の合計は10092です。小さな例では、合計は2028です。</p>
<p>倉庫内のロボットと箱の動きを予測してください。
ロボットの移動が終わった後、全ての箱のGPS座標の合計はいくつですか？</p>
<h1 id="パート2-59"><a class="header" href="#パート2-59">パート2</a></h1>
<p>ハダカイワシはあなたの情報を使って突入するための安全な瞬間を見つけ、故障したロボットの電源を切ります！
あなたの栄誉を讃えるお祭りの準備を始めた矢先、<strong>別の</strong>倉庫のロボット<strong>も</strong>故障しているとの報告が入ります。</p>
<p>この倉庫のレイアウトは、あなたがたった今救った倉庫と驚くほど似ています。
1つの重要な違いがあります：ロボット以外の全てが<strong>2倍の幅</strong>です！
ロボットの移動のリストは変わりません。</p>
<p>倍角の倉庫の地図を取得するには、元の地図から始め、各タイルについて次の変更を行います：</p>
<ul>
<li>タイルが <code>#</code> の場合、新しい地図には <code>##</code> が含まれます。</li>
<li>タイルが <code>O</code> の場合、新しい地図には <code>[]</code> が含まれます。</li>
<li>タイルが <code>.</code> の場合、新しい地図には <code>..</code> が含まれます。</li>
<li>タイルが <code>@</code> の場合、新しい地図には <code>@.</code> が含まれます。</li>
</ul>
<p>これにより、幅が2倍で、<code>[]</code> で表される幅広の箱を持つ新しい倉庫の地図が生成されます。
（ロボットの大きさは変わりません。）</p>
<p>以前の大きな例は、今や次のようになります：</p>
<pre><code>####################
##....[]....[]..[]##
##............[]..##
##..[][]....[]..[]##
##....[]@.....[]..##
##[]##....[]......##
##[]....[]....[]..##
##..[][]..[]..[][]##
##........[]......##
####################
</code></pre>
<p>箱は今や2倍の幅がありますが、ロボットは依然として同じ大きさと速度です。
そのため、同時に2つの他の箱を押すような位置に箱を置くことができます。
例えば、この状況を考えてみてください：</p>
<pre><code>#######
#...#.#
#.....#
#..OO@#
#..O..#
#.....#
#######

&lt;vv&lt;&lt;^^&lt;&lt;^^
</code></pre>
<p>この地図の大きさを適切に変更した後、ロボットは次のようにこれらの箱を押します:</p>
<pre><code>Initial state:
##############
##......##..##
##..........##
##....[][]@.##
##....[]....##
##..........##
##############

Move &lt;:
##############
##......##..##
##..........##
##...[][]@..##
##....[]....##
##..........##
##############

Move v:
##############
##......##..##
##..........##
##...[][]...##
##....[].@..##
##..........##
##############

Move v:
##############
##......##..##
##..........##
##...[][]...##
##....[]....##
##.......@..##
##############

Move &lt;:
##############
##......##..##
##..........##
##...[][]...##
##....[]....##
##......@...##
##############

Move &lt;:
##############
##......##..##
##..........##
##...[][]...##
##....[]....##
##.....@....##
##############

Move ^:
##############
##......##..##
##...[][]...##
##....[]....##
##.....@....##
##..........##
##############

Move ^:
##############
##......##..##
##...[][]...##
##....[]....##
##.....@....##
##..........##
##############

Move &lt;:
##############
##......##..##
##...[][]...##
##....[]....##
##....@.....##
##..........##
##############

Move &lt;:
##############
##......##..##
##...[][]...##
##....[]....##
##...@......##
##..........##
##############

Move ^:
##############
##......##..##
##...[][]...##
##...@[]....##
##..........##
##..........##
##############

Move ^:
##############
##...[].##..##
##...@.[]...##
##....[]....##
##..........##
##..........##
##############
</code></pre>
<p>この倉庫も、箱の位置を特定するためにGPSを使用しています。
これらの大きな箱については、地図の端から問題の箱の最も近い端までの距離が測定されます。
したがって、下に示す箱は、地図の上端からの距離が1、地図の左端からの距離が5であり、
GPS座標は $100 \times 1 + 5 = 105$ になります。</p>
<pre><code>##########
##...[]...
##........
</code></pre>
<p>上記の大きな例の拡大版では、ロボットが全ての移動を終えた後、倉庫はこのようになります：</p>
<pre><code>####################
##[].......[].[][]##
##[]...........[].##
##[]........[][][]##
##[]......[]....[]##
##..##......[]....##
##..[]............##
##..@......[].[][]##
##......[][]..[]..##
####################
</code></pre>
<p>これらの箱のGPS座標の合計は9021です。</p>
<p>この新しい拡大された倉庫でロボットと箱の動きを予測してください。
全ての箱の最終GPS座標の合計はいくつですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第16日-トナカイ迷路"><a class="header" href="#第16日-トナカイ迷路">第16日: トナカイ迷路</a></h1>
<p><a href="2024/../2015/day14.html">トナカイオリンピック</a>の季節がやってきました！
今年の大イベントは<strong>トナカイ迷路</strong>で、トナカイたちは<strong>最小スコア</strong>を競います。</p>
<p>あなたと歴史学者たちは、イベントが始まろうとしているちょうどその時に主任を探しに到着します。
少し見るのも悪くないですよね？</p>
<p>トナカイはスタートタイル（<code>S</code> と表示）から<strong>東</strong>を向いてスタートし、
エンドタイル（<code>E</code> と表示）に到達する必要があります。
彼らは1回に1タイル前進することができます（スコアを1ポイント増加させます）。
ただし、壁（<code>#</code>）には決して入ることができません。
また、彼らは時計回りまたは反時計回りに90度回転することもできます（スコアを1000ポイント増加させます）。</p>
<p>座る最適な場所を見つけるために、近くのキオスクから地図（あなたのパズル入力）を手に入れることから始めます。
例えば：</p>
<pre><code>###############
#.......#....E#
#.#.###.#.###.#
#.....#.#...#.#
#.###.#####.#.#
#.#.#.......#.#
#.#.#####.###.#
#...........#.#
###.#.#####.#.#
#...#.....#.#.#
#.#.#.###.#.#.#
#.....#...#.#.#
#.###.#.#.#.#.#
#S..#.....#...#
###############
</code></pre>
<p>この迷路には多くの経路がありますが、最良の経路のいずれかを選ぶと、スコアはわずか7036になります。
これは、36歩前進し、合計で7回90度回転することで達成できます：</p>
<pre><code>###############
#.......#....E#
#.#.###.#.###^#
#.....#.#...#^#
#.###.#####.#^#
#.#.#.......#^#
#.#.#####.###^#
#..&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;v#^#
###^#.#####v#^#
#&gt;&gt;^#.....#v#^#
#^#.#.###.#v#^#
#^....#...#v#^#
#^###.#.#.#v#^#
#S..#.....#&gt;&gt;^#
###############
</code></pre>
<p>二つめの例を示します：</p>
<pre><code>#################
#...#...#...#..E#
#.#.#.#.#.#.#.#.#
#.#.#.#...#...#.#
#.#.#.#.###.#.#.#
#...#.#.#.....#.#
#.#.#.#.#.#####.#
#.#...#.#.#.....#
#.#.#####.#.###.#
#.#.#.......#...#
#.#.###.#####.###
#.#.#...#.....#.#
#.#.#.#####.###.#
#.#.#.........#.#
#.#.#.#########.#
#S#.............#
#################
</code></pre>
<p>この迷路では、最良の経路は11048ポイントかかります。そのような経路のひとつをたどると、次のようになります：</p>
<pre><code>#################
#...#...#...#..E#
#.#.#.#.#.#.#.#^#
#.#.#.#...#...#^#
#.#.#.#.###.#.#^#
#&gt;&gt;v#.#.#.....#^#
#^#v#.#.#.#####^#
#^#v..#.#.#&gt;&gt;&gt;&gt;^#
#^#v#####.#^###.#
#^#v#..&gt;&gt;&gt;&gt;^#...#
#^#v###^#####.###
#^#v#&gt;&gt;^#.....#.#
#^#v#^#####.###.#
#^#v#^........#.#
#^#v#^#########.#
#S#&gt;&gt;^..........#
#################
</code></pre>
<p>上に示した経路には、最初の動きとして90度のターンが含まれており、東を向いていたトナカイが北を向くことになります。</p>
<p>地図を注意深く分析してください。トナカイが得られる可能性のある最小スコアはいくつですか？</p>
<h1 id="パート2-60"><a class="header" href="#パート2-60">パート2</a></h1>
<p>最良の経路がどのようなものかわかったので、座るのに最適な場所を見つけることができます。</p>
<p>全ての壁でないタイル (<code>S</code>, <code>.</code>, <code>E</code>) には、タイルの端に座る場所が用意されています。
これらのタイルのどれが座るのに最適な場所かを決めるには、
様々な要因（座席の快適さ、トイレの距離、視界を遮る柱の有無など）が影響しますが、
最も重要な要因は、<strong>そのタイルが迷路の最良の経路のいずれかに含まれているかどうか</strong>です。
そうでないどこか別の場所に座ると、すべてのアクションを見逃してしまいます！</p>
<p>したがって、<code>S</code> タイルと <code>E</code> タイルを含む、
迷路の最良の経路の<strong>いずれか</strong>の一部であるタイルを特定する必要があります。</p>
<p>最初の例では、迷路のさまざまな最良の経路のいずれかに含まれるタイル（<code>O</code>でマークされています）が45個あります：</p>
<pre><code>###############
#.......#....O#
#.#.###.#.###O#
#.....#.#...#O#
#.###.#####.#O#
#.#.#.......#O#
#.#.#####.###O#
#..OOOOOOOOO#O#
###O#O#####O#O#
#OOO#O....#O#O#
#O#O#O###.#O#O#
#OOOOO#...#O#O#
#O###.#.#.#O#O#
#O..#.....#OOO#
###############
</code></pre>
<p>ふたつめの例では、少なくとも1つの最良の経路に含まれるタイルが64枚あります：</p>
<pre><code>#################
#...#...#...#..O#
#.#.#.#.#.#.#.#O#
#.#.#.#...#...#O#
#.#.#.#.###.#.#O#
#OOO#.#.#.....#O#
#O#O#.#.#.#####O#
#O#O..#.#.#OOOOO#
#O#O#####.#O###O#
#O#O#..OOOOO#OOO#
#O#O###O#####O###
#O#O#OOO#..OOO#.#
#O#O#O#####O###.#
#O#O#OOOOOOO..#.#
#O#O#O#########.#
#O#OOO..........#
#################
</code></pre>
<p>地図をさらに分析してください。
迷路の最良の経路のいずれかに含まれるタイルは何枚ありますか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第17日-時空間コンピュータ"><a class="header" href="#第17日-時空間コンピュータ">第17日: 時空間コンピュータ</a></h1>
<p>歴史学者たちが彼らの奇妙な装置のボタンを押しますが、
今回はただ皆が<a href="2024/../2018/day6.html">落下している</a>ように感じます。</p>
<p>「危機的な状況」と装置が馴染みのある声で通知します。
「ブートストラップ処理に失敗。デバッガを初期化中…」</p>
<p>小さなハンドヘルド装置は突然、コンピュータ一式へと展開しました！
歴史学者たちは緊張した様子で周りを見回し、そのうちの一人がそれをあなたに投げてよこします。</p>
<p>これは3ビットコンピュータのようです：
そのプログラムは3ビットの数（0から7）で構成されたリストで、例えば <code>0,1,2,3</code> のようになっています。
コンピュータには A, B, C という名前の3つの<strong>レジスタ</strong>もありますが、
これらのレジスタは3ビットに制限されず、任意の整数を保持できます。</p>
<p>コンピュータは<strong>8つの命令</strong>を知っており、
それぞれは3ビット数（命令の<strong>オペコード</strong>と呼ばれる）で識別されます。
各命令はその後に続く3ビットの数を入力として読み取ります。これを<strong>オペランド</strong>と呼びます。</p>
<p><strong>命令ポインタ</strong>と呼ばれる数は、次のオペコードが読み取られるプログラム内の位置を特定します。
これは0から始まり、それはプログラム内の最初の3ビットの数を指します。
ジャンプ命令を除いて、命令ポインタは各命令が処理されるごとに2増加します
（命令のオペコードとそのオペランドを越えて次に進むため）。
コンピュータがプログラムの終わりを超えてオペコードを読み取ろうとすると、その代わりに<strong>停止</strong>します。</p>
<p>よって、プログラム <code>0,1,2,3</code> はオペコードが0の命令を実行し、それにオペランド1を渡し、
その後オペコードが2の命令を実行してそれにオペランド3を渡し、最後に停止します。</p>
<p>オペランドには2種類あり、それぞれの命令はそのオペランドの種類を指定します。
<strong>即値オペランド</strong>の値はそのオペランド自体です。
たとえば、即値オペランド7の値は数7です。
<strong>コンボオペランド</strong>の値は次のようにして見つけることができます：</p>
<ul>
<li>コンボオペランド0から3は即値0から3を表します。</li>
<li>コンボオペランド4はレジスタAの値を意味します。</li>
<li>コンボオペランド5はレジスタBの値を意味します。</li>
<li>コンボオペランド6はレジスタCの値を意味します。</li>
<li>コンボオペランド7は予約されており、正しいプログラムには現れません。</li>
</ul>
<p>8つの命令は以下の通りです：</p>
<p><code>adv</code> 命令（オペコード0）は<strong>除算</strong>を行います。
被除数はAレジスタの値です。除数は命令の<strong>コンボ</strong>オペランドの指す値の2のべき乗で求められます。
（つまり、オペランドが2の場合はAを4 $(2^2)$ で割り、オペランドが5の場合はAを $2^B$ で割ります。）
除算操作の結果は整数に<strong>切り捨て</strong>られ、Aレジスタに書き込まれます。</p>
<p><code>bxl</code> 命令（オペコード1）は、
レジスタBと命令の<strong>即値</strong>オペランドの<strong>ビット単位のXOR</strong>を計算し、結果をレジスタBに格納します。</p>
<p><code>bst</code> 命令（オペコード2）は、
<strong>コンボ</strong>オペランドの値を8で割った余りを計算し（つまり最下位3ビットのみを保持します）、
その値をBレジスタに書き込みます。</p>
<p><code>jnz</code> 命令（オペコード3）は、Aレジスタが0の場合何もしません。
しかし、Aレジスタが<strong>零でない</strong>場合、<strong>即値</strong>オペランドの値を命令ポインタに設定することで<strong>ジャンプ</strong>します。
この命令がジャンプすると、命令ポインタはこの命令の後に2増加<strong>しません</strong>。</p>
<p><code>bxc</code> 命令（オペコード4）は、レジスタBとレジスタCの<strong>ビット単位のXOR</strong>を計算し、結果をレジスタBに格納します。
（後方互換性のため、この命令はオペランドを読み取りますが、それを<strong>無視</strong>します。）</p>
<p><code>out</code> 命令（オペコード5）は、<strong>コンボ</strong>オペランドの値を8で割った余りを計算し、その値を<strong>出力</strong>します。
（プログラムが複数の値を出力する場合、それらはカンマで区切られます。）</p>
<p><code>bdv</code> 命令（オペコード6）は、<code>adv</code> 命令とまったく同じように機能しますが、結果は<strong>Bレジスタ</strong>に格納されます。
（被除数はAレジスタから読み取られます。）</p>
<p><code>cdv</code> 命令（オペコード7）は、結果が<strong>Cレジスタ</strong>に格納されることを除いて、<code>adv</code>命令とまったく同じように動作します。
（被除数はAレジスタから読み取られます。）</p>
<p>命令の動作例をいくつか示します:</p>
<ul>
<li>レジスタCに9が入っている場合、プログラム 2,6 はレジスタBを1に設定します。</li>
<li>レジスタAに10が入っている場合、プログラム 5,0,5,1,5,4 は 0,1,2 を出力します。</li>
<li>レジスタAに2024が入っている場合、プログラム 0,1,5,4,3,0 は 4,2,5,6,7,7,7,7,3,1,0 を出力し、レジスタAには0が残ります。</li>
<li>レジスタBに29が入っている場合、プログラム 1,7 はレジスタBを26に設定します。</li>
<li>レジスタBに2024が、レジスタCに43690が含まれている場合、プログラム 4,0 はレジスタBを 44354 に設定します。</li>
</ul>
<p>歴史学者たちの奇妙な装置がデバッガの初期化を終了し、
<strong>実行しようとしているプログラム</strong>（あなたのパズル入力）<strong>に関する情報</strong>を表示しています。
例えば:</p>
<pre><code>Register A: 729
Register B: 0
Register C: 0

Program: 0,1,5,4,3,0
</code></pre>
<p>あなたの最初のタスクは、<strong>プログラムが何を出力しようとしているのかを特定する</strong>ことです。
これを行うには、レジスタを指定された値に初期化し、その後、与えられたプログラムを実行して、
出力命令によって生成された出力を収集します。
（出力命令によって生成された値は常にコンマで結合してください。）
上のプログラムが停止した後、その最終出力は 4,6,3,5,6,3,5,2,1,0 になります。</p>
<p>デバッガが提供する情報を使用して、レジスタを指定された値に初期化し、プログラムを実行します。
停止したら、出力された値をカンマで結合して一つの文字列にするとどうなりますか？</p>
<h1 id="パート2-61"><a class="header" href="#パート2-61">パート2</a></h1>
<p>デバイスのマニュアルをさらに掘り下げると、問題を見つけました。
このプログラムは<strong>そのプログラムの別のコピーを出力する</strong>ことになっています！
残念ながら、レジスターAの値が破損しているようです。
プログラムの出力命令がプログラム自体の正確なコピーを生成するように、
レジスタAを初期設定する新しい値を見つける必要があります。</p>
<p>例えば：</p>
<pre><code>Register A: 2024
Register B: 0
Register C: 0

Program: 0,3,5,4,3,0
</code></pre>
<p>このプログラムは、レジスタAが117440に初期化されている場合に、自身のコピーを出力します。
（レジスタAの元の初期値である2024は無視されます。）</p>
<p>プログラムが自身のコピーを出力するような、レジスタAの最も小さい正の初期値は何ですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-18-ram脱走"><a class="header" href="#day-18-ram脱走">Day 18: RAM脱走</a></h1>
<p>あなたと歴史学者たちは、前はこんなにドット絵ではなかった気がします。
あなたは北極の<a href="2024/../2017/day2.html">コンピュータの中</a>にいます！</p>
<p>ちょうど周囲を確認しようとしたとき、プログラムがあなたのところに駆け寄ってきます。
「このメモリ領域は安全ではありません！
ユーザーはプッシュダウンオートマトンが何であるかを誤解していて、
彼らのアルゴリズムが私たちの上にバイト全体を押し込んでいます！逃げて！」</p>
<p>アルゴリズムは高速です ー
あなたのメモリ空間に<a href="https://www.youtube.com/watch?v=9eyFDBPk4Yw">ナノ秒</a>ごとにバイトが落ちてくることになります！
幸いなことにあなたの方が<strong>速く</strong>、アルゴリズムを素早くスキャンすることで、
<strong>どのバイトが落ちるかのリスト</strong>（あなたのパズル入力）をメモリ空間に落ちる順序で作成しました。</p>
<p>あなたのメモリ空間は、水平と垂直の両方で0から70の範囲の座標を持つ2次元グリッドです。
ただし、例のために、0から6の範囲の座標を持つ小さなグリッドにいて、
次のバイト位置のリストがあると仮定します：</p>
<pre><code>5,4
4,2
4,5
3,0
2,1
6,3
2,4
1,5
0,6
3,3
2,6
5,1
1,2
5,5
2,5
6,5
1,4
0,4
6,4
1,1
6,1
1,0
0,5
1,6
2,0
</code></pre>
<p>各バイト位置は <code>X,Y</code> 座標として与えられ、<code>X</code> はメモリ空間の左端からの距離、<code>Y</code> はメモリ空間の上端からの距離です。</p>
<p>あなたと歴史学者たちは現在、メモリ空間の左上隅 (<code>0,0</code>) にいて、
右下隅の出口（あなたのメモリ空間で <code>70,70</code>、ただしこの例では <code>6,6</code>）に到達する必要があります。
まず、バイトが落ちる様子をシミュレーションして、安全に走ることができる場所を計画する必要があります。
とりあえず今は、メモリ空間に落ちる最初の数バイトだけをシミュレーションします。</p>
<p>バイトがあなたのメモリ空間に落ちると、その座標が<strong>破損</strong>します。
破損したメモリ座標には、あなたや歴史学者たちが入ることはできないので、経路を慎重に計画する必要があります。
また、メモリ空間の境界を越えることもできません。
あなたの唯一の望みは出口に到達することです。</p>
<p>上記の例で、最初の12バイトが落とされた後のメモリ空間を描くと
（<code>.</code> を安全、<code>#</code> を破損として使って）、次のようになります：
（訳註：リスト全体ではなく最初の12要素であることに注意）</p>
<pre><code>...#...
..#..#.
....#..
...#..#
..#..#.
.#..#..
#.#....
</code></pre>
<p>あなたは上下左右にステップ移動できます。
メモリ空間内の12バイトが破損した後、左上隅から出口までの最短経路は22ステップかかります。
そのような経路の一つを <code>O</code> でマークした地図を示します：</p>
<pre><code>OO.#OOO
.O#OO#O
.OOO#OO
...#OO#
..#OO#.
.#.O#..
#.#OOOO
</code></pre>
<p>最初の1キロバイト（1024バイト）がメモリ空間に落ちるのをシミュレートします。
その後、出口に到達するために必要な最小ステップ数はいくつですか？</p>
<h1 id="パート2-62"><a class="header" href="#パート2-62">パート2</a></h1>
<p>歴史学者たちは、このピクセル化された世界をあなたのように動き回ることに慣れていません。
あなたは、彼らが出口に辿り着く前に道が完全に塞がれてしまうのではないかと心配しています。</p>
<p>全員がどれだけ速く進む必要があるかを判断するために、<strong>出口への道を塞ぐ最初のバイト</strong>を特定する必要があります。</p>
<p>上記の例では、<code>1,1</code> のバイトが落ちた後でも出口への道はまだあります：</p>
<pre><code>O..#OOO
O##OO#O
O#OO#OO
OOO#OO#
###OO##
.##O###
#.#OOOO
</code></pre>
<p>しかし、次のバイト (<code>6,1</code>) を追加すると、出口への道がなくなります：</p>
<pre><code>...#...
.##..##
.#..#..
...#..#
###..##
.##.###
#.#....
</code></pre>
<p>よってこの例では、出口に到達できなくなる最初のバイトの座標は <code>6,1</code> です。</p>
<p>メモリ空間を破損させるバイト群をさらにシミュレーションしてください。
あなたの開始位置から出口に到達できなくなる最初のバイトの座標は何ですか？
（答えは、他の文字を使わずにカンマで区切った2つの整数として示してください。）
（訳註：つまり <code>input.txt</code> にある形式のままで）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="19日目-リネンの配置"><a class="header" href="#19日目-リネンの配置">19日目: リネンの配置</a></h1>
<p>今日は、歴史学者たちが歯車島の<a href="2024/../2023/day12.html">hot spring</a>に連れて行ってくれます！
非常に怪しいことに、彼らが広大な螺旋のフィールドを慎重に探索し始めても、何もややこしい事が起きません。</p>
<p>隣の<strong>温泉</strong>を訪れるチャンスが<strong>ついに</strong>来たのでしょうか？
確かめる方法は一つだけです。</p>
<p>温泉のフロントデスクのスタッフと短い会話をした後、入場料を支払うための適切なお金を持っていないことがわかります。
しかし、あなたが去る前に、スタッフがあなたの注意を引きます。
どうやら、あなたが温泉で手助けをしたことを聞いていて、取引をする気があるようです：
もし<strong>タオルを整頓する</strong>手伝いをしてくれれば、<strong>無料で</strong>入れてあげると言っています！</p>
<p>この温泉のタオルは全て、<strong>色による縞柄</strong>になっています。
パターンは数種類しかありませんが、そこにあるパターンについては、スタッフが何枚でもそのパターンのタオルを用意してくれます。
縞の色は <strong>白</strong> (w) <strong>青</strong> (u) <strong>黒</strong> (b) <strong>赤</strong> (r) <strong>緑</strong> (g) があります。
したがって、パターン <code>ggr</code> のタオルは、緑色の縞、緑色の縞、そして赤色の縞がこの順で配置されています。
（タオルを逆さまにしてパターンを反転させることはできません。そうすると温泉のロゴが逆向きになってしまいます。）</p>
<p>公式温泉ブランディング専門家は、展示したい<strong>デザイン</strong>のリストを作成しました。
それぞれのデザインは縞の色の長い系列です。
使用するタオルは自由ですが、全てのタオルの縞は希望するデザインとぴったり一致しなければなりません。
したがって、デザイン <code>rgrgr</code> を展示するには、
2つの <code>rg</code> タオルと <code>r</code> タオルを使うか、
<code>rgr</code> タオルと <code>gr</code> タオルを使うこともできます。
また、実際にそのようなタオルパターンが利用可能であれば、単一の巨大な <code>rgrgr</code> タオルを使用することもできます。</p>
<p>まず、利用可能な全てのタオルのパターンと希望するデザインのリスト（あなたのパズル入力）を集めます。
例えば：</p>
<pre><code>r, wr, b, g, bwu, rb, gb, br

brwrr
bggr
gbbr
rrbgbr
ubwu
bwurrg
brgr
bbrgwb
</code></pre>
<p>最初の行は利用可能なタオルのパターンを示しています。
この例では、温泉には単一の赤い縞 (<code>r</code>) のタオル無限枚、
白い縞と赤い縞 (<code>wr</code>) のタオル無限枚、などがあります。</p>
<p>空白の行の後、残りの行は温泉が展示したいデザインをそれぞれ述べています。
この例では、最初のデザイン (<code>brwrr</code>) は、
温泉が黒い縞、赤い縞、白い縞、そして2つの赤い縞をこのの順にして展示したいことを意味しています。</p>
<p>利用可能なタオルで、全てのデザインが作れる訳ではありません。
上記の例で、各デザインが可能かどうかは次のとおりです：</p>
<ul>
<li><code>brwrr</code> は、<code>br</code> タオル、次に <code>wr</code> タオル、最後に <code>r</code> タオルで作ることができます。</li>
<li><code>bggr</code> は、<code>b</code> タオル、2つの <code>g</code> タオル、次に `` rタオルで作ることができます。</li>
<li><code>gbbr</code> は、<code>gb</code> タオルの後に <code>br</code> タオルで作ることができます。</li>
<li><code>rrbgbr</code> は、<code>r</code>, <code>rb</code>, <code>g</code>, <code>br</code> で作ることができます。</li>
<li><code>ubwu</code> は<strong>不可能</strong>です。</li>
<li><code>bwurrg</code> は、<code>bwu</code>, <code>r</code>, <code>r</code>, <code>g</code> で作ることができます。</li>
<li><code>brgr</code> は、<code>br</code>, <code>g</code>, <code>r</code> で作ることができます。</li>
<li><code>bbrgwb</code> は<strong>不可能</strong>です。</li>
</ul>
<p>この例では、8つのデザインのうち6つが利用可能なタオルパターンで作成可能です。</p>
<p>できるだけ早く温泉に入るために、タオルパターンと希望するデザインのリストを注意深く確認してください。
何種類のデザインが作成可能ですか？</p>
<h1 id="パート2-63"><a class="header" href="#パート2-63">パート2</a></h1>
<p>スタッフは、あなたが考えたタオルの配置のいくつかが少し気に入らないようです。
タオルの再配置の無限ループを避けるために、全ての可能な選択肢を彼らに提供するべきかもしれません。</p>
<p>上記の例のデザインが作成できるさまざまな方法は次のとおりです：</p>
<p><code>brwrr</code> は2つの異なる方法で作成できます：<code>b</code>, <code>r</code>, <code>wr</code>, <code>r</code> <strong>または</strong> <code>br</code>, <code>wr</code>, <code>r</code></p>
<p><code>bggr</code> は <code>b</code>, <code>g</code>, <code>g</code>, <code>r</code> でのみ作成できます。</p>
<p><code>gbbr</code> は4つの異なる方法で作成できます：</p>
<ul>
<li><code>g</code>, <code>b</code>, <code>b</code>, <code>r</code></li>
<li><code>g</code>, <code>b</code>, <code>br</code></li>
<li><code>gb</code>, <code>b</code>, <code>r</code></li>
<li><code>gb</code>, <code>br</code></li>
</ul>
<p><code>rrbgbr</code> は6つの異なる方法で作成できます：</p>
<ul>
<li><code>r</code>, <code>r</code>, <code>b</code>, <code>g</code>, <code>b</code>, <code>r</code></li>
<li><code>r</code>, <code>r</code>, <code>b</code>, <code>g</code>, <code>br</code></li>
<li><code>r</code>, <code>r</code>, <code>b</code>, <code>gb</code>, <code>r</code></li>
<li><code>r</code>, <code>rb</code>, <code>g</code>, <code>b</code>, <code>r</code></li>
<li><code>r</code>, <code>rb</code>, <code>g</code>, <code>br</code></li>
<li><code>r</code>, <code>rb</code>, <code>gb</code>, <code>r</code></li>
</ul>
<p><code>bwurrg</code> は <code>bwu</code>, <code>r</code>, <code>r</code>, <code>g</code> でしか作れません。</p>
<p><code>brgr</code> は2つの異なる方法で作ることができます：<code>b</code>, <code>r</code>, <code>g</code> <code>r</code> <strong>または</strong> <code>br</code>, <code>g</code>, <code>r</code></p>
<p><code>ubwu</code> と <code>bbrgwb</code> はやはり不可能です。</p>
<p>この例でタオルを希望のデザインに配置する方法を全て合計すると16 (2 + 1 + 4 + 6 + 1 + 2) になります。</p>
<p>リストができ次第、温泉に入らせて貰えます。
各デザインを作ることができる異なる方法の数を合計するといくつになりますか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="day-20-レースコンディション"><a class="header" href="#day-20-レースコンディション">Day 20: レースコンディション</a></h1>
<p>（レースの状態、と、デジタル回路用語の競合状態、を掛けている）</p>
<p>歴史学者たちは再びかなりドット絵化しています。
今回は、巨大な黒い建物があなたの上にそびえ立っています ー
あなたはCPUの<a href="2024/../2017/day24.html">すぐ外</a>にいます！</p>
<p>歴史学者たちが作業を始めると、近くのプログラムがあなたがアイドル状態であることを察知し、<strong>レース</strong>を挑んできます。
どうやら、頻繁に開催される<strong>レースコンディション</strong>フェスティバルにちょうど間に合ったようです！</p>
<!-- 頻繁にあったらダメじゃんww -->
<p>レースは特に長くて曲がりくねったコードパスで行われます。
プログラムたちは、誰が<strong>最少のピコ秒</strong>でゴールに到着するかを競います。
勝者には自分専用の<strong>mutex</strong>が贈られます！</p>
<p>彼らは<strong>レースコース</strong>の地図（あなたのパズル入力）を手渡します。
例えば：</p>
<pre><code>###############
#...#...#.....#
#.#.#.#.#.###.#
#S#...#.#.#...#
#######.#.#.###
#######.#.#...#
#######.#.###.#
###..E#...#...#
###.#######.###
#...###...#...#
#.#####.#.###.#
#.#...#.#.#...#
#.#.#.#.#.#.###
#...#...#...###
###############
</code></pre>
<p>地図はコース (<code>.</code>) で構成されています。また<strong>スタート</strong> (<code>S</code>) と<strong>エンド</strong> (<code>E</code>)の位置
（どちらもトラックとみなします）を含み、壁 (<code>#</code>) があります。</p>
<p>プログラムがレースコースを走るとき、スタート位置から出発します。
その後、上、下、左、右に移動することが許されており、その各移動には<strong>1ピコ秒</strong>かかります。
目標は、できるだけ早くエンド位置に到達することです。
この例のレーストラックでは、最速タイムは84ピコ秒です。</p>
<p>スタートからゴールまでの道はひとつしかなく、プログラムは全て同じ速度で進むため、レースはかなり退屈でした。
もっと面白くするために、レースに新しいルールが導入されました：
プログラムは<strong>チート</strong>をすることが許されています。</p>
<p>チートの規則は非常に厳格です。<!-- 腸捻転な文章だ！ -->
レース中に<strong>きっかり一度</strong>だけ、プログラムは<strong>最大2ピコ秒</strong>の間、<strong>衝突判定を無効化</strong>することができます。
これにより、プログラムは通常のコースであるかのように<strong>壁を通過する</strong>ことができます。
<strong>チート</strong>が終了した時点で、プログラムは再び通常のコースに戻っていなければなりません。
さもなくば<strong>セグメンテーションフォルト</strong>が発生し、失格となります。</p>
<!-- かべのなかにいる -->
<p>したがって、プログラムは、下の図で <code>1</code> と <code>2</code> と印した2つの移動でチートを行うことで、
72ピコ秒でコースを走破することができます（<strong>12ピコ秒</strong>を節約）：</p>
<pre><code>###############
#...#...12....#
#.#.#.#.#.###.#
#S#...#.#.#...#
#######.#.#.###
#######.#.#...#
#######.#.###.#
###..E#...#...#
###.#######.###
#...###...#...#
#.#####.#.###.#
#.#...#.#.#...#
#.#.#.#.#.#.###
#...#...#...###
###############
</code></pre>
<p>あるいは、プログラムが下の図で <code>1</code> と <code>2</code> と印した2つの移動でチートを行うことで、
64ピコ秒でコースを走破することができます（<strong>20ピコ秒</strong>を節約）：</p>
<pre><code>###############
#...#...#.....#
#.#.#.#.#.###.#
#S#...#.#.#...#
#######.#.#.###
#######.#.#...#
#######.#.###.#
###..E#...12..#
###.#######.###
#...###...#...#
#.#####.#.###.#
#.#...#.#.#...#
#.#.#.#.#.#.###
#...#...#...###
###############
</code></pre>
<p>下図のチートは<strong>38ピコ秒</strong>を節約します：</p>
<pre><code>###############
#...#...#.....#
#.#.#.#.#.###.#
#S#...#.#.#...#
#######.#.#.###
#######.#.#...#
#######.#.###.#
###..E#...#...#
###.####1##.###
#...###.2.#...#
#.#####.#.###.#
#.#...#.#.#...#
#.#.#.#.#.#.###
#...#...#...###
###############
</code></pre>
<p>このチートは<strong>64ピコ秒</strong>を節約し、プログラムを直接エンドの位置に導きます：</p>
<pre><code>###############
#...#...#.....#
#.#.#.#.#.###.#
#S#...#.#.#...#
#######.#.#.###
#######.#.#...#
#######.#.###.#
###..21...#...#
###.#######.###
#...###...#...#
#.#####.#.###.#
#.#...#.#.#...#
#.#.#.#.#.#.###
#...#...#...###
###############
</code></pre>
<p>各チートには固有の<strong>開始位置</strong>（チートを発動させる位置、壁を通過する最初の移動の直前）と<strong>終了位置</strong>があります。</p>
<!-- ここでちゃんと定義していたか… -->
<p>チートはその開始位置と終了位置によって一意に識別されます。</p>
<p>この例では、チートの総数（節約される時間により分類）は次のとおりです：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">節約ピコ秒</th><th style="text-align: right">個数</th></tr></thead><tbody>
<tr><td style="text-align: right">2</td><td style="text-align: right">14</td></tr>
<tr><td style="text-align: right">4</td><td style="text-align: right">14</td></tr>
<tr><td style="text-align: right">6</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: right">8</td><td style="text-align: right">4</td></tr>
<tr><td style="text-align: right">10</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: right">12</td><td style="text-align: right">3</td></tr>
<tr><td style="text-align: right">20</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: right">36</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: right">38</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: right">40</td><td style="text-align: right">1</td></tr>
<tr><td style="text-align: right">64</td><td style="text-align: right">1</td></tr>
</tbody></table>
</div>
<p>レースコースのコンディションがどうなるかわからないので、
できるだけ多くの選択肢を持つために、最良のチートのリストが必要です。
少なくとも100ピコ秒を節約できるチートはいくつありますか？</p>
<h1 id="パート2-64"><a class="header" href="#パート2-64">パート2</a></h1>
<p>プログラムはあなたのチートのリストに困惑しているようです。
どうやら、2ピコ秒のチートルールは数ミリ秒前に廃止されたようです！
最新版のチート規則では、最大<strong>20ピコ秒</strong>続く単一のチートが可されています。</p>
<p>今、2ピコ秒で可能だった全てのチートに加えて、さらに多くのチートが可能です。
この6ピコ秒のチートは<strong>76ピコ秒</strong>を節約します：</p>
<pre><code>###############
#...#...#.....#
#.#.#.#.#.###.#
#S#...#.#.#...#
#1#####.#.#.###
#2#####.#.#...#
#3#####.#.###.#
#456.E#...#...#
###.#######.###
#...###...#...#
#.#####.#.###.#
#.#...#.#.#...#
#.#.#.#.#.#.###
#...#...#...###
###############
</code></pre>
<p>下図のチートは上図のものと同じ開始位置と終了位置を持っているため、
チート中の経路が異なっていても<strong>同じチート</strong>です：</p>
<pre><code>###############
#...#...#.....#
#.#.#.#.#.###.#
#S12..#.#.#...#
###3###.#.#.###
###4###.#.#...#
###5###.#.###.#
###6.E#...#...#
###.#######.###
#...###...#...#
#.#####.#.###.#
#.#...#.#.#...#
#.#.#.#.#.#.###
#...#...#...###
###############
</code></pre>
<p>チートは20ピコ秒全てを使用する必要はありません。
チートは20ピコ秒までの任意の時間持続することができます。
（ただし、プログラムが通常のコースにいるときにのみ終了できます。）
使用されなかったチート時間は失います。
後のチートのために保存することはできません。</p>
<p>やはり最良のチートのリストが必要ですが、今では選択肢がさらに増えています。
例の地図では、<strong>50ピコ秒以上</strong>を節約するチートの個数は次のとおりです：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">節約ピコ秒</th><th style="text-align: right">個数</th></tr></thead><tbody>
<tr><td style="text-align: right">50</td><td style="text-align: right">32</td></tr>
<tr><td style="text-align: right">31</td><td style="text-align: right">52</td></tr>
<tr><td style="text-align: right">54</td><td style="text-align: right">29</td></tr>
<tr><td style="text-align: right">56</td><td style="text-align: right">39</td></tr>
<tr><td style="text-align: right">58</td><td style="text-align: right">25</td></tr>
<tr><td style="text-align: right">60</td><td style="text-align: right">23</td></tr>
<tr><td style="text-align: right">62</td><td style="text-align: right">20</td></tr>
<tr><td style="text-align: right">64</td><td style="text-align: right">19</td></tr>
<tr><td style="text-align: right">66</td><td style="text-align: right">12</td></tr>
<tr><td style="text-align: right">68</td><td style="text-align: right">14</td></tr>
<tr><td style="text-align: right">70</td><td style="text-align: right">12</td></tr>
<tr><td style="text-align: right">72</td><td style="text-align: right">22</td></tr>
<tr><td style="text-align: right">74</td><td style="text-align: right">4</td></tr>
<tr><td style="text-align: right">76</td><td style="text-align: right">3</td></tr>
</tbody></table>
</div>
<p>更新されたチート規則を使用して最良のチートを見つけてください。
少なくとも100ピコ秒を節約できるチートはいくつありますか？</p>
<details><summary>訳補足</summary>
<p>チートは、始点と終点だけで区別される、というのが規則なので、下図のような状況（英文字はコースとする）について、</p>
<pre><code>###############
abcde..#..vwxyz
###############
</code></pre>
<p>aからv, aからw, …, aからz, bからv,…,eからz の25通りのチートは、どれも中心の壁1枚を抜けるだけで実質同じだが<strong>全て違うものとして数える</strong>。</p>
<p>自分はわざわざこれを同一視する計算を書いて</p>
<pre><code>That's not the right answer; your answer is too low.
</code></pre>
<p>と言われたマヌケです。
問題文をちゃんと読めば</p>
<pre><code>cheats are uniquely identified by their start position and end position.
</code></pre>
<p>と確かに書いてある。</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21日目-キーパッドの謎"><a class="header" href="#21日目-キーパッドの謎">21日目: キーパッドの謎</a></h1>
<p>サンタの<a href="2024/../2019/day25.html">トナカイ級宇宙船</a>にテレポートすると、歴史学者たちはパニックに陥ります：
彼ら捜索隊の誰かが<strong>行方不明</strong>です。
宇宙船のコンピュータによる迅速な生命体スキャンにより、行方不明の歴史学者は、
テレポートした際に船の別の部分に到着したことが明らかになります。</p>
<p>そのエリアへのドアはロックされていますが、コンピュータでは開けることができません。
ドアの数字キーパッドでドアコード（あなたのパズル入力）を<strong>物理的に入力する</strong>ことでのみ開けることができます。</p>
<p>数字キーパッドは4行のボタンで構成されています：<code>789</code>, <code>456</code>, <code>123</code> そして最後に空欄の後に <code>0A</code> があります。
視覚的には、次のように配置されています：</p>
<pre><code>+---+---+---+
| 7 | 8 | 9 |
+---+---+---+
| 4 | 5 | 6 |
+---+---+---+
| 1 | 2 | 3 |
+---+---+---+
    | 0 | A |
    +---+---+
</code></pre>
<p>残念ながら、ドアの外のエリアは現在<strong>減圧</strong>されており、誰もドアの近くに行くことができません。</p>
<!--なら開けたらダメなのでは？ -->
<p>代わりにロボットを送る必要があります。</p>
<p>ロボットは、船内を移動し数字キーパッドを見つけることには問題ありませんが、ボタンを押すために設計されていません：
特定のボタンを直接押すように指示することはできません。
代わりに、<strong>方向キーパッド</strong>で遠隔操作できるロボットアームがあります。</p>
<p>方向キーには2行のボタンがあります：1行目は 隙間、<code>^</code> (上) 、<code>A</code> (作動) があり、
2行目には <code>&lt;</code> (左)、 <code>v</code> (下)、<code>&gt;</code> (右) があります。
視覚的には、次のように配置されています：</p>
<pre><code>    +---+---+
    | ^ | A |
+---+---+---+
| &lt; | v | &gt; |
+---+---+---+
</code></pre>
<p>ロボットが数字キーに到着すると、そのロボットアームは右下隅の <code>A</code> ボタンを指しています。
その後、この方向キーを使用してロボットアームを操作する必要があります：
上/下/左/右のボタンを押すと、アームがその方向にボタンひとつ分移動し、
<code>A</code> ボタンを押すとロボットが前に少し進み、ロボットアームが狙っているボタンを押します。</p>
<p>例えば、ロボットに数字キーで <code>029A</code> を入力させるために、方向キーで使用できる一連入力列は次のとおりです：</p>
<ul>
<li><code>&lt;</code> <code>A</code>（初期位置）から <code>0</code> にアームを移動させる</li>
<li><code>A</code> で <code>0</code> ボタンを押す</li>
<li><code>^A</code> でアームを <code>2</code> ボタンに移動させて押す</li>
<li><code>&gt;^^A</code> でアームを <code>9</code> ボタンに移動させて押す</li>
<li><code>vvvA</code> でアームを <code>A</code> ボタンに移動させて押す</li>
</ul>
<p>全体で、ロボットが <code>029A</code> を入力するための方向キーでのボタン押下の最短系列は3つあります：
<code>&lt;A^A&gt;^^AvvvA</code>, <code>&lt;A^A^&gt;^AvvvA</code>, <code>&lt;A^A^^&gt;AvvvA</code> です。</p>
<p>残念ながら、この方向キーリモコンがあるエリアは現在、<strong>高レベルの放射線</strong>を受けており、誰も近づくことができません。
代わりにロボットを送る必要があります。</p>
<p>ロボットが方向キーに到着すると、そのロボットアームは右上隅の <code>A</code> ボタンを指しています。
その後、<strong>別の第二の</strong>方向キーリモコンが使用されて、このロボットを制御します。
（最初のロボットと同じ方法ですが、こちらは数字キーではなく方向キーを打っています。）</p>
<p>このロボットが最初のロボットに <code>029A</code> をドアに入力するよう指示するための、
方向キーのボタン押下の可能な最短の入力系列は複数あります。
その一例は <code>v&lt;&lt;A&gt;&gt;^A&lt;A&gt;AvA&lt;^AA&gt;A&lt;vAAA&gt;^A</code> です。</p>
<p>残念ながら、この第二の方向キーリモコンがあるエリアは現在<strong>マイナス40度</strong>です！
別のロボットを送って、その方向キーを押す必要があります。</p>
<p>このロボットが第二のロボットに、第一のロボットに最終的に <code>029A</code> をドアに入力するように指示するための、
方向キーのボタンを押す最短の可能なシーケンスは多数あります。
その一例は <code>&lt;vA&lt;AA&gt;&gt;^AvAA&lt;^A&gt;A&lt;v&lt;A&gt;&gt;^AvA^A&lt;vA&gt;^A&lt;v&lt;A&gt;^A&gt;AAvA^A&lt;v&lt;A&gt;A&gt;^AAAvA&lt;^A&gt;A</code> です。</p>
<p>残念ながら、この第三の方向キーリモコンがあるエリアは現在<strong>歴史学者でいっぱい</strong>なので、
ロボットはそこまでたどり着くことができません。
代わりに、<strong>あなたが</strong>この系列を自分で入力する必要があります。</p>
<p>このボタン押下の系列を選択した場合、あなたの方向キー、
2台のロボットの方向キー、および数字キーで押される全てのボタンは次のとおりです：</p>
<pre><code>&lt;vA&lt;AA&gt;&gt;^AvAA&lt;^A&gt;A&lt;v&lt;A&gt;&gt;^AvA^A&lt;vA&gt;^A&lt;v&lt;A&gt;^A&gt;AAvA^A&lt;v&lt;A&gt;A&gt;^AAAvA&lt;^A&gt;A
v&lt;&lt;A&gt;&gt;^A&lt;A&gt;AvA&lt;^AA&gt;A&lt;vAAA&gt;^A
&lt;A^A&gt;^^AvvvA
029A
</code></pre>
<p>まとめると、次のキーパッドがあります：</p>
<ul>
<li><strong>あなた</strong>が使用している方向キーパッドが1つ</li>
<li><strong>ロボット</strong>が使用している方向キーパッドが2つ</li>
<li><strong>ロボット</strong>が使用している（ドアの）数字キーパッドが1つ</li>
</ul>
<p>これらのロボットはボタンを押すために設計されていないことを覚えておくことが重要です。
特に、ロボットアームがキーパッド上にボタンが存在しない<strong>空欄</strong>を指している場合、
たとえ一瞬でも、ロボットは回復不可能な<strong>パニック</strong>に陥ります。
だから、それをしないでください。
全てのロボットは最初にキーパッドの <code>A</code> キーを指します。それがどこにあろうと。</p>
<p>ドアを解除するには、数値キーパッドに<strong>5つ</strong>のコードを入力する必要があります。例えば：</p>
<pre><code>029A
980A
179A
456A
379A
</code></pre>
<p>これらのそれぞれについて、数値キーパッドで目的のコードを入力するために押すべき最短のボタン系列は例えば次のとおりです：</p>
<pre><code>029A: &lt;vA&lt;AA&gt;&gt;^AvAA&lt;^A&gt;A&lt;v&lt;A&gt;&gt;^AvA^A&lt;vA&gt;^A&lt;v&lt;A&gt;^A&gt;AAvA^A&lt;v&lt;A&gt;A&gt;^AAAvA&lt;^A&gt;A
980A: &lt;v&lt;A&gt;&gt;^AAAvA^A&lt;vA&lt;AA&gt;&gt;^AvAA&lt;^A&gt;A&lt;v&lt;A&gt;A&gt;^AAAvA&lt;^A&gt;A&lt;vA&gt;^A&lt;A&gt;A
179A: &lt;v&lt;A&gt;&gt;^A&lt;vA&lt;A&gt;&gt;^AAvAA&lt;^A&gt;A&lt;v&lt;A&gt;&gt;^AAvA^A&lt;vA&gt;^AA&lt;A&gt;A&lt;v&lt;A&gt;A&gt;^AAAvA&lt;^A&gt;A
456A: &lt;v&lt;A&gt;&gt;^AA&lt;vA&lt;A&gt;&gt;^AAvAA&lt;^A&gt;A&lt;vA&gt;^A&lt;A&gt;A&lt;vA&gt;^A&lt;A&gt;A&lt;v&lt;A&gt;A&gt;^AAvA&lt;^A&gt;A
379A: &lt;v&lt;A&gt;&gt;^AvA^A&lt;vA&lt;AA&gt;&gt;^AAvA&lt;^A&gt;AAvA^A&lt;vA&gt;^AA&lt;A&gt;A&lt;v&lt;A&gt;A&gt;^AAAvA&lt;^A&gt;A
</code></pre>
<p>歴史学者たちは神経質になってきています。
船のコンピュータは、行方不明の歴史学者が閉じ込められているエリアが、
<strong>巨大な電磁石</strong>のある場所なのか<strong>どろどろの溶岩</strong>の中なのか覚えていません。
あなたは5つのコードそれぞれについて、必要なボタン押下の<strong>最短の系列</strong>を見つける必要があります。</p>
<p>単一のコード（例えば <code>029A</code>）の<strong>複雑さ</strong>は、次のふたつ値を掛け算した結果に等しいです：</p>
<ul>
<li>コードを数値キーパッドに入力するために、方向キーのキーパッドで入力する必要がある最短のボタン押下系列の長さ
ー <code>029A</code> の場合、これは 68 です。</li>
<li><strong>コードの数値部分</strong>（先頭のゼロを無視する）
ー <code>029A</code> の場合、これは29です。</li>
</ul>
<p>上記の例では、5つのコードの複雑さは $68 \times 29$, $60 \times 980$, $68 \times 179$,
$64 \times 456$, $64 \times 379$ を計算することで求められます。
これらを合計すると126384になります。</p>
<p>ドアの前のロボットに各コードを入力させるために必要な最小のボタン押下回数を見つけてください。
リストにある5つのコードの複雑さの合計はいくつですか？</p>
<h1 id="パート2-65"><a class="header" href="#パート2-65">パート2</a></h1>
<p>行方不明の歴史学者が解放されると、歴史学者たちは探索隊のメンバーが
<strong>もう一人</strong>この間ずっと行方不明であることに気づきます！</p>
<p>迅速な生命体スキャンにより、この歴史学者も船のロックされたエリアに閉じ込められていることが明らかになります。
さまざまな危険があるため、再びロボットが派遣され、
ロボットアームを持つロボットを管理する遠隔操作キーパッドの別の連鎖が形成されます。</p>
<p>今回は、さらに多くのロボットが関与しています。
要約すると、以下のキーパッドがあります：</p>
<ul>
<li>ひとつの方向キーパッドを<strong>あなた</strong>が操作しています</li>
<li>25の方向キーパッドを<strong>ロボット</strong>が操作しています</li>
<li><strong>ロボット</strong>が操作している数値キーパッドがドアにあります</li>
</ul>
<p>前と同じように、キーパッドは連鎖を形成します。
あなたの方向キーパッドがロボットを制御し、そのロボットが方向キーパッドでタイピングし、
その方向キーパッドが別のロボットを制御し、そのロボットが方向キーパッドでタイピングし…と続き、
最後は数値キーパッドでタイピングしているロボットになります。</p>
<p>ドアのコードは今回も同じで、ロボットの数と方向キーの数だけが変わりました。</p>
<p>ドアの前にいるロボットが各コードを入力するために必要なボタン押下の最小回数を見つけてください。
リストにある5つのコードの複雑さの合計はいくつですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22日目-猿市場"><a class="header" href="#22日目-猿市場">22日目: 猿市場</a></h1>
<p>あなたたちがジャングルの奥深くにテレポートされると、
<a href="2024/../2022/day11.html">猿</a>が歴史学者たちの装置を盗んでしまいます！
歴史学者たちが主任を探している間に、それを取り戻さなければなりません。</p>
<p>装置を盗んだ猿は、交換条件として途方もない数のバナナを要求しているようです。
あなたの唯一の選択肢は、猿交換市場でバナナを買うことです。</p>
<p>猿交換市場がどのように機能するのかはわかりませんが、歴史学者の一人が危機を察して助けに来てくれます。
どうやら、彼らはここの猿を研究していたことがあり、彼らの秘密を解読しているようです。</p>
<p>今日は、市場には<strong>良い隠れ場所</strong>を買いに来た猿がいっぱいいます。
幸運なことに、最近このジャングルで過ごした時間のおかげで、
売ることができる良い隠れ場所をあなたはたくさん知っています！
十分な隠れ場所を売れば、デバイスを買い戻すための十分なバナナを手に入れることができるでしょう。</p>
<p>市場では、買い手はランダムな価格を使っているようですが、実際には彼らの価格は単なる擬似乱数です！
彼らが価格を決める秘密を知っていれば、最適な売りどきを待つことができます。</p>
<p>秘密についての部分は文字通りです、と歴史学者は説明します。
バイヤーはそれぞれ、前の秘密の数から導き出された秘密の数の擬似乱数列を生成します。</p>
<p>特に、各バイヤーの<strong>秘密</strong>の数は、次の手順を経て、列の次の秘密の数が導かれます。</p>
<ul>
<li><strong>秘密の数に64を掛けた</strong>結果を計算します。次に、この結果を秘密の数に<strong>混ぜます</strong>。最後に、秘密の番号を<strong>剪定</strong>します。</li>
<li><strong>秘密の数を32で割った</strong>結果を計算します。結果は最も近い整数に切り捨てます。
次に、この結果を秘密の数に<strong>混ぜます</strong>。最後に、秘密の数を<strong>剪定</strong>します。</li>
<li><strong>秘密の数に2048を掛けた</strong>結果を計算します。次に、この結果を秘密の数に<strong>混ぜます</strong>。最後に、秘密の数を<strong>剪定</strong>します。</li>
</ul>
<p>上記の手順の各段階には、<strong>混ぜる</strong>ことと<strong>剪定</strong>が含まれます：</p>
<ul>
<li>値を秘密の数に<strong>混ぜる</strong>には、与えられた値と秘密の数の<a href="https://ja.wikipedia.org/wiki/%E3%83%93%E3%83%83%E3%83%88%E6%BC%94%E7%AE%97#%E3%83%93%E3%83%83%E3%83%88%E3%82%B7%E3%83%95%E3%83%88">ビット単位XOR</a>を計算します。
すると、秘密の数はその操作の結果になります。
（秘密の数が42で、15を秘密の数に<strong>混ぜる</strong>と、秘密の数は37になります。）</li>
<li>秘密の数を<strong>剪定</strong>するには、秘密の数を16777216で<a href="https://ja.wikipedia.org/wiki/%E5%89%B0%E4%BD%99%E6%BC%94%E7%AE%97">割った余り</a>を計算します。
すると、秘密の数はその操作の結果になります。
（秘密の数が100000000で、秘密の数を<strong>剪定</strong>すると、秘密の数は16113920になります。）</li>
</ul>
<p>この手順が完了すると、バイヤーは列の次の秘密の数を得ます。
バイヤーは、より多くの秘密の数を生成するために、この手順を必要なだけ繰り返すことができます。</p>
<p>したがって、あるバイヤーが秘密の数 123 を持っている場合、
そのバイヤーの次に続く10個の秘密の数は次のようになります：</p>
<pre><code>15887950
16495136
527345
704524
1553684
12683156
11100544
12249484
7753432
5908254
</code></pre>
<p>各バイヤーは価格を選ぶ際に自分の秘密の数を使用するため、各バイヤーの秘密の数の列を予測できることが重要です。
幸いなことに、歴史学者の研究により、<strong>各バイヤーの秘密の数の初期値</strong>が明らかになりました（あなたのパズルの入力）。
例えば：</p>
<pre><code>1
10
100
2024
</code></pre>
<p>このリストは、猿交換市場の異なる4人の秘密の隠れ場所バイヤーの初期の数の初期値です。
各バイヤーからの秘密の数をシミュレートできれば、彼らの将来の価格を全て予測できるようになります。</p>
<p>1日のうちに、バイヤーはそれぞれ2000の<strong>新しい</strong>秘密の数を生成する時間があります。
この例では、各バイヤーの秘密の数の初期値と、彼らが生成する2000番目の新しい秘密の数は次のとおりです。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">初期値</th><th style="text-align: right">2000番め</th></tr></thead><tbody>
<tr><td style="text-align: right">1</td><td style="text-align: right">8685429</td></tr>
<tr><td style="text-align: right">10</td><td style="text-align: right">4700978</td></tr>
<tr><td style="text-align: right">100</td><td style="text-align: right">15273692</td></tr>
<tr><td style="text-align: right">2024</td><td style="text-align: right">8667524</td></tr>
</tbody></table>
</div>
<p>各バイヤーについて2000番目の新しい秘密の数を足し合わせると、37327623になります。</p>
<p>各バイヤーについて、2000の新しい秘密の数の生成をシミュレートします。
各バイヤーにより生成された2000番目の秘密の数の合計はいくつですか？</p>
<h1 id="パート2-66"><a class="header" href="#パート2-66">パート2</a></h1>
<p>もちろん、秘密の数は各バイヤーが提示している価格ではありません！それはばかげています。
そうではなく、バイヤーが提示する<strong>価格</strong>は、それぞれの秘密の数の<strong>一の位の数字</strong>です。</p>
<p>したがって、バイヤーが秘密の数123から始めると、そのバイヤーの最初の10回の<strong>価格</strong>は次のようになります：</p>
<pre><code>3 (123 の)
0 (15887950 の)
6 (16495136 の)
5 (以下同様)
4
4
6
4
4
2
</code></pre>
<p>この価格は、バイヤーがあなたの新しい隠れ場所に関する情報と引き換えに提供している<strong>バナナ</strong>の数です。
しかし、あなたはまだ<a href="2024/../../2022/day21/quiz.html">猿の言葉</a>を話せないので、バイヤーと直接交渉することはできません。
歴史学者は少し話せますが、交渉するには十分ではありません。
その代わりに、彼は別の猿にあなたの代わりに交渉を頼むことができます。</p>
<p>残念ながら、その猿は価格の<strong>変動</strong>を見て売るタイミングを決めることしかできません。
具体的には、その猿は<strong>4つの連続した価格変動の特定の列</strong>を探し、その列を見たらすぐに売却します。</p>
<p>したがって、バイヤーが秘密の数123から始まる場合、そのバイヤーの最初の10個の秘密の数、価格、
および対応する変動は次のようになります:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">秘密の数</th><th style="text-align: center">価格</th><th style="text-align: right">変動</th></tr></thead><tbody>
<tr><td style="text-align: right">123</td><td style="text-align: center">3</td><td style="text-align: right"></td></tr>
<tr><td style="text-align: right">15887950</td><td style="text-align: center">0</td><td style="text-align: right">-3</td></tr>
<tr><td style="text-align: right">16495136</td><td style="text-align: center">6</td><td style="text-align: right">6</td></tr>
<tr><td style="text-align: right">527345</td><td style="text-align: center">5</td><td style="text-align: right">-1</td></tr>
<tr><td style="text-align: right">704524</td><td style="text-align: center">4</td><td style="text-align: right">-1</td></tr>
<tr><td style="text-align: right">1553684</td><td style="text-align: center">4</td><td style="text-align: right">0</td></tr>
<tr><td style="text-align: right">12683156</td><td style="text-align: center">6</td><td style="text-align: right">2</td></tr>
<tr><td style="text-align: right">11100544</td><td style="text-align: center">4</td><td style="text-align: right">-2</td></tr>
<tr><td style="text-align: right">12249484</td><td style="text-align: center">4</td><td style="text-align: right">0</td></tr>
<tr><td style="text-align: right">7753432</td><td style="text-align: center">2</td><td style="text-align: right">-2</td></tr>
</tbody></table>
</div>
<p>最初の価格には比較する前の価格がないため、対応する変動はありません。</p>
<p>この短い例では、最初の数個の価格の中で最高価格は6になるので、猿にその時に売るよう指示を出すと良いでしょう。
最初の6はわずか2回の変動の後に出現するため、その時に猿に売るよう指示することはできません。
しかし、2回目の6は変動 -1,-1,0,2 の後に出現します。
したがって、この変動の列を猿に与えれば、猿はその列を初めて見るまで待ち、
その後直ちに現在の価格で隠れ場所の情報を売り、6本のバナナを得ることができます。</p>
<p>各バイヤーは隠れ場所をひとつだけしか購入したくないので、隠れ場所が売れた後、猿は次のバイヤーに移ります。
もし猿がバイヤーから指示されたその価格変動の列を聞かなければ、猿は決して売らず、代わりに次のバイヤーに移動します。</p>
<p>さらに悪いことに、探すための価格変動の列は、猿に与えられるのは<strong>一つだけ</strong>です。
バイヤーごとに列を変更することはできません。</p>
<p>あなたはできるだけ多くのバナナが必要になるので、
<strong>どの4つの価格変動の例が全体として最も多くのバナナを得る</strong>ことができるかを決める必要があります。
各バイヤーは、秘密の数の初期値の後に2000の秘密の数を生成するので、
各バイヤーについて、あなたの列が出現する<strong>2000の価格変動</strong>があります。</p>
<p>各バイヤーの秘密の数の初期値が次のとおりだとします：</p>
<pre><code>1
2
3
2024
</code></pre>
<p>猿に伝えることができる4つの価格変動の列はたくさんありますが、
これら4人のバイヤーに対して、最も多くのバナナを得られる列は -2,1,-1,3 です。
この列を使用すると、猿は次のように販売します：</p>
<ul>
<li>秘密の数の初期値が1のバイヤーに対して、変動 -2,1,-1,3 は最初に価格が7のときに出現します</li>
<li>秘密の数の初期値が2のバイヤーに対して、変動 -2,1,-1,3 は最初に価格が7のときに出現します</li>
<li>秘密の数の初期値が3のバイヤーに対して、変動 -2,1,-1,3 は最初の2000回の変動の中には<strong>出現しません</strong>。</li>
<li>初期値が2024のバイヤーに対して、変動 -2,1,-1,3 は最初に価格が9のときに発生します。</li>
</ul>
<p>したがって、猿に各バイヤーの価格が2下がり、次に1上がり、次に1下がり、最後に3上がった最初のときに
売るように頼むと、23（7 + 7 + 9）バナナを得ることができます！</p>
<p>全てのバイヤーの将来の価格でその変動の列を探すことで、合計で最も多くのバナナを得ることができる、
猿に伝えるべき最良の列を見つけてください。そうして得られる最も多くのバナナはどれだけですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="23日目-lanパーティ"><a class="header" href="#23日目-lanパーティ">23日目: LANパーティ</a></h1>
<p>歴史学者たちがイースターバニー本部の安全なエリアを歩き回っていると、
今日予定されている<a href="https://ja.wikipedia.org/wiki/LAN%E3%83%91%E3%83%BC%E3%83%86%E3%82%A3%E3%83%BC">LANパーティ</a>のポスターを見つけます！
もしかしたら見つけられるかもしれません。
近くの<a href="2024/../2016/day9.html">データリンクポート</a>に接続して、
ローカルネットワークの地図をダウンロードします（あなたのパズル入力）。</p>
<p>ネットワークマップは、全ての<strong>2台のコンピュータ間の接続</strong>のリストを提供します。例えば：</p>
<pre><code>kh-tc
qp-kh
de-cg
ka-co
yn-aq
qp-ub
cg-tb
vc-aq
tb-ka
wh-tc
yn-cg
kh-ub
ta-co
de-co
tc-td
tb-wq
wh-td
ta-ka
td-qp
aq-cg
wq-ub
ub-vc
de-ta
wq-aq
wq-vc
wh-yn
ka-de
kh-ta
co-tc
wh-qp
tb-vc
td-yn
</code></pre>
<p>ネットワークマップの各テキスト行はひとつの接続を表しています。
行 <code>kh-tc</code> は、<code>kh</code> という名前のコンピュータと <code>tc</code> という名前のコンピュータの間の接続を表します。
接続は方向がなく、<code>tc-kh</code> も全く同じ意味になります。</p>
<p>LANパーティは通常マルチプレイヤーゲームを行うため、
接続されたコンピュータのグループを見つけることで場所を特定できるかもしれません。
まず、<strong>3台のコンピュータのセット</strong>で、
セット内の各コンピュータが他の2台のコンピュータに接続されているものを探してみてください。</p>
<p>この例では、相互接続された3台のコンピュータのセットが12組あります：</p>
<pre><code>aq,cg,yn
aq,vc,wq
co,de,ka
co,de,ta
co,ka,ta
de,ka,ta
kh,qp,ub
qp,td,wh
tb,vc,wq
tc,td,wh
td,wh,yn
ub,vc,wq
</code></pre>
<p>もし主任歴史学者がここにいて、<strong>かつ</strong>彼がLANパーティーに参加しているなら、すぐにそれを知っておくのが最善です。
彼のコンピュータの名前は <code>t</code> で始まるとあなたは確信しているので、
3台のコンピュータのセットのうち少なくとも1台のコンピュータの名前が
<code>t</code> で始まるもののみを考慮してください。
それにより、相互接続された3台のコンピュータのセットが7つに絞られます：</p>
<pre><code>co,de,ta
co,ka,ta
de,ka,ta
qp,td,wh
tb,vc,wq
tc,td,wh
td,wh,yn
</code></pre>
<p>相互接続された3台のコンピュータのセ全てットを見つけてください。
その中で、少なくとも1台のコンピュータの名前が <code>t</code> で始まるものはいくつありますか？</p>
<h1 id="パート2-67"><a class="header" href="#パート2-67">パート2</a></h1>
<p>全ての結果を確認するにはまだ多すぎます。
別の方法でLANパーティを見つけて、自分の足でそこへ行く必要があります。</p>
<p>従業員が周りにいないようなので、彼らは皆LANパーティにいるに違いないと考えます。
もしそれが本当なら、LANパーティは<strong>全て互いに接続されているコンピュータの最大のセット</strong>になります。
つまり、LANパーティの各コンピュータは、LANパーティの他の全てのコンピュータに接続されています。</p>
<p>上の例では、全て互いに接続されているコンピュータの最大のセットは <code>co</code>, <code>de</code>, <code>ka</code>, <code>ta</code> で構成されています。
このセットの各コンピュータは、セット内の他の全てのコンピュータに接続されています：</p>
<pre><code>ka-co
ta-co
de-co
ta-ka
de-ta
ka-de
</code></pre>
<p>LANパーティのポスターには、LANパーティに入るための<strong>パスワード</strong>は、
LANパーティのすべてのコンピュータの名前をアルファベット順に並べて、
カンマで結合したものであると書かれています。
（LANパーティを運営している人たちは明らかにオタクの集まりです。）
この例では、パスワードは <code>co,de,ka,ta</code> になります。</p>
<p>LANパーティに入るためのパスワードは何ですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="24日目こんがらがった配線"><a class="header" href="#24日目こんがらがった配線">24日目：こんがらがった配線</a></h1>
<p>あなたと歴史学者たちは、ジャングルのどこかにある<a href="2024/../2022/day23.html">大きな林</a>の端に到着します。
最後の事件の後、妖精たちは果物を監視する小さな装置を設置しました。
歴史学者たちが林を探している間、彼らの一人が監視装置を見てくれないかと尋ねます。
どうやら最近故障したようです。</p>
<p>その装置はブール論理ゲートを通じて数値を生成しようとしているようです。
各ゲートには2つの入力と1つの出力があります。
ゲートは全て、<strong>真</strong> (<code>1</code>) または<strong>偽</strong> (<code>0</code>) の値を扱います。</p>
<ul>
<li>ANDゲートは、<strong>両方</strong>の入力が<code>1</code>の場合に<code>1</code>を出力します。いずれかの入力が<code>0</code>の場合、これらのゲートは<code>0</code>を出力します。</li>
<li>ORゲートは、<strong>1つまたは両方</strong>の入力が<code>1</code>の場合に<code>1</code>を出力します。両方の入力が<code>0</code>の場合、これらのゲートは<code>0</code>を出力します。</li>
<li>XORゲートは、入力が<strong>異なる</strong>場合に<code>1</code>を出力します。入力が同じ場合、これらのゲートは<code>0</code>を出力します。</li>
</ul>
<p>ゲートは、出力を生成する前に両方の入力が受信されるのを待ちます。
配線は <code>0</code>, <code>1</code> を伝送するか、または全く値を持たないことができます。
ループはありません。
ゲートがひとたび出力を決定すると、その出力はシステム全体がリセットされるまで変化しません。
各配線は最大で1つのゲート出力に接続されますが、多くのゲート入力に接続することができます。</p>
<p>動作中のシステムをいじって感電するリスクを冒すのではなく、
ゲートの接続と配線の初期値を全て書き留めて（あなたのパズル入力）、
比較的安全に検討できるようにします。例えば：</p>
<pre><code>x00: 1
x01: 1
x02: 1
y00: 0
y01: 1
y02: 0

x00 AND y00 -&gt; z00
x01 XOR y01 -&gt; z01
x02 OR y02 -&gt; z02
</code></pre>
<p>ゲートは入力を待っているため、いくつかの配線は値を持って始まる必要があります（システム全体への入力として）。
前半はこれらの値を指定します。
例えば <code>x00: 1</code> は <code>x00</code> という名前の配線が値 <code>1</code> で始まることを意味します
（ゲートが既にその配線にその値を出力しているかのように）。</p>
<p>後半では、全てのゲートとそれに接続されている配線を列挙します。
例えば <code>x00 AND y00 -&gt; z00</code> は、入力に配線 <code>x00</code> と <code>y00</code> が接続され
その出力を配線 <code>z00</code> に書き込む<code>AND</code>ゲートがあることを述べています。</p>
<p>この例では、これらのゲートをシミュレーションすると、
最終的に配線<code>z00</code>に<code>0</code>が、配線<code>z01</code>に<code>0</code>が、配線<code>z02</code>に<code>1</code>が現れます。</p>
<p>最終的に、システムは <code>z</code> で始まる全ての配線のビットを組み合わせて<strong>数値</strong>を生成しようとしています。
<code>z00</code>は最下位ビットで、次に<code>z01</code>、次に<code>z02</code>、以下同様に続きます。</p>
<p>この例では、3つの出力ビットが2進数の<code>100</code>を形成し、これは10進数の<strong>4</strong>に相当します。</p>
<p>より大きな例を示します：</p>
<pre><code>x00: 1
x01: 0
x02: 1
x03: 1
x04: 0
y00: 1
y01: 1
y02: 1
y03: 1
y04: 1

ntg XOR fgs -&gt; mjb
y02 OR x01 -&gt; tnw
kwq OR kpj -&gt; z05
x00 OR x03 -&gt; fst
tgd XOR rvg -&gt; z01
vdt OR tnw -&gt; bfw
bfw AND frj -&gt; z10
ffh OR nrd -&gt; bqk
y00 AND y03 -&gt; djm
y03 OR y00 -&gt; psh
bqk OR frj -&gt; z08
tnw OR fst -&gt; frj
gnj AND tgd -&gt; z11
bfw XOR mjb -&gt; z00
x03 OR x00 -&gt; vdt
gnj AND wpb -&gt; z02
x04 AND y00 -&gt; kjc
djm OR pbm -&gt; qhw
nrd AND vdt -&gt; hwm
kjc AND fst -&gt; rvg
y04 OR y02 -&gt; fgs
y01 AND x02 -&gt; pbm
ntg OR kjc -&gt; kwq
psh XOR fgs -&gt; tgd
qhw XOR tgd -&gt; z09
pbm OR djm -&gt; kpj
x03 XOR y03 -&gt; ffh
x00 XOR y04 -&gt; ntg
bfw OR bqk -&gt; z06
nrd XOR fgs -&gt; wpb
frj XOR qhw -&gt; z04
bqk OR frj -&gt; z07
y03 OR x01 -&gt; nrd
hwm AND bqk -&gt; z03
tgd XOR rvg -&gt; z12
tnw OR pbm -&gt; gnj
</code></pre>
<p><code>z</code>で始まる全ての配線の値を待った後、このシステムの配線は次の値を持っています：</p>
<pre><code>bfw: 1
bqk: 1
djm: 1
ffh: 0
fgs: 1
frj: 1
fst: 1
gnj: 1
hwm: 1
kjc: 0
kpj: 1
kwq: 0
mjb: 1
nrd: 1
ntg: 0
pbm: 1
psh: 1
qhw: 1
rvg: 0
tgd: 0
tnw: 1
vdt: 1
wpb: 0
z00: 0
z01: 0
z02: 0
z03: 1
z04: 0
z05: 1
z06: 1
z07: 1
z08: 1
z09: 1
z10: 1
z11: 0
z12: 0
</code></pre>
<p>全ての<code>z</code>で始まる配線のビットを組み合わせると、二進数<code>0011111101000</code>が生成されます。
この数を10進数に変換すると2024になります。</p>
<p>ゲートと配線のシステムをシミュレートします。
<code>z</code>で始まる配線に出力される10進数はいくつですか？</p>
<h1 id="パート2-68"><a class="header" href="#パート2-68">パート2</a></h1>
<p>監視装置をより詳しく調査した結果、シミュレーションしているシステムが
<strong>ふたつの2進数を加算</strong>しようとしていることがわかりました。</p>
<p>具体的には、<code>x</code> で始まる配線のビットをひとつの2進数として扱い、
<code>y</code> で始まる配線のビットをふたつめの2進数として扱い、
それらふたつの数を加算しようとしています。
この演算の出力は、<code>z</code> で始まる配線上に2進数として生成されます。
（3つの場合全てにおいて、配線<code>00</code>が最下位ビットで、その後に<code>01</code>, <code>02</code>と続きます。）</p>
<p>あなたのパズル入力にある配線の初期値は、間違った値に合計される数値のペアの<strong>ひとつの実例</strong>を表しています。
最終的には、入力として与えられる<strong>任意の</strong>2つの2進数は正しく処理されるべきです。
つまり、<code>x</code> で始まる配線と <code>y</code> で始まる配線のビットの任意の組み合わせに対して、
それらのビットが表す2つの数の合計が、<code>z</code> で始まるワイヤ上に2進数として生成されるべきです。</p>
<p>例えば、4本の<code>x</code>配線、4本の<code>y</code>配線、5本の<code>z</code>配線を持つ加算システムがあるとき、
<code>x</code>配線に任意の4ビット数を供給し、<code>y</code>配線に任意の4ビット数を供給し、
最終的にその2つの数の合計を<code>z</code>配線に5ビット数として見つけることができるはずです。
このようなシステムに数を提供する方法の1つは、
<code>x</code>配線に<code>11</code>（2進数で<code>1011</code>）を、<code>y</code>配線に<code>13</code>（2進数で<code>1101</code>）を送ることです：</p>
<pre><code>x00: 1
x01: 1
x02: 0
x03: 1
y00: 1
y01: 0
y02: 1
y03: 1
</code></pre>
<p>システムが正しく動作しているならば、全てのゲートの処理が完了した後、
<code>z</code>配線上に5ビットの2進数<code>11000</code>として24 (11+13) がみつかるはずです。</p>
<pre><code>z00: 0
z01: 0
z02: 0
z03: 1
z04: 1
</code></pre>
<p>残念ながら、あなたの実際のシステムは、もっと多くのビットで数を加算する必要があり、そのためにもっと多くの配線があります。</p>
<p>デバイスの擦り傷や傷の科学捜査的分析に基づいて、
出力配線が<strong>入れ替えられた</strong>ゲートのペアがちょうど<strong>4組</strong>あることがわかります。
（ひとつのゲートはそのようなペアのひとつにしか入ることができません。
つまり、ゲートの出力は複数回入れ替えられることはありません。）</p>
<p>例えば、以下のシステムは、<code>x00</code>から<code>x05</code>までの6ビット数と<code>y00</code>から<code>y05</code>までの6ビット数のビット単位のANDを求め、
その結果を<code>z00</code>から<code>z05</code>までの6ビット数として書き込むことになっています：</p>
<pre><code>x00: 0
x01: 1
x02: 0
x03: 1
x04: 0
x05: 1
y00: 0
y01: 0
y02: 1
y03: 1
y04: 0
y05: 1

x00 AND y00 -&gt; z05
x01 AND y01 -&gt; z02
x02 AND y02 -&gt; z01
x03 AND y03 -&gt; z03
x04 AND y04 -&gt; z04
x05 AND y05 -&gt; z00
</code></pre>
<p>しかしこの例では、2組のゲートの出力配線が入れ替わっており、そのためシステムが誤った答えを生成しています。
出力が入れ替わった最初のゲートのペアは <code>x00 AND y00 -&gt; z05</code> と <code>x05 AND y05 -&gt; z00</code> です。
2番目のゲートのペアは <code>x01 AND y01 -&gt; z02</code> と <code>x02 AND y02 -&gt; z01</code> です。
これら2つの入れ替わりを修正すると、<code>x</code>または<code>y</code>で始まる配線の任意の初期値のセットに対して
意図した通りに動作するシステムが得られます：</p>
<pre><code>x00 AND y00 -&gt; z00
x01 AND y01 -&gt; z01
x02 AND y02 -&gt; z02
x03 AND y03 -&gt; z03
x04 AND y04 -&gt; z04
x05 AND y05 -&gt; z05
</code></pre>
<p>この例では、2組のゲートの出力が入れ替わりに関与しています。
出力配線の名前をソートしてカンマで結合すると、
入れ替わりに関与する配線のリストは <code>z00,z01,z02,z05</code> となります。</p>
<p>もちろん、実際のシステムはこれよりもはるかに複雑で、
出力を入れ替える必要があるゲートは<code>z</code>で始まる配線に接続されているものに限らず<strong>どれも</strong>可能性があります。
出力配線<code>aaa</code>と<code>eee</code>を、<code>ooo</code>と<code>z99</code>を、<code>bbb</code>と<code>ccc</code>を、<code>aoc</code>と<code>z24</code>を入れ替える必要があると判明した場合、
あなたの答えは <code>aaa,aoc,bbb,ccc,eee,ooo,z24,z99</code> となります。</p>
<p>あなたのゲートと配線のシステムには、出力配線を入れ替える必要があるゲートが<strong>4組</strong>あります
ー 全部で<strong>8本</strong>の配線です。
あなたのシステムが正しく加算を行うために、どの4組のゲートの出力を入れ替える必要があるかを特定してください。
入れ替えに関与する8本の配線の名前をソートして、それらの名前をカンマで結合すると何になりますか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="25日目-aoc年代記"><a class="header" href="#25日目-aoc年代記">25日目: AoC年代記</a></h1>
<p>アイデアも時間も尽きた歴史学者たちは、念のために<strong>主任歴史学者</strong>のオフィスをもう一度確認しに戻るべきだと合意しました。
彼があなたに気づかれずにそこに戻った可能性があるからです。</p>
<p>そこに着くと、彼のオフィスのドアが<strong>施錠</strong>されていることに驚きます！
中に誰かがいるのが聞こえますが、ノックしても反応はありません。
この階の錠前は全て豪華で高価な、<a href="https://ja.wikipedia.org/wiki/%E3%83%94%E3%83%B3%E3%82%BF%E3%83%B3%E3%83%96%E3%83%A9%E3%83%BC%E9%8C%A0">5ピンのシリンダー錠</a>のバーチャル版なので、
ドアを開ける手助けが頼めるか、北極のセキュリティに連絡します。</p>
<p>残念ながら彼らは、どの錠が取り付けられていて、どの鍵がそれに対応しているのかを見失ってしまっているため、
彼らができる最善のことは、あなたがいるフロアの<strong>全ての錠と全ての鍵の図面</strong>（あなたのパズル入力）を送ることです。</p>
<p>図面は暗号化されたファイル形式ですが、製造元の情報が含まれているため、あなたはメーカーサポートの電話番号を調べます。</p>
<p>「弊社のバーチャル5ピンシリンダー製品ですか？
それは弊社の最も高価なモデルです！<strong>どこよりも</strong>安全でー」
あなたはドアを開ける必要があり、あまり時間がないことを説明します。</p>
<p>「まあ、鍵が錠を開けるかどうかは、実際に鍵を錠に試さなければわかりません（量子隠れ変数のため）、
しかしいくつかの鍵と錠の組み合わせを除外することは<strong>できます</strong>。」</p>
<p>「仮想システムは複雑ですが、その一部は実際には主にマーケティング上の理由から、
5ピンシリンダー錠の粗いシミュレーションです。
図面を見れば、鍵が錠に合う可能性があるかどうかを判断できます。」</p>
<p>彼はあなたにいくつかの図面の例を送信します：</p>
<pre><code>#####
.####
.####
.####
.#.#.
.#...
.....

#####
##.##
.#.##
...##
...#.
...#.
.....

.....
#....
#....
#...#
#.#.#
#.###
#####

.....
.....
#.#..
###..
###.#
###.#
#####

.....
.....
.....
#....
#.#..
#.#.#
#####
</code></pre>
<p>「錠の図面は、最上行が埋まっており（<code>#</code>）と最下行が空いている（<code>.</code>）ものです。
鍵の図面は、最上行が空いていて最下行が埋まっています。
よく見ると、各図面は実際にはさまざまな高さの列の集まりであり、
錠の場合は上から下に、鍵の場合は下から上に伸びています。」</p>
<p>「錠の場合、それらはピンそのものです。図面のピンを列ごとの高さのリストに変換できます。
鍵の場合、列はピンと整列する鍵の形を成しています。それらも高さのリストに変換できます。」</p>
<p>「したがって、最初の錠はピンの高さが <code>0,5,3,4,3</code> であると言えます。」</p>
<pre><code>#####
.####
.####
.####
.#.#.
.#...
.....
</code></pre>
<p>「また、最初の鍵は高さは <code>5,0,2,1,3</code> です。」</p>
<pre><code>.....
#....
#....
#...#
#.#.#
#.###
#####
</code></pre>
<p>「これらは一緒に合うように見えます。
最初の4つの列では、ピンと鍵は重なりません。しかし、この鍵はこの錠には<strong>合いません</strong>。
最も右の列では、錠のピンが鍵と重なっており、その列では錠の高さと鍵の高さの合計が
空間の大きさを超えていることがわかります。」</p>
<p>「とにかく、それぞれの鍵を錠それぞれでテストすることで、試すべき鍵を絞り込むことができます。
つまり、チェックしなければならないのは…
待って、錠は<strong>いくつ</strong>あるのですか？
でも、<strong>その</strong>サイズのものを設置したのは一件だけ、ほっきょー」
あなたは通話を切ります。</p>
<p>この例では、両方の錠をピンの高さに変換すると、次のようになります：</p>
<pre><code>0,5,3,4,3
1,2,0,5,3
</code></pre>
<p>3つの鍵全てを高さに変換すると、次のようになります：</p>
<pre><code>5,0,2,1,3
4,3,4,0,2
3,0,2,0,1
</code></pre>
<p>そして、全ての鍵を全ての錠に試すことができます：</p>
<ul>
<li>錠 <code>0,5,3,4,3</code> と鍵 <code>5,0,2,1,3</code> : 最後の列で<strong>重なり</strong>があります。</li>
<li>錠 <code>0,5,3,4,3</code> と鍵 <code>4,3,4,0,2</code> : 2番目の列で<strong>重なり</strong>があります。</li>
<li>錠 <code>0,5,3,4,3</code> と鍵 <code>3,0,2,0,1</code> : 全ての列が<strong>合います</strong>！</li>
<li>錠 <code>1,2,0,5,3</code> と鍵 <code>5,0,2,1,3</code> : 最初の列で<strong>重なり</strong>があります。</li>
<li>錠 <code>1,2,0,5,3</code> と鍵 <code>4,3,4,0,2</code> : 全ての列が<strong>合います</strong>！</li>
<li>錠 <code>1,2,0,5,3</code> と鍵 <code>3,0,2,0,1</code> : 全ての列が<strong>合います</strong>！</li>
</ul>
<p>この例では、どの列でも重ならずに合う錠と鍵の組み合わせの数は3です。</p>
<p>あなたの錠と鍵の図面を分析してください。
どの列でも重ならずに合う錠と鍵の組み合わせはいくつありますか？</p>
<h1 id="パート2-69"><a class="header" href="#パート2-69">パート2</a></h1>
<p>あなたと歴史学者たちはオフィスに押し入り、主任歴史学者は驚いて目を覚まします！
歴史学者たちは皆、順番に混乱した表情を浮かべ、一人が主任はここ数ヶ月どこにいたのかと尋ねます。</p>
<p>「私はずっとここにいて、サンタからのこの優先度の高いリクエストに取り組んでいました！
私が離れたのは、約1ヶ月前にコーヒーを取りに行ったときだけだと思います…」</p>
<p>その時、主任は時間に気づきます。
「ああ、いけない！遅れそうだ！サンタがリクエストしたこの年代記の仕上げをしようとして寝てしまったに違いない。
サンタが出発する前にリストの残り50か所を訪れて、年代記を完成させる時間が足りない！
サンタは今夜のそりの出発前にこれ必要だと言っていました。」</p>
<p>歴史学者の一人が、これまでずっと使ってきた、どこを探していたかを記録していたリストを掲げます。
皆が訪れた各場所の横には、その場所に<strong>スター</strong>が付けられています。
他の歴史学者たちも旅の間に取った自分のメモを掲げています。
歴史学者として、そんな歴史的に重要な場所を訪れながら、全てを書き留めずにはいられなかったのでしょう。</p>
<p>主任の目が大きく開きます。
「これだけあれば、年代記を完成させるのに時間は十分にあるかもしれません！
サンタはそれをリボンで包んでほしいと言っていたから、ラッピング部門に連絡します…
ああ、それをサンタのところに持って行ってくれませんか？
その頃にはそりの出発を見るために自分の席にいないとならないのです。」</p>
<p>あなたはうなずき、歴史学者たちは急いで年代記の最終ページのためにメモを集めます。</p>
<h2 id="足らない場合"><a class="header" href="#足らない場合">足らない場合</a></h2>
<p>しかし、年代記を完成させるための星が足りません。あと**個必要です。</p>
<h2 id="足りた場合"><a class="header" href="#足りた場合">足りた場合</a></h2>
<p>年代記を届けるのに十分な星があります。</p>
<p>（リンクを進むと）</p>
<p><strong>50個のスター</strong>で示された場所のメモを使って、歴史学者たちは年代記を完成させ、それを包んで、
そりの大発射の前にサンタに届けるようにあなたに渡します。</p>
<p>あなたが到着したとき、サンタはそりの中で最終的な出発準備をしているところでした。
あなたは彼に年代記を渡そうとしますが、彼はそれを受け取りません。
「ホー、ホー、ホー」と彼は自分に笑います。
「その贈り物は私のためではなく、<strong>あなた</strong>のものです。
その年代記は、あなたが過去10年間に訪れた場所や助けた人々の記録です。すべてに感謝します。」
そう言って、サンタは今年の残りのプレゼントを配るためにそりを飛ばします。</p>
<p>（また、興味があれば<a href="https://cottonbureau.com/people/advent-of-code">ショップ</a>に新しいデザインがアップされています。
見えない場合は、少し待ってみてください。）</p>
<p>おめでとうございます！あなたは2024年のAdvent of Codeの全てのパズルを解き終えました！
私があなたのためにそれらを作るのと同じくらい、解くのが楽しかったことを願っています。<!-- はい、とっても。-->
あなたの冒険について聞かせていただけると嬉しいです。
私の<a href="https://was.tl/">ウェブサイト</a>の連絡先情報や<a href="https://bsky.app/profile/was.tl">Bluesky</a>,
<a href="https://hachyderm.io/@ericwastl">Mastodon</a>, <a href="https://twitter.com/ericwastl">Twitter</a>を通じてご連絡いただけます。</p>
<p>将来的にこのようなものをもっと見たい場合は、Advent of Codeを<a href="https://adventofcode.com/2024/support">サポート</a>し、他の人と共有することを検討してください。</p>
<p>各パズルのイースターエッグを<u>ハイライト</u>しましたので、見逃した場合はご確認ください。
それらにマウスを重ねると、イースターエッグが表示されます。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="パート1"><a class="header" href="#パート1">パート1</a></h1>
<p>階数を 0 から始めて、開きカッコで増やし、閉じ括弧で減らせばよい。</p>
<pre><code class="language-haskell">part1 :: String  -- 入力
      -&gt; Int     -- 答え
part1 = foldl step 0

step n '(' = succ n
step n ')' = pred n
</code></pre>
<h1 id="パート2-70"><a class="header" href="#パート2-70">パート2</a></h1>
<p>パート1と同様に現在位置を追跡し、最初に \(-1\) になったところで止めて、
そこまでの位置の個数が答えである。</p>
<pre><code class="language-haskell">part2 :: String -&gt; Int
part2 = length . takeWhile (-1 &lt;) . scanl step 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力"><a class="header" href="#入力">入力</a></h1>
<p>文字 <code>x</code> で区切られているので、空白に置き換えて <code>words</code> を使えば手抜きできる。
3項組も長さ3のリストで代用する。</p>
<pre><code class="language-haskell">runner i f = do
  lwhs &lt;- map parse . lines &lt;$&gt; readFile i
  print $ f lwhs

parse :: String -&gt; [Int,Int,Int]
parse = map read . words . map f
  where
    f 'x' = ' '
    f  c  = c
</code></pre>
<h1 id="パート1-1"><a class="header" href="#パート1-1">パート1</a></h1>
<p>要求どおりに計算するだけ。</p>
<pre><code class="language-haskell">part1 :: [[Int]]  -- l,w,h
      -&gt; Int      -- 答え
part1 = sum . map fun1

fun1 [l,w,h] = minimum as + 2 * sum as
  where
    as = [l * w, w * h, h * l]

main1 = runner "input.txt" part1
</code></pre>
<h1 id="パート2-71"><a class="header" href="#パート2-71">パート2</a></h1>
<p>やはり要求どおりに計算するだけ。</p>
<pre><code class="language-haskell">part2 :: [[Int]]  -- l,w,h
      -&gt; Int      -- 答え
part2 = sum . map fun2

fun2 [l,w,h] = 2 * minimum rs + l * w * h
  where
    rs = [l + w, w + h, h + l]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="パート1-2"><a class="header" href="#パート1-2">パート1</a></h1>
<p>座標がどちらに広がるのか事前に予測できないので、配列で扱うのは難しい。
座標の集合で扱うと制約なく扱いやすい。</p>
<pre><code class="language-haskell">import qualified Data.Set as S

part1 :: String  -- 指示
      -&gt; Int     -- 答え
part1 = S.size . S.fromList . scanl step (0,0)

step (x,y) '^' = (pred x, y)
step (x,y) 'v' = (succ x, y)
step (x,y) '&lt;' = (x, pred y)
step (x,y) '&gt;' = (x, succ y)
</code></pre>
<h1 id="パート2-72"><a class="header" href="#パート2-72">パート2</a></h1>
<p>入力を、サンタ用とメカサンタ用に分離した後はパート1と同じやり方で座標を得て、
合わせてから数えればよい。</p>
<pre><code class="language-haskell">part2 :: String  -- 指示
      -&gt; Int     -- 答え
part2 cs = S.size $ S.union ps1 ps2
  where
    ps1 = go [c | (c, 0) &lt;- zip cs $ cycle [0, 1]]
    ps2 = go [c | (c, 1) &lt;- zip cs $ cycle [0, 1]]

go = S.fromList . scanl step (0,0)
</code></pre>
<p>交互に取り出すには他にも、</p>
<pre><code class="language-haskell">import Data.List (transpose)
import Data.List.Split (chunksOf)

part2 cs = S.size $ S.unions $ map go $ transpose $ chunksOf 2 cs
</code></pre>
<p>のようにしてもできる。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="パート1-3"><a class="header" href="#パート1-3">パート1</a></h1>
<p>これを解くためだけにMD5ハッシュの計算を実装するのはつらいので、ライブラリの力を借りる。
<a href="https://ja.wikipedia.org/wiki/MD5">Wikipedia</a>を見ると、512ビット=64バイトが処理の単位なので、
この問題の入力はまるまる収まるだろう。</p>
<ul>
<li><a href="https://hackage.haskell.org/package/cryptohash-md5">cryptohash-md5</a></li>
<li><a href="https://hackage.haskell.org/package/pureMD5">pureMD5</a></li>
</ul>
<p>あたりを使えばよいだろう。
前者を使ってみる。
<code>hash :: ByteString -&gt; ByteString</code> で、入力は普通に文字列を <code>ByteString</code> 化したもので与えればよいが、
返される結果は文字列ではなく16バイトのバイナリ値で、
問題文のいうところの「<code>0</code>が続く」とは<code>Data.ByteString.Base16.encode</code> した結果が、という意味である。
5文字の0が続くとは、上位 \(4 \times 5\) ビットが0ということで、先頭2バイトは0、
3バイトめは上位4ビットが0なので16未満として判定できるので、<code>encode</code> は使わずに済む。</p>
<pre><code class="language-haskell">import qualified Data.ByteString.Char8 as BS
import qualified Crypto.Hash.MD5 as MD5

part1 :: String  -- 秘密鍵
      -&gt; Int     -- 答え
part1 sk = head
  [ i
  | i &lt;- [1..]
  , let digest = MD5.hash $ BS.pack $ sk ++ show i
  , fromEnum (BS.index digest 0) ==  0
  , fromEnum (BS.index digest 1) ==  0
  , fromEnum (BS.index digest 2) &lt;  16
  ]
</code></pre>
<h1 id="パート2-73"><a class="header" href="#パート2-73">パート2</a></h1>
<pre><code class="language-haskell">part2 :: String  -- 秘密鍵
      -&gt; Int     -- 答え
part2 sk = head
  [ i
  | i &lt;- [1..]
  , let digest = MD5.hash $ BS.pack $ sk ++ show i
  , fromEnum (BS.index digest 0) == 0
  , fromEnum (BS.index digest 1) == 0
  , fromEnum (BS.index digest 2) == 0
  ]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-1"><a class="header" href="#入力-1">入力</a></h1>
<p>行ごとのリストを与える。</p>
<pre><code class="language-haskell">runner f = readFile "input.txt" &gt;&gt;= print . f . lines
</code></pre>
<h1 id="パート1-4"><a class="header" href="#パート1-4">パート1</a></h1>
<p>いい文字列を判定する述語を作る。</p>
<p>「母音を3つ」は、<code>aaa</code> の例でもわかるように、同じ文字が3つでもよいので、数えればよい。</p>
<pre><code class="language-haskell">isVowel x = elem x "aeiou"

cond1 xs = 3 &lt; length (filter isVowel xs)
</code></pre>
<p>あと2つの条件のために、連続する2文字の全ての組を作っておく。</p>
<pre><code class="language-haskell">xys = zip xs (tail xs)
</code></pre>
<p>「続き文字を含む」とは、<code>xys</code> の中に、左右が等しいものがあるということになる。</p>
<pre><code class="language-haskell">cond2 xys = any (uncurry (==)) xys
</code></pre>
<p>特定の対を含まないとは、そのいずれも <code>xys</code> の中に現れないことである。</p>
<pre><code class="language-haskell">cond3 xys = all (flip notElem xys) [('a','b'),('c','d'),('p','q'),('x','y')]
</code></pre>
<p>入力から、これらすべてを満たす語の数を数える。</p>
<pre><code class="language-haskell">part1 :: [String]  -- 入力
      -&gt; Int       -- 答え
part1 = length . filter cond123

cond123 xs = cond1 xs &amp;&amp; cond2 xys &amp;&amp; cond3 xys
  where
    xys = zip xs (tail xs)

main1 = runner part1
</code></pre>
<h1 id="パート2-74"><a class="header" href="#パート2-74">パート2</a></h1>
<p>前者の条件は、パート1の <code>xys</code> で考えると、直後の対は重なりがあるので、それを除いた以降に等しいものがあればよい。
全ての対について調べ、そのようなものが一つあればよい。</p>
<pre><code class="language-haskell">cond4 xs = any sub $ tails xys
  where
    xys = zip xs (tail xs)
    sub (xy : _ : xys) = elem xy xys
    sub _ = False

-- 別解
cond4 xs = not $ null [() | xy:xys &lt;- tails $ zip xs $ tail xs, elem xy $ drop 1 xys]
</code></pre>
<p>別解は、<code>drop</code> が不足について文句を言わないことを使っている。</p>
<p>後者の条件は、<code>xys</code> と同様に対になる文字について判定すればよい。
<code>aaa</code> も該当するとは、間に挟まる文字は何でもいいということなので無視できる。</p>
<pre><code class="language-haskell">cond5 xs = any (uncurry (==)) $ zip xs (drop 2 xs)
</code></pre>
<p>以上をまとめる。</p>
<pre><code class="language-haskell">part2 :: [String]  -- 入力
      -&gt; Int       -- 答え
part2 = length . filter cond5 . filter cond4

main2 = runner part2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-2"><a class="header" href="#入力-2">入力</a></h1>
<p>このように、妙に冗長な入力データを読み取る必要があるのもAoCの特徴。
指示の種類を表す列挙型と、範囲を表す座標の対を組にした指示の型を定義する。</p>
<pre><code class="language-haskell">data Cmd = LOff | LOn | LTgl

type Instr = (Cmd, ((Int,Int),(Int,Int)))
</code></pre>
<p>コンマで区切られた数字列を、二つの整数の対として読み込む補助関数を定義しておく。</p>
<pre><code class="language-haskell">csv :: String -&gt; (Int, Int)
csv xs = (read as, read bs)
  where
    (as, _:bs) = span (',' /=) xs
</code></pre>
<p>一行を読み込むには、まず <code>words</code> で分割し、2語めが何かで見分けると話が早い。
<code>toggle</code>だけ、左上座標がどこにあるかが違う。右下座標は常に末尾にある。</p>
<pre><code class="language-haskell">parse :: String -&gt; (Cmd, ((Int, Int), (Int, Int)))
parse xs =
  case w2 of
    "on"  -&gt; (LOn , (csv w3, xy9))
    "off" -&gt; (LOff, (csv w3, xy9))
    _     -&gt; (LTgl, (csv w2, xy9))
  where
    (_:w2:w3:ws) = words xs
    xy9 = csv (last ws)
</code></pre>
<p>全体を読み込んで処理する。</p>
<pre><code class="language-haskell">runner f = readFile i &gt;&gt;= print f . map parse . lines
</code></pre>
<h1 id="パート1-5"><a class="header" href="#パート1-5">パート1</a></h1>
<p>\(1000 \times 1000\) の配列を作り、指示通りにライトを操作して、最終結果を取り出せばよい。
ここで、<code>Data.Ix.range</code> を使うと、範囲の要素を列挙することが容易にできる。
その結果を <code>accumArray</code> で累積すれば結果が得られる。</p>
<pre><code class="language-haskell">import Data.Ix
import Data.Array

part1 :: [String] -&gt; Int
part1 ls = length $ filter id $ elems arr
  where
    arr = accumArray control1 False ((0,0),(999,999))
          [(xy, cmd) | l &lt;- ls, let (cmd, bnds) = parse l, xy &lt;- range bnds]

control1 :: Bool -&gt; Cmd -&gt; Bool
control1 _ LOn  = True
control1 _ LOff = False
control1 b LTgl = not b
</code></pre>
<h1 id="パート2-75"><a class="header" href="#パート2-75">パート2</a></h1>
<p>パート1では2値だったライトの状態を整数にし、指示に対する操作を定義通りに差し替えればよい。</p>
<pre><code class="language-haskell">part2 :: [String] -&gt; Int
part2 ls = sum $ elems arr
  where
    arr = accumArray control2 0 ((0,0),(999,999))
          [(xy, cmd) | l &lt;- ls, let (cmd, bnds) = parse l, xy &lt;- range bnds]

control2 :: Int -&gt; Cmd -&gt; Int
control2 n LOn  = succ n
control2 n LOff = max 0 (pred n)
control2 n LTgl = n + 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-3"><a class="header" href="#入力-3">入力</a></h1>
<p>16ビット非負整数のビット単位論理演算を用いるので、それ用のライブラリを読み込んでおく。</p>
<pre><code class="language-haskell">import Data.Word
import Data.Bits
</code></pre>
<p>行の形式は「(式) <code>-&gt;</code> (信号名)」となっている。
式には</p>
<ul>
<li>(信号)　これは演算を通さず、直結することを意味する</li>
<li>(信号) (演算) (信号) の形式で、演算は <code>AND</code> <code>OR</code></li>
<li>(信号) (シフト演算) (数字列) の形式で、演算は <code>LSHIFT</code> <code>RSHIFT</code></li>
<li><code>NOT</code> (信号)</li>
</ul>
<p>のパターンがある。「（信号）」は、信号名もしくは数字列で16ビット整数を表す。</p>
<p>（例を鵜呑みにすると、<code>x AND y -&gt; d</code> のように論理ゲートの入力はワイヤ名だけに見えるが、
実際には数が書いてあることもある。
また逆に、<code>123 -&gt; x</code> のように数が信号に送り込まれる場合だけでなく、
<code>foo -&gt; bar</code> のように論理ゲートなしで直結される信号もある。）</p>
<p>手を抜きつつ全ての場合を表現するには、次のようなデータ構造を定義できる。</p>
<pre><code class="language-haskell">type Instr =
  ( String   -- 出力先の信号名
  , ( String   -- 論理ゲートの名前 "-"（直結）,AND,OR,LSHIFT,RSHIFT,NOT
    , [String] -- 入力元の信号名または数字列、0～2要素
    )
  )
</code></pre>
<p>もっと真面目に、次のような代数的データ型で表現することもできるが、もうこれでいいだろう。</p>
<pre><code class="language-haskell">type Instr = (String, LHS) -- 出力先の信号名、左辺の式

data SIGNAL = LIT Word16 | WIRE String

data LHS
  = ID SIGNAL
  | AND SIGNAL SIGNAL
  | OR  SIGNAL SIGNAL
  | LSHIFT SIGNAL SIGNAL
  | RSHIFT SIGNAL SIGNAL
  | NOT SIGNAL
</code></pre>
<p>行を読み込む。</p>
<pre><code class="language-haskell">runner i f = readFile i &gt;&gt;= print . f . map parse . lines

parse :: String -&gt; Instr
parse l = (last ws, lhs)
  where
    ws = words l
    ws0:ws1:ws2:_ = ws
    lhs = case length ws of
      3 -&gt; ("-", [ws0])       -- 123 -&gt; x, hoge -&gt; a
      4 -&gt; (ws0, [ws1])       -- NOT x -&gt; h
      5 -&gt; (ws1, [ws0, ws2])  -- x AND y -&gt; d, x OR y -&gt; e, x LSHIFT 2 -&gt; f, y RSHIFT 2 -&gt; g
</code></pre>
<h1 id="パート1-6"><a class="header" href="#パート1-6">パート1</a></h1>
<p>信号名に対して、その値を左辺に基づいて計算する。
そのとき、左辺に現れる信号の値が必要になる。
これを再帰関数で素朴に実装すると止まらない。配線がどこかでループしているようだ。</p>
<p>答えが求まるということは、ループがあるにもかかわらず、信号の値は発振するようなことはなく安定するのだろう。
一度計算した信号の値を再計算しないように、メモ化再帰と同等の、<code>Map</code>を用いた計算を行う。</p>
<pre><code class="language-haskell">import qualified Data.Map as M

buildMap :: [Instr] -&gt; M.Map String Word16
buildMap is = m
  where
    m = M.fromList [(sig, eval lhs) | (sig, lhs) &lt;- is]
    eval (op, args) = op2f (head op) $ map readSig args
    op2f '-' [x]    = x
    op2f 'A' [x, y] = x .&amp;. y
    op2f 'O' [x, y] = x .|. y
    op2f 'L' [x, y] = shiftL x (fromIntegral y) -- シフト量引数は Int
    op2f 'R' [x, y] = shiftR x (fromIntegral y)
    op2f 'N' [x]    = complement x
    readSig arg
      | all isDigit arg = read arg
      | otherwise       = m M.! arg
</code></pre>
<p>サンプルデータには <code>a</code> という信号がないので、構築したマップそのものを表示して動作を確認する。</p>
<pre><code>ghci&gt; runner "test.txt" buildMap
fromList [("d",72),("e",507),("f",492),("g",114),("h",65412),("i",65079),("x",123),("y",456)]
</code></pre>
<p>本番データは巨大なので、<code>a</code> の値だけ求めよう。</p>
<pre><code class="language-haskell">part1 is = buildMap is M.! "a"

main1 = runner "input.txt" part1
</code></pre>
<h1 id="パート2-76"><a class="header" href="#パート2-76">パート2</a></h1>
<p><code>buildMap</code> の <code>readSig</code> に細工をするのが早いのだが、それもダサいので、
真面目に <code>[Instr]</code> を差し替える形でする。</p>
<pre><code class="language-haskell">part2 is = buildMap m1 M.! "a"
  where
    m1 = [if sig == "b" then (sig, lit3176) else i | i@(sig, lhs) &lt;- is]
    lit3176 = ("-",["3176"])

main2 = runner "input.txt" part2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="パート1-7"><a class="header" href="#パート1-7">パート1</a></h1>
<ul>
<li>行ごとに、先頭と末尾のダブルクオートの2文字ぶん、コード表現は文字数が多い。</li>
<li>エスケープシーケンスが現れるごとに、
<ul>
<li><code>\\</code> は1文字余計に必要</li>
<li><code>\"</code> も1文字余計に必要</li>
<li><code>\x00</code> は3文字余計に必要（2文字が16進数字でない、などという場合がないことを祈る）</li>
</ul>
</li>
</ul>
<p>を数えて総計を求める。</p>
<pre><code class="language-haskell">part1 :: [String] -&gt; Int
part1 = sum . map f
  where
    f ('\\':'x':_:_:xs) = 3 + f xs
    f ('\\':'\\':xs) = succ $ f xs
    f ('\\':'\"':xs) = succ $ f xs
    f (_:xs) = f xs
    f "" = 2
</code></pre>
<h1 id="パート2-77"><a class="header" href="#パート2-77">パート2</a></h1>
<p>むしろこっちの方がやることは少ない。</p>
<ul>
<li>行ごとに、全体を囲うダブルクオート2文字が余計に必要</li>
<li><code>"</code> はエスケープ1文字余計に必要</li>
<li><code>\</code> もエスケープ1文字余計に必要</li>
</ul>
<p>を足し合わせるだけ。</p>
<pre><code class="language-haskell">part2 :: [String] -&gt; Int
part2 = sum . map f
  where
    f l = 2 + length (filter (flip elem "\"\\") l)

test2 = runner "test.txt" part2
main2 = runner "input.txt" part2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-4"><a class="header" href="#入力-4">入力</a></h1>
<p>行を、二つの都市名と距離のタプルにする。</p>
<pre><code class="language-haskell">runner i f = readFile i &gt;&gt;= print . f . map parse . lines

parse :: String -&gt; (String,String,Int)
parse xs = (ws !! 0, ws !! 2, read $ ws !! 4)
  where
    ws = words xs
</code></pre>
<h1 id="パート1-8"><a class="header" href="#パート1-8">パート1</a></h1>
<p>都市間を飛び回る距離なので、どちら向きにも移動できる無向グラフと解釈する。
内容は巡回セールスマン問題に他ならないが、都市の数が大したことないので、
都市のリストの順列を生成し、その距離を求める。</p>
<p>行 <code>(c1,c2,dist)</code> に対して、<code>Map</code> に二つのキー <code>(c1,c2)</code>, <code>(c2, c1)</code> いずれも値は <code>dist</code> を入れる。</p>
<pre><code class="language-haskell">import qualified Data.Map as M

part1 ccds = ...
  where
    distMap :: M.Map (String,String) Int
    distMap = M.fromList $ concat [[((c1, c2), d), ((c2, c1), d)] | (c1,c2,d) &lt;- ccds]
</code></pre>
<p>この表があれば、都市名のリストを順路と見なして、その総距離を求められる。</p>
<pre><code class="language-haskell">    fullDist :: [String] -&gt; Int
    fullDist cs = sum $ map (distMap M.!) $ zip cs (tail cs)
</code></pre>
<p>都市名の一覧を作る。</p>
<pre><code class="language-haskell">import Data.List

    cities = nub $ concat [[c1, c2] | (c1,c2,_) &lt;- ccds]
</code></pre>
<p>これの全ての順列に対する距離の最小値が答え。</p>
<pre><code class="language-haskell">part1 ccds = minimum $ map fullDist $ permutations cities
  where
    ...
</code></pre>
<h1 id="パート2-78"><a class="header" href="#パート2-78">パート2</a></h1>
<p>最大値と最小値は同時に求めると効率がよい。</p>
<pre><code class="language-haskell">part12 ccds = minmaximum $ map fullDist $ permutations cities
  where
    ...

minmaximum :: Ord a =&gt; [a] -&gt; (a,a)
minmaximum (x:xs) = foldl' step (x,x) xs
  where
    step lbub@(lb,ub) x
      | x &lt; lb = (x, ub)
      | ub &lt; x = (lb, x)
      | otherwise = lbub
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-5"><a class="header" href="#入力-5">入力</a></h1>
<p>ファイルに入れる代わりに文字列としてプログラムに埋め込んでしまう。</p>
<pre><code class="language-haskell">import Data.Char

input = map digitToInt "(パズル入力の数字列)"
</code></pre>
<h1 id="パート1-9"><a class="header" href="#パート1-9">パート1</a></h1>
<p><code>Data.List.group</code> で等しいものの並びに分割し、その個数とその数の並びにする。
個数は10以上になりうるので、その場合にはまた10進数の桁ごとに分解し直す必要があることに注意。</p>
<pre><code class="language-haskell">step :: [Int] -&gt; [Int]
step ds = concatMap f $ group ds
  where
    f ds1@(d:_)
      | l &lt; 10    = [l, d]
      | otherwise = map digitToInt (show l) ++ [d]
      where
        l = length ds1
</code></pre>
<p>40回繰り返した結果の長さを求める。</p>
<pre><code class="language-haskell">part1 = length ds40
  where
    ds40 = iterate step input !! 40
</code></pre>
<h1 id="パート2-79"><a class="header" href="#パート2-79">パート2</a></h1>
<p>Wikipediaの解説を見ると、
「1, 2, 3以外の数字は、シード番号にそのような数字または
同じ数字の3つを超えるランが含まれていない限り、シーケンスに現れない。」
とある。そんなことがあるのか。
それはともかく、特に計算量を節約する何かがあるわけでもなさそうなので、
ただ計算機をブン回す。</p>
<pre><code class="language-haskell">part2 cs = length ds50
  where
    ds50 = iterate step input !! 50
</code></pre>
<h1 id="ふりかえり"><a class="header" href="#ふりかえり">ふりかえり</a></h1>
<p>長さが10を越えた場合が発生するのか、<code>Debug.Trace</code> を仕込んで確認したところ起きなかった。
1,2,3以外の数字が現れないとはそういうことなのか。</p>
<p>力まかせで解いてしまって、本当によかったのだろうか。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="パート1-10"><a class="header" href="#パート1-10">パート1</a></h1>
<p>繰り上がりありで列をインクリメントするには、逆順になっているとHaskell的には都合がよい。</p>
<pre><code class="language-haskell">incr ('z':cs) = 'a' : incr cs  -- 繰り上がり
incr ('h':cs) = 'k' : cs       -- 禁止文字iは飛ばす
incr ('n':cs) = 'p' : cs       -- 禁止文字oは飛ばす
incr ('k':cs) = 'm' : cs       -- 禁止文字lは飛ばす
incr ( c :cs) = succ c : cs
incr "" = ""
</code></pre>
<p>要件1を判定する。
インクリメント列は、後ろからはデクリメント列に見える。</p>
<pre><code class="language-haskell">cond1 cs@(c1:c2:c3:_) = (succ c3 == c2 &amp;&amp; succ c2 == c1) || cond1 (tail cs)
cond1 _ = False
</code></pre>
<p>要件2は、上の <code>incr</code> の結果では生成はしないが、上位桁に最初からあるものを除去できない。
しかし、パズル入力にそれがなければ、これ以上気にする必要はない。</p>
<p>要件3は、連続する2文字が等しいかどうかの列を考え、
一つ<code>True</code>を見つけたとき、その直後は <code>aaa</code> のような並びなので捨てて、
それより後ろにもう一つ<code>True</code>があればよい。</p>
<pre><code class="language-haskell">cond3 cs =
  case dropWhile not $ zipWith (==) cs $ tail cs of
    True:bs -&gt; or $ drop 1 bs
    _       -&gt; False
</code></pre>
<p>全体をまとめる。</p>
<pre><code class="language-haskell">next :: String -&gt; String
next = reverse . until cond13 incr . incr . reverse

cond13 xs = cond1 xs &amp;&amp; cond3 xs

part1 = next "(パズル入力)"
</code></pre>
<h1 id="パート2-80"><a class="header" href="#パート2-80">パート2</a></h1>
<p>パート1の結果をもう一度処理するだけ。</p>
<pre><code class="language-haskell">part2 = next part1
</code></pre>
<p>こちらは先ほどより時間がかかる。
が、待つほかない。</p>
<h1 id="おや"><a class="header" href="#おや">おや？</a></h1>
<p>ここまで書いて、要件2の解釈がおかしいかもしれないことに気がついた。
文字 <code>i</code>,<code>o</code>,<code>l</code> を含めることができない、という制約の下で、
<code>ah...</code> をインクリメントして、くり上がりにより <code>h</code> を <code>i</code> にしようとして、
禁止文字なので飛ばして <code>j</code> にすると、下の桁 <code>...</code> はゼロリセットされる必要があるのでは？</p>
<p>といって、くり上がりにより<code>h</code>がインクリメントの対象になったのだから、
下の桁 <code>...</code> は実際には既に <code>aaa</code> とゼロリセットされているので問題なかった。
どっとはらい。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-6"><a class="header" href="#入力-6">入力</a></h1>
<p>JSONライブラリを使ってもいいが、この程度の構文は自分で読み込んでしまおう。
まず、JSONデータとは、数字列、ダブルクオートで囲まれた文字列、角括弧とコンマによる配列、
波括弧と文字列とコロンとコンマによるオブジェクトである。</p>
<pre><code class="language-haskell">import Text.Parsec

data JSON = JSONNum Int | JSONStr String | JSONList [JSON] | JSONObj [(String, JSON)]

numP :: Parsec String u JSON
numP = do
  s &lt;- option id (negate &lt;$ char '-')
  JSONNum . s . read &lt;$&gt; many1 digit

strP :: Parsec String u JSON
strP = JSONStr &lt;$&gt; between (char '"') (char '"') (many1 letter)

lstP :: Parsec String u JSON
lstP = JSONList &lt;$&gt; between (char '[') (char ']') (sepBy jsonP (char ','))

objP :: Parsec String u JSON
objP = JSONObj &lt;$&gt; between (char '{') (char '}') (sepBy colonedP (char ','))
  where
    colonedP = do
      k &lt;- between (char '"') (char '"') (many1 letter)
      char ':'
      v &lt;- jsonP
      return (k,v)

jsonP :: Parsec String u JSON
jsonP = choice [try numP, try strP, try lstP, objP]

allP :: Parsec String u JSON
allP = do
  j &lt;- jsonP
  eof
  return j
</code></pre>
<pre><code class="language-haskell">runner f = do
  co &lt;- readFile "input.txt"
  let Right j = runParser allP () "" co
  print $ f $ j
</code></pre>
<h1 id="パート1-11"><a class="header" href="#パート1-11">パート1</a></h1>
<p><code>JSON</code>型の値が読み込めたら、走査して数値を全て足し合わせる。</p>
<pre><code class="language-haskell">part1 = runner traverse
  where
    traverse :: JSON -&gt; Int
    traverse (JSONNum n)   = n
    traverse (JSONStr _)   = 0
    traverse (JSONList js) = sum $ map traverse js
    traverse (JSONObj kvs) = sum $ map (traverse . snd) kvs
</code></pre>
<h1 id="パート2-81"><a class="header" href="#パート2-81">パート2</a></h1>
<p>走査の際に、オブジェクトに遭遇した場合、値に <code>"red"</code> があれば引き返す。</p>
<pre><code class="language-haskell">part2 = runner traverse
  where
    traverse :: JSON -&gt; Int
    traverse (JSONNum n)   = n
    traverse (JSONStr _)   = 0
    traverse (JSONList js) = sum $ map traverse js
    traverse (JSONObj kvs)
      | any isRed vs = 0
      | otherwise    = sum $ map traverse vs
      where
        vs= map snd kvs
    isRed :: JSON -&gt; Bool
    isRed (JSONStr "red") = True
    isRed _ = False
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-7"><a class="header" href="#入力-7">入力</a></h1>
<p>フォーマット冗長さがすごい。
行を <code>words</code> した結果のうち、必要な情報を含む要素の位置を調べる。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">位置</th><th>内容</th></tr></thead><tbody>
<tr><td style="text-align: right">0</td><td>主語</td></tr>
<tr><td style="text-align: right">2</td><td>gain/lose</td></tr>
<tr><td style="text-align: right">3</td><td>幸せ度</td></tr>
<tr><td style="text-align: right">10</td><td>隣人</td></tr>
</tbody></table>
</div>
<p>この結果を保存するデータ構造を選ぶのに、本体でどう使うかを考える。
人の名前の順列を作り、隣同士のペアで幸せ度を集計する。
つまり、人の名前の（主語, 隣人）という対をキーとすればよいだろう。</p>
<pre><code class="language-haskell">parse :: String -&gt; ((String,String), Int)
parse l = (pq, x)
  where
    ws = words l
    pq = (ws !! 0, init ws !! 10)
    x = (if ws !! 2 == "gain" then id else negate) (read $ ws !! 3)

runner i f = readFile i &gt;&gt;= print . f . map parse . lines
</code></pre>
<h1 id="パート1-12"><a class="header" href="#パート1-12">パート1</a></h1>
<p>最後は出発点に戻ってくるという条件の追加された巡回セールスマン問題に他ならない。
要素数も9日目と同じ8。</p>
<p>幸福度は、主語の側と隣人の側があるので足し合わせておく。</p>
<p>ペアの左を集めて <code>nub</code> することで参加者一覧を得て、順列を作り、幸福度の合計を求める。
先頭の一人は固定して構わない。</p>
<pre><code class="language-haskell">import Data.List
import qualified Data.Map as M

part1 pqxs = maximum $ map score $ permutations ps
  where
    (p1:ps) = nub $ map (fst . fst) pqxs
    pqxm = M.fromListWith (+) $ concat [[pqx, ((q,p),x)] | pqx@((p,q),x) &lt;- pqxs]
    score ps = sum [pqxm M.! (p,q) | (p,q) &lt;- zip (p1 : ps) (ps ++ [p1])]

test1 = runner "test.txt" part1
main1 = runner "input.txt" part1
</code></pre>
<h1 id="パート2-82"><a class="header" href="#パート2-82">パート2</a></h1>
<p>書いてあるとおりに、自分を表に幸福度0で追加し、今度は自分を先頭にして計算してもよいが、
自分に関する幸福度は0なので、足しても足さなくても同じ。
つまり、長いテーブルに横並びに座った順列の幸福度を考えればよい。</p>
<pre><code class="language-haskell">part2 pqxs = maximum $ map score $ permutations ps
  where
    ps = nub $ map (fst . fst) pqxs
    pqxm = M.fromListWith (+) $ concat [[pqx, ((q,p),x)] | pqx@((p,q),x) &lt;- pqxs]
    score (p1:ps) = sum [pqxm M.! (p,q) | (p,q) &lt;- zip (p1:ps) ps]

main2 = runner "input.txt" part2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-8"><a class="header" href="#入力-8">入力</a></h1>
<p>また冗長な書式。トナカイの名前は関係ないので、パラメータだけ抜き出す。</p>
<pre><code class="language-haskell">parse :: String -&gt; [Int]
parse xs = map (read . (ws !!)) [3, 6, 13]
  where
    ws = words xs

runner i f = readFile i &gt;&gt;= print . f . map parse . lines
</code></pre>
<h1 id="パート1-13"><a class="header" href="#パート1-13">パート1</a></h1>
<p><code>replicate</code> と <code>cycle</code> で毎秒ごとの飛行距離を作って足し合わせるだけでも答えは出せる。</p>
<pre><code class="language-haskell">part1 time ls = maximum $ map dist ls
  where
    dist [s,t,u] = sum $ take time $ cycle (replicate t s ++ replicate u 0)

test1 = runner "test.txt"  (part1 1000)
main1 = runner "input.txt" (part1 2503)
</code></pre>
<p>もう少し気の利いた計算をするなら、
(速度 \(s\)、飛行時間 \(t\) 秒、休憩時間 \(u\)) 秒というトナカイが \(D\) 秒飛ぶとき、
1サイクルが \(t + u\) 秒かかるので、\(D \div (t + u) = q \dots r\) として、
サイクルを \(q\) 回行い、さらに最後のサイクルのうち \(r\) 秒だけを行う。</p>
<p>完全に行えたサイクルでは $t$ 秒間飛行し、最後の回は $\min(t, r)$ 秒だけ飛行しているので、
移動できた総距離は \s (q t + \min(t, r)\)となる。</p>
<pre><code class="language-haskell">    dist [s,t,u] = s * (q * t + min t r)
      where
        (q,r) = divMod time (t + u)
</code></pre>
<h1 id="パート2-83"><a class="header" href="#パート2-83">パート2</a></h1>
<p>こちらは、毎秒ごとの状況を分析する必要があるので、パート1の素朴な方法をベースに考える。</p>
<p>それぞれのトナカイについて、次の1秒で進む距離（または0）のリストを作り、
これを累積することで各時刻の位置を作り、一位を選んで点数を付与する、を繰り返す。</p>
<pre><code class="language-haskell">import Data.List

part2 time ls =
    maximum $             -- 最高得点
    map sum $ transpose $ -- トナカイごとに足し合わせ
    map point2top $       -- 首位にポイント付与
    take time $           -- レース時間で打ち切り
    transpose $           -- 毎秒ごとに、各トナカイの位置のリスト、のリスト
    map genDists ls       -- トナカイごとに、毎秒の位置のリスト、のリスト
  where
    genDists [s,t,u] = scanl1 (+) $ cycle (replicate t s ++ replicate u 0)
    point2top ds = [if d == m then 1 else 0 | d &lt;- ds]
      where
        m = maximum ds
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-9"><a class="header" href="#入力-9">入力</a></h1>
<p>マイナスと数字以外を無視して数値列だけ読み込む。</p>
<pre><code class="language-haskell">import Data.List.Split

parse :: String -&gt; [Int]
parse = map read . wordsBy (flip notElem ('-':['0'..'9']))

runner i f = readFile i &gt;&gt;= print . f . map parse . lines
</code></pre>
<h1 id="パート1-14"><a class="header" href="#パート1-14">パート1</a></h1>
<p>材料が N 種類あり、全部で小さじ W 杯を使うようなやり方で、
それぞれをどれだけ使うかのというレシピを配合のリストで表し、レシピのリストを作る。</p>
<pre><code class="language-haskell">recipe :: Int -- 残りの材料種類
       -&gt; Int -- 残りの配合量
       -&gt; [[Int]] -- レシピのリスト
-- 材料が最後なら残量全部それ
recipe 1 w = [[w]]
-- 配合がいっぱいなら、残りの材料は全部使わない
recipe k 0 = [replicate k 0]
-- 先頭の材料をx = 0～w使い、残りの材料の使い方は再帰的に求めて組み合わせる
recipe k w = [x:ys | x &lt;- [0..w], ys &lt;- recipe (pred k) (w - x)]
</code></pre>
<p>重複した呼び出しが多いので、配列DPで計算量を節約する。</p>
<pre><code class="language-haskell">import Data.Array

mkRecipe k w = recipeA ! (k, w)
  where
    bnds = ((1,0), (k,w))
    recipeA = listArray bnds $ map recipeF $ range bnds
    recipeF (1, w) = [[w]]
    recipeF (k, 0) = [replicate k 0]
    recipeF (k, w) = [x : ys | x &lt;- [0..w], ys &lt;- recipeA ! (pred k, w - x)]
</code></pre>
<p>レシピの全てのやり方について、材料ごとの特性値を掛けて足し合わせ、
（カロリーを除いて）0で足切りした総積を求め、その最大値を見つける。</p>
<pre><code class="language-haskell">import Data.List

part1 list = maximum
    [ product $ init vals
    | ws &lt;- mkRecipe (length list) 100
    , let vals = values ws ]
  where
    tlist = transpose list
    values ws = map (max 0 . sum . zipWith (*) ws) tlist

test1 = runner "test.txt" part1
main1 = runner "input.txt" part1
</code></pre>
<h1 id="パート2-84"><a class="header" href="#パート2-84">パート2</a></h1>
<p>カロリーが500のものだけ残し、その中でスコアの最高点を求める。</p>
<pre><code class="language-haskell">part2 list = maximum
    [ product $ init vals
    | ws &lt;- mkRecipe (length list) 100
    , let vals = values ws
    , last vals == 500 ]        -- ココ
  where
    tlist = transpose list
    values ws = map (max 0 . sum . zipWith (*) ws) tlist
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-10"><a class="header" href="#入力-10">入力</a></h1>
<p>物の名前と、整数が対になっている。
名前から値が取り出せるように、それぞれのおばさんを <code>Map String Int</code> で表現する。</p>
<pre><code class="language-haskell">import qualified Data.Map as M
import Data.List.Split

parse :: String -&gt; M.Map String Int
parse l =
    M.fromList $ map l2p $ chunksOf 2 $ drop 2 $ words l
  where
    l2p [a,b] = (init a, read $ if last b == ',' then init b else b) -- コロンとコンマを消して

runner f = readFile "input.txt" &gt;&gt;= print . f . map parse . lines
</code></pre>
<h1 id="パート1-15"><a class="header" href="#パート1-15">パート1</a></h1>
<p>思い出したメモの内容で、MFCSAMの情報と矛盾がないものを選択する。
フィールドが存在する場合は値が一致する必要があり、存在しない場合は不問とする。</p>
<pre><code class="language-haskell">mfcsam =
  [("children",3),("cats",7),("samoyeds",2),("pomeranians",3),("akitas",0)
  ,("vizslas",0),("goldfish",5),("trees",3),("cars",2),("perfumes",1)]

part1 aunts = [id | (id, aunt) &lt;- zip [1..] aunts, all (check aunt) mfcsam]

check aunt (k,v) = v == M.findWithDefault v k aunt

main1 = runner part1
</code></pre>
<h1 id="パート2-85"><a class="header" href="#パート2-85">パート2</a></h1>
<p>比較関数を妥当なものに交換しつつ検査する形に変更する。</p>
<pre><code class="language-haskell">part2 =
  [ id
  | (id, aunt) &lt;- zip [1..] aunts
  , all (check   aunt) mfcsamEQ
  , all (checkLT aunt) mfcsamLT
  , all (checkGT aunt) mfcsamGT]

checkLT aunt (k,v) = v &gt; M.findWithDefault minBound k aunt
checkGT aunt (k,v) = v &lt; M.findWithDefault maxBound k aunt

mfcsamEQ = [("children",3),("samoyeds",2),("akitas",0)
           ,("vizslas",0),("cars",2),("perfumes",1)]
mfcsamLT = [("pomeranians",3),("goldfish",5)]
mfcsamGT = [("cats",7),("trees",3)]

main2 = runner part2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-11"><a class="header" href="#入力-11">入力</a></h1>
<p>行ごとの数値を読み込むだけ。</p>
<pre><code class="language-haskell">runner i f = readFile i &gt;&gt;= print . f . map read . lines
</code></pre>
<h1 id="パート1-16"><a class="header" href="#パート1-16">パート1</a></h1>
<h2 id="ナップザック問題"><a class="header" href="#ナップザック問題">ナップザック問題</a></h2>
<p>これはナップザック問題の一種。</p>
<p>入力の容器の個数は20個あるので、その総当たりの組み合わせは \(2^20 = 1,048,576\) とやや多い。</p>
<p>力任せにするなら、</p>
<ul>
<li>以降のコップのリスト</li>
<li>これまでに選んだコップの容量合計</li>
<li>以降のコップの容量合計</li>
</ul>
<p>を引数にとり、</p>
<ul>
<li>選んだ合計容量が目標ぴったりなら、一つ発見したと返す</li>
<li>越えていたら、それ以上調べずに引き返す</li>
<li>まだ足りていないが、残りのコップを全て使っても目標に届かないなら、無理と引き返す</li>
<li>可能性が残っているなら、先頭のコップを使う場合と使わない場合の両方に再帰し、結果の合計を返す</li>
</ul>
<p>という形に、枝刈りを意識した構造にしたい。</p>
<pre><code class="language-haskell">part1a goal cups = iter rest cups (sum cups)
  where
    iter 0 _ _ = 1
    iter rest _ _ | rest &lt; 0 = 0
    iter rest _ remain | rest &gt; remain = 0
    iter _ [] _ = 0
    iter rest (x:xs) remain = iter rest xs remain1 + iter (rest - x) xs remain1
      where
        remain1 = remain - x

test1a = runner "test.txt" (part1a 25)
main1a = runner "input.txt" (part1a 150)
</code></pre>
<p>ほら、ただの全探索だと遅いでしょ、とやるつもりだったのだが、
2021年10月製造のcore i7ノートPCで、ノーストレスで答えが出てしまった。</p>
<p>枝刈りなしの版でもやってみる。</p>
<pre><code class="language-haskell">part1b goal cups = iter 0 cups
  where
    iter acc [] = if acc == goal then 1 else 0
    iter acc (x:xs) = iter acc xs + iter (acc + x) xs
</code></pre>
<p>遅くはなったが、5秒は掛からない。</p>
<h2 id="動的プログラミング"><a class="header" href="#動的プログラミング">動的プログラミング</a></h2>
<p>「これまでに調べたコップの組み合わせで、合計xリットルを作る方法の個数」を配列に持つ。
最初は「0リットルを作る方法は1通り」から、aリットルのコップを1つ追加するたびに、
xリットルを作る方法の個数をx+aリットルを作る方法に足し込む、を繰り返す。</p>
<pre><code class="language-haskell">import Data.Array
import Data.List

part1c goal cups = arrN ! goal
  where
    arr0 = listArray (0, goal) $ 1 : repeat 0
    arrN = foldl' step arr0 cups
    step arr a = accum (+) arr $ zip [a .. goal] $ elems arr
</code></pre>
<p>最速で答えが出る。</p>
<h1 id="パート2-86"><a class="header" href="#パート2-86">パート2</a></h1>
<p>答えとして集める情報を、場合の数1、だけではなくて、
使う容器の個数ごとに分けて集計することになる。</p>
<p>集計は後回しにして、その容量を達成するひとつの組み合わせが使う容器の個数、のリストだけ集めて、
最後に、容器の使用数最小のものの個数を数えるやり方でしてみよう。</p>
<p>枝刈りなし全探索版、ただし結果を集める方法は <code>(++)</code> を回避するテクニックを使っている：</p>
<pre><code class="language-haskell">part2a goal cups = (head ks, length ks) -- 使う容器の個数とその場合の数
  where
    iter acc cnt [] ans = if acc == goal then cnt : ans else ans
    iter acc cnt (x:xs) ans = iter acc cnt xs $ iter (acc + x) (succ cnt) xs ans
    ks = head $ group $ sort $ iter 0 0 cups []
</code></pre>
<p>上でも答えに易々と到達するので逆にがっくりするが、気をとりなおしてDP版：</p>
<pre><code class="language-haskell">part2b goal cups = head $ filter ((0 &lt;) . snd) $ assocs cnts
  where
    arr0 = listArray (0, goal) $ [0] : repeat []
    arrN = foldl' step arr0 cups
    step arr a = accum (++) arr $ zip [a .. goal] $ map (map succ) $ elems arr
    cnts = accumArray (+) 0 (0, length cups)
           [(k,1) | k &lt;- arrN ! goal]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>ライフゲームは有名だし難しくもないので、好きにプログラムすればできるでしょう。</p>
<p>ここではせっかくなので、電飾の様子を見えるようにしてみた。</p>
<div>
<canvas id="canvas" width="100" height="100" style="width:400px; height:400px; image-rendering: pixelated">
</canvas>
</div>
<div id="counter">
0
</div>
<button onclick="run(false)">Run1</button> 1061 <br/>
<button onclick="run(true)">Run2</button> 1006
<script>
let lights;
let isPart2 = false;
let count;
let canvas, ctx, imageData;
let tickhandler;
class Cell {
    x; y; pos;
    z = 0;
    z1 = 0;
    constructor(x, y) { this.x = x; this.y = y; this.pos = y*400+x*4-404; }
    pull() {
        const x = this.x, y = this.y;
        if (isPart2 && (x == 1 || x == 100) && (y == 1 || y == 100)) {
            this.z1 = 1;
            return;
        }
        var v = lights[y-1][x-1].z + lights[y][x-1].z + lights[y+1][x-1].z +
                lights[y-1][x  ].z                    + lights[y+1][x  ].z +
                lights[y-1][x+1].z + lights[y][x+1].z + lights[y+1][x+1].z;
        if (this.z) {
            this.z1 = (v == 2 || v == 3) ? 1 : 0;
        } else {
            this.z1 = (v == 3) ? 1 : 0;
        }
    }
    push(imageData) {
        this.z = this.z1;
        const c = this.z ? 0 : 255;
        imageData.data[this.pos] = c;
        imageData.data[this.pos+1] = c;
        imageData.data[this.pos+2] = c;
    }
}
function initialize() {
    let y = -1, x;
    lights = new Array(102).fill(0).map(() => {
        y++; x=0;
        return new Array(102).fill(0).map(() => new Cell(x++,y));
    });
    var src = document.getElementById("input.txt").innerText.split("\n");
    for (y=1; y<=100; y++) {
        for (x=1; x<=100; x++) {
            lights[y][x].z = (src[y].charAt(x-1) == "#") ? 1 : 0;
        }
    }
    if (isPart2) {
        lights[1][1].z = lights[1][100].z = lights[100][1].z = lights[100][100].z = 1;
    }
    count = 0;
    canvas = document.getElementById("canvas");
    ctx = canvas.getContext('2d');
    imageData = ctx.createImageData(100, 100);
    imageData.data.fill(255);
}
function step() {
    for (var y=1; y<=100; y++) {
        for (var x=1; x<=100; x++) {
            lights[y][x].pull();
        }
    }
    for (var y=1; y<=100; y++) {
        for (var x=1; x<=100; x++) {
            lights[y][x].push(imageData);
        }
    }
    ctx.putImageData(imageData, 0, 0);
    count++;
    var n = countLights();
    document.getElementById("counter").innerText = "" + count + " " + n;
}
function countLights() {
    var s = 0;
    for (var y=1; y<=100; y++) {
        for (var x=1; x<=100; x++) {
            s += lights[y][x].z;
        }
    }
    return s;
}
function run(mode) {
    isPart2 = mode;
    initialize();
    tickhandler = window.setInterval(tickstep, 200);
}
function tickstep() {
    step();
    if (count == 100) { window.clearInterval(tickhandler)};
}
</script>
<div id="input.txt" style="display: none">
#..####.##..#...#..#...#...###.#.#.#..#....#.##..#...##...#..#.....##..#####....#.##..##....##.#....
.#..#..#..#.###...##..#.##.....#...#..##....#####.##............####.#..######..#.#.##.#...#..#...##
#.....##.##.##.#..##.#..###...#.#.#..##..###.####.####.#.####.#...##.#..###.........#.###...#....###
#.###..#######..##..#.....##.#.#.###.#.##..#.##..##.##.#.##...###.#...#.#####.#.##..#.#####..#.#####
#.##.##.###.##..###.#.##.##...##.#.#..##..###.########.#.####..####...#####...#..#...##....##.##.##.
..#.#.#.#..#.#.###....###...#...#.##..####.###.....#.####.###.###.#......#.#.###..#..#.#....#.#####.
...#.###.#....#.###...#.#.#...#...#.#####....#....#...#####..#..#.#..######..#.##.#.##.#..###.#...##
.###...#...#.#..#.#.####.#...#.....##...###.#....#..##.###....#.##....###..#.#####...###.#.##.####..
#.#....##.#.....#####.#.##..#######.#.####..###.##.#####.##.#...###...#.#...###..#...#.#.###.###.###
...##.##.....##..#.##...#.#...#...#.#####.#...#.#.#.#####.##.#...#.#..##.##..#...#....####..###.###.
#..#....######...#...###.#....#####....#.#.#....#....#.#######.#####..#....#....#.##..#.##.###..#...
#####.#.######.#.#####.#..##..##..####..#....#...#######....##..##.#..###..###.###..###...#...######
#...##..##...###....##..##.##..#.#.#.#....##.#.......###..###..###...###..##.##.##.#.#.#..#.#..#..#.
..###....##.###..#.#..########...###...##..#######....##..###..#####.##.#....###..##.##.##.#...##.#.
###..#.#..#.#.##.##...##.....#..###.#..##.##.#....##.#.######..##..#.#.##.###...#..####...#.#..#.###
.######....#..##..#.####.##..#.#..#.#..#....#..##.#..#.#...####..#....#.####.#.###.#...####.#...#.#.
#.######.##..###.###..#..###.#...#..#...#...###.##....#.#......#...#.##.#.###..#.#####.#.#..###..#.#
...#..#...####..###.########.....###.###.#..##.##....######..#..#.....#.##.##.#..##..#..##...#..#..#
#..#..##..#.#.########.##.#.####..#.#####.#.###.##....###..##..#.#.###..#.##..##.##.####...######.##
.######.###....#...##...#..#....##..#.#...###.######.##...#....##.##.#.#.##..#...###.###.#....#..##.
####.#.##..##.##.###...#.###.##..##....###..####.##..#.#.##..###.#..##...####...#..####.#.#..##...#.
.#.#..#.....##...#..#...#.#...#.#.##..#....#..#......#####.#######....#.#..#..###..##.#.########..##
.##.#..#..##..#..####.#...####...#...#..##.#..###.#..######..#.#...###.##...#..#####..##.#..##.#.##.
.###..##.##.##....###.###..#.#...##.#.#...#.#######.####..#..###.#######.#...#.#...#.##...#..####..#
##.########..#..#....#.###..##.##.#.##.#..#......####..##.##.#..####..#####..#.....#####.###..#.#.#.
.#..####..##.#.#..#####.##..#..#.#....#.#####.#####...######........##.##..##.#.#.###..#.#.#.#..##.#
.##..##..#.######..###....#.#.###.#........#..###..#.########.....#.##...#.....#..#...##...#..#.###.
##.##.#..####....####.#######.....#.#.#...#.######.#.....####.####...###..####.##.##....###..#..#...
#.#..####...#......#...###...##....##.#######..#.###.#...###.##.##...####..#.####..#......##..#####.
.#.#...##...#....#.####.##.....#....#.#.#######..###.#.....#.....####...##...#.#.##.####..##.###.#.#
####.#.#.####...#...####.#.....#.#######.#.......####......###..###.#...######..#.##.#.##..#..##..##
..##.###..#..####..####.......######.##..#.....##.##...##.##......#.###..###...#.##.#####.#.######.#
.###..####.###..#..#.......#.##...##...##.######.....#..####.#......#.#...#...#...###...#.#.##..####
.####....##.##.#.....##.###.####.#.......#.......#.#..#.#.#.....###.#.#####.#..#.#.#####.#####.###.#
.##.#.###.#####..#..#....###.#.#.#..#..###..##..####..##.###....#..####.####.#..###.#..######.######
####.#.....##..###....#.....#.##.#.##..##..########.#####..###.####....##.....######.#.#.##.......#.
#.#.##.....#.....##.###.#..#.##.##....#..##....##.#.###.##.#..#..##.##.###.#..##.###...##..###.#####
#.###.#.#.#.#.#.#.#...#..#.###..####.##...#..####.###....#..#..##.#....####..##.##....#.#.##.##....#
...######....#..####...#.#..#.#.#..#.##.#.#.......#..#......##..#...#..#..##...##.#...#.#.#...##.##.
.#####..#...####....#..###..##....#####..###.#.#...###..###.###..##...#......#...#...#.#.#...#.##..#
......#####.#...#.#.#.##..#.###..##..#.#...###..###....##..#####..#######.#..#.###....###...##.#..#.
..##.########.##..#....##.#...##.##.#.#..#.##..#.#.#.##....#.#.#.#.##....##....#....#####.##..#.##.#
####...#....##.#.###......##.##.#..##...#..#####..#.#....##..#####...#.#.##...#.####.####..##.######
.##.###.##.#...#.#....###.#######...##...##..#..##.###.#.####..#..###......#.#.##.#.#....#..##...#..
.#.###.#.###.###.#.##.#..#......####.##...#..##.#..####.....#...#.###.##.##.#..#.##..#.###......#..#
...##.####......#.#.#..###..#....###....#.##.#####..#..#..#...#.#.###...#.#.#.##....###.####..###.#.
##..#.#.#.#....####...#.##.###..####....#..#####.######..#.##.##..#####.#.....#.#...##.#.##.##.#.#..
#..##.#.#.#.###.#.#.###...#.#...##..#..#.#.#.##..###...#..##.#..#.#.#..#.....#.######.#.###..###.#..
....#.#.##.###.##...#.##.#....#..##.#..##...#...#.##.####...##..####.#.........#..##..#...#...##.#..
.##.......##...###.##.#.##.###.##.#..#..#..####...#...#....#####...###..##..#..#..##...#....#..#####
..####..#...#...#..###....##.#.#####..#..#.....#......#...#.......##....####...##....##.##.#.#####.#
##.#.#.#..##..##..#.####.##.##.###.#...###.#....#.....#.###...#######..###.####.###.####.##...##.#..
..#.#...##.#....#..#..##.####.....#.#.#...#..#..###.#..###.#####.#.#####.#.#.#.#.###.##.###..#....##
.###.#...#....###..#...####....####..#.##..#..##.###..#.#.#.#..#...###.#.#...#......#...#.##.##.#...
..####.####.##.#.##....#...##....#..#....#..###..#...#..###.#####.....#####..##.#.#.#.#.#.##.####...
...##.#.##.####..##.###..#.#.#.#.#.#.#..###...#.##..#.####.##...#.#.##......###..#...###....#.#.###.
##...##..#.#.##..#.#.#....#.####.......#.#.#######.#..#....#.###.#...###.##....###.#.#..#.#.##.####.
...##.......######.....##....#...#..#.##.###.#..#.##.###.#.###.#.#.#...#.#...##.##.##..#.##########.
###..#....#.#.....#....###.#...##.......##.#.#..#.#...########......###..##.#..#..####.##..####...#.
......##.###.#.###.....#..#...#.#......##....#....#........#..#...##.##.....#...##.##.........##....
.##.##.#.#...#....######..##....##..##.#.#.##.#.##..##...#..###......##......#.#....#.#.#.......###.
.......#.##..##.#...#.##..#..#####.#..#.######.........###.#####.####.#...##...........##...##..####
#......#.#..#...#...##..#.#.###.##.##.#.#..#.###.##.#..###..#.###..#...###.##..###..#...#..###...#..
####.##..#####..####.#...#..#..###..##.#.#...#...#...#.##.####.##.###....###...#.#.#..####.######.##
.....#..####...#.#.#.####..####..##.###......#.....########.#...#.#..#..#...#.###..##.#####..###.###
.#######.#.##..###.#...###.#####............##.###...#.##.#.##..##.#.#..#.######..######..#..#..####
...##..#.####...#..#.#.##.#....#.####..#..###.###..#.#...#....##.##.#......##..##..#.#.#.###..#..#..
........#...#.##.#.#..#....####....#.##...###..####...###.#.#..######..###..##.#####.###.###.#.#...#
##......##.#..###.####.##.#.###.#.......#.##..####..#.###.##..##..##...##...#.###...#.#..#..#.#####.
##..#.#.....##.####.#..##.#.##.#.#...#...#.#...####.#.#.##...##....##.###..###.####.#...#.###..#####
.#####.####.####.####.#.##.##......###....###.####...###...#...#..#.##.#.#####.###..##.#..###...##..
.#...#..##...##...#....#.#.#..##..#.##..#.###.#.###..###.#.#.###.#....#######.####.##..#..#...####..
..##.##..#.##..#.#.###..#.##.########...####.#.###.##..#..###.###...##..##.#..#.######.##.#....###.#
##.#####.###.##.#.##.##.##.###..##..##..#.#.#.#.####..#......#.#.#.#.#.#.##...#####.####...#.#...#.#
.#..###..##.#####.#.##.#..##...##..##...#####.#.####..#...##.....######.#.#...##.#..#######.###.###.
#.#..##.#.#####.#.#.....###.###.#..##.#####....#.###.##.##.#.#..##..#.#....#######.###.#.#.....#.###
....###...#.###.####....###.....##....#####.##.###.###.##.##.##.#..###..######...####.#.#..####..#..
###.....#..####..#.####..#..#...##.##..##.######.####.....#...##....#..#.##.#####..###.##.#.####...#
.##.##.#...#..####...##.##.###...#...#..#.#.#####.....####...#.#.#..#.####...####.#...###.#......###
###.##....#.#.#...#.###....####..##...##.##.##.#..#...####..#..#..##...#####.####.####...##.#..###.#
..####.....##..###.#.#.###.########..#...#.##..#.#.#.......#.##.#..#...####.##.#..#.######..#.#...#.
#.#.##.#.#.##.#....##......##......#######.#..#.##...##..#.#.###...#.#..#..###...#..###.....##.....#
..#.##.#.##.#.##..##.....#.#..#.#..#...##..#..#.#....###.#####....####.####..#####.##.###...#..###.#
#....#.###..#..########.###..#.#.#.##...##.#..##.###..#..#..#.#.##..###...###.#.##..#.##.#..#.#.####
#.......#######......#...#...##.##...###.#....##.#..#....####.#.##.###...#.#####...##.###........##.
.##.####.....###.##......####.###.########..#.####..#.##.#.####.....#...#.##....#######.##..#......#
#.#.##.##....##..##.#.###..#.##.#..#..#.#..##.....###..###.##.##.####.##.#.#.##...####..#.#..##.#.#.
...##.#.#.#...###.#.......#.#.....#.#...##....##.##.##.####...#.#..#..#..#.#.##.#..#.#.#....###..#.#
....#.#.###.#####.##..###..##..#...#.##.#......##.####.#..####.#.##..####.#.#...##..#####..##.#.#...
..###.#.##..#....#..#.#.....##.#####..##....#.#...#.##..##.#.#..#...##.##..##..##....#...#..#..#..##
##.#.##.#...#.###.##.##.##.##..##.##...#..##.#..#######.#..#...#.#.##..#....##.#..####.###........#.
.##.#..#.....#####..##.#.#.#.#..###.#######.###.###....##....#.#.#.###....###.#..#.#....#.#..###...#
...###.#.#.###..#...#..###.######..##.#.#..#...####.#####.##..#..###...#..#..#..###..##.#.#...#.###.
#......#.#..#..##.##.#.##.#.###.#.##.#.#..#....#.##..#..##..##.#.#.#....##.###.###.####.#.#####...##
...#.##..#.######.......#.#.###.....#####....##.#.#.###........#.#.###.#.#########.##.##.#..##..#...
##..###..###....####.##.##..##.###....####..##...####.####..####..###.####..##.#...###.#####.##.##.#
###...##.#.#.#####..#..#####...##.#...#.#.###.#..##..###.##.#.#.....####.##.#..##.###.#...##.##...##
...#.#.##.##..##....#..#.#####.##.###..#.#.#........####.###.##....##....####..#.#....#.#.#.###..#.#
..#.#.#.#.###...#....##..######.##....#.#.##..###..#.#.###..#.##..#.#.###......#..#..#.####..#...##.
.....####.#.....###.#.##.#..##.#..###.#####.#..##...###.#..###..#..##....###.#..##.#..#.##.#..#...##
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-12"><a class="header" href="#入力-12">入力</a></h1>
<p>原子記号は大文字1文字または大文字1文字+小文字1文字でひとつ。
原子記号一つをひとつの整数で扱うよう変換する。
16ビットもあれば表現できるので、<code>Word16</code> でも収まる。
（実際に現れている記号だけに背番号をつければ、<code>Word8</code>でも収まるだろうけど。）</p>
<pre><code class="language-haskell">import Data.Char

encode :: String -&gt; [Int]
encode (c1:c2:cs) | isLower c2 = ord c1 * 256 + ord c2 : encode cs
encode (c:cs) = ord c : encode cs
encode "" = []
</code></pre>
<p>最終行以外は置換を表す。
一つの置換は、原子 <code>Int</code> から原子の列 <code>[Int]</code> へ置換する。</p>
<p>最終行は原子の列 <code>[Int]</code> で表せる。</p>
<pre><code>parse :: String -&gt; (Int,[Int])
parse xs = (head $ encode w1, encode w3)
  where
    [w1,_,w3] = words xs

runner i f = do
  ls &lt;- lines &lt;$&gt; readFile i
  let n = length ls
      rules = map parse $ take (n - 2) ls
      mol = encode $ last ls
  print $ f rules mol
</code></pre>
<h1 id="パート1-17"><a class="header" href="#パート1-17">パート1</a></h1>
<p>置換の左辺は重複があるので、それら全ての可能性を試し、
初期列のいずれかの原子に対して可能な置き換えを一度行った全ての結果を作り、
重複を除いて種類を数える。</p>
<pre><code class="language-haskell">import qualified Data.IntMap as IM
import qualified Data.Set as S
import Data.List

part1 rules mol = S.size mols
  where
    rs = IM.fromListWith (++) [(l,[r]) | (l,r) &lt;- rules]
    mols = S.fromList [a ++ d ++ c | (a,b:c) &lt;- zip (inits mol) (tails mol), d &lt;- IM.findWithDefault [] b rs]

main1 = runner "input.txt" part1
</code></pre>
<h1 id="パート2-87"><a class="header" href="#パート2-87">パート2</a></h1>
<p>本当に原子から出発して、あらゆる置換を幅優先探索で試すのは発散する。
目標に到達するように置換の適用を制御する方法もよくわからない。</p>
<p>完成した瞬間から時計を戻して考えて、目標から逆変換して原子まで還元するステップを探す。</p>
<p>もし変換規則が優しく作られていて、端から貪欲に書き換えを行えばよいならば、話は楽。
さもなくば、可能な還元を実行して作られる分子の全てを幅優先で作っていく全探索が必要になる。</p>
<p>規則が膨大なら、右辺のTrieを構築するところだが、そこまでではないので、
右辺の先頭の原子をキーにして整理しておくにとどめる。</p>
<pre><code class="language-haskell">part2 rules mol0 = ...
  where
    revrules = IM.fromListWith (++) [(r1, [lr]) | lr@(l,r1:_) &lt;- rules]
</code></pre>
<p>これを使って、分子に可能な還元を行った全ての結果を作る計算が定義できる。</p>
<pre><code class="language-haskell">    revstep mol =
      [ a ++ l : drop (length r) c
      | (a,b:c) &lt;- zip (inits mol) (tails mol)
      , (l,_:r) &lt;- IM.findWithDefault [] b revrules
      , isPrefixOf r c]
</code></pre>
<p>可能な限り <code>revstep</code> を適用し、その先頭だけ残す、を繰り返し、毎回の分子長さ、繰り返しの回数、最終結果の分子、を見てみる。</p>
<pre><code class="language-haskell">import Debug.Trace

part2 rules mol0 = loop 0 mol0
  where
    loop cnt mol = traceShow (cnt, length mol) $
      case revstep mol of
        [] -&gt; (cnt, mol)
        (mol1:_) -&gt; loop (succ cnt) mol1
</code></pre>
<p>残念ながら201ステップで長さ15の分子で進まなくなってしまった。
丁寧に幅優先探索する必要があるようだ。</p>
<p>既出の分子は探索しないように記録しつつ、深さ優先探索で電子を目指す。</p>
<pre><code class="language-haskell">part2 rules mol0 = iter S.empty [(0, mol0)]
  where
    revrules = IM.fromListWith (++) [(r1, [lr]) | lr@(l,r1:_) &lt;- rules]
    revstep mol =
      [ a ++ l : drop (length r) c
      | (a,b:c) &lt;- zip (inits mol) (tails mol)
      , (l,_:r) &lt;- IM.findWithDefault [] b revrules
      , isPrefixOf r c]

    electron = encode "e"

    iter :: S.Set [Int] -&gt; [(Int,[Int])] -&gt; Int
    iter dones ((cnt,mol):cmols)
      | electron == mol    = cnt
      | S.member mol dones = iter dones cmols
      | otherwise          = iter dones1 cmols1
      where
        mol1s = revstep mol
        cnt1 = succ cnt
        dones1 = S.insert mol dones
        cmols1 = foldr step cmols mol1s
        step m r
          | S.member m dones1 = r
          | otherwise = (cnt1, m) : r
</code></pre>
<p>何とか答えに到達した。
実際、可能な還元リストの末尾を辿るようにすると一直線に到達するので、
相当いやらしい設計になっているようだ。すごい。</p>
<p>そして、これはDFSで一つの解を見つけただけなので、これが最短であるという保証はない。
証明するためには、全ての場合を続けて探索し尽くす必要があるが、これが終わらない。
なのでこのspoilerは不完全な内容。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="パート1-18"><a class="header" href="#パート1-18">パート1</a></h1>
<p>自分のパズル入力が 36,000,000 だったので、それを前提に話を進める。</p>
<p>家番号 \(N\) が \(a\) の倍数であるとき、プレゼントを \(10a\) 受け取る、
その総和が目標を超えるような最小の \(N\) を見つけたい。
家番号 \(N\) に、小人 \(N\) は必ず訪問するので、
家番号 3,600,000 は小人 3,600,000 から 36,000,000 を受け取る。
よって \(N \leq 3,600,000\) 以下を調べればよい。</p>
<pre><code class="language-haskell">import Data.Array.Unboxed

theInput :: Int
theInput = 36000000
theInput10 = div theInput 10

part1 = head $ filter ((theInput10 &lt;=) . snd) $ assocs arr
  where
    arr :: UArray Int Int
    arr = accumArray (+) 1 (1,theInput10)
          [(j, i) | i &lt;- [2 .. theInput10], j &lt;- [i, i+i .. theInput10]]
</code></pre>
<p>探索範囲を倍々に増やしながら答えを見つけるまで続けるようなコードにすることもできる。</p>
<pre><code class="language-haskell">part1a = loop 1 100
  where
    loop lb ub
      | null ans  = loop (succ ub) (min theInput10 (ub * 2))
      | otherwise = head ans
      where
        arr :: UArray Int Int
        arr = accumArray (+) 1 (lb,ub)
          [(j, i) | i &lt;- [2..ub], let j0 = i * divrup lb i, j &lt;- [j0, j0+i .. ub]]
        ans = filter ((theInput10 &lt;=) . snd) $ assocs arr

-- 切り上げ除算
divrup x y = negate $ div (negate x) y
</code></pre>
<p>こちらの方が少し速く完了する。</p>
<h1 id="パート2-88"><a class="header" href="#パート2-88">パート2</a></h1>
<p>家番号 \(K\) に訪れる小人の番号は \(K\) 以下である。
\(K=1\) から順に、小人 \(K\) の配達まで済ませた状況を作り、家 \(K\) の個数を確認する。
目標に達していなければさらに次に進む。このとき、\(K\) 以下の家の状況は今後更新されないので捨ててよい。</p>
<pre><code class="language-haskell">import qualified Data.IntMap as IM

part2 = loop 1 IM.empty
  where
    loop k im
      | n &gt;= theInput = (k, n)
      | otherwise     = loop (succ k) im1
      where
        ((k1, n), im1) =
          IM.deleteFindMin $
          IM.unionWith (+) im $
          IM.fromDistinctAscList $
          [(i, 11 * k) | i &lt;- map (k *) [1 .. 50]]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="パート1-19"><a class="header" href="#パート1-19">パート1</a></h1>
<p>装備のパラメータを (金額, 攻撃力, 防御力) というタプルで表す。</p>
<p>お買い物の全ての場合をリスト内包表記で数え上げてみる。</p>
<p>武器はひとつだけ選んで購入する。</p>
<pre><code class="language-haskell">    weapon &lt;- [(8,4,0),(10,5,0),(25,6,0),(40,7,0),(74,8,0)]
</code></pre>
<p>防具はひとつだけ選んで購入するか、使わないでもよい。</p>
<pre><code class="language-haskell">    armor &lt;- [(0,0,0),(13,0,1),(31,0,2),(53,0,3),(75,0,4),(102,0,5)]
</code></pre>
<p>指輪は二つまで使える。</p>
<pre><code class="language-haskell">rings = [(25,1,0),(50,2,0),(100,3,0),(20,0,1),(40,0,2),(80,0,3),(0,0,0)]

    (ring1:rs) &lt;- tails rings
    ring2 &lt;- if null rs then [ring1] else rs
</code></pre>
<p>総当たりの組み合わせを、費用の安い順にする。</p>
<pre><code class="language-haskell">cags = sort
  [ weapon `add` armor `add` ring1 `add` ring2
  | weapon &lt;- ...
  ]

add (a,b,c) (d,e,f) = (a+d,b+e,c+f)
</code></pre>
<p>自分のHP、攻撃力、防御力を \(h_1 = 100, a_1, g_1\)、
ボスのそれを \(h_2, a_2, g_2\) とする。</p>
<p>こちらの攻撃1回で削るHP量は \(\max(1, a_1-g_2)\) で、
ボスを倒すまでかかるターン数は \(\lceil \frac{h_2}{\max(1, a_1 - g_2)} \rceil\) である。</p>
<p>ボスからの攻撃1回で削られるHP量は \(\max(1, a_2-g_1)\) で、
耐えるターン数は \(\lceil \frac{h_1}{\max(1, a_1-g_2)} \rceil\) である。</p>
<p>結局、この戦いに勝つ条件は
\(\lceil \frac{h_1}{\max(1, a_1 - g_2)} \rceil \geq \lceil \frac{h_2}{\max(1, a_1 - g_2)} \rceil\)
となる。</p>
<pre><code class="language-haskell">win a1 g1 = divrup h1 (max 1 (a2 - g1)) &gt;= divrup h2 (max 1 (a1 - g2))

h2 = ...
a2 = ...
g2 = ... -- 入力データ

part1 = head $ filter (\(_,a1,g1) -&gt; win a1 g1) cags
</code></pre>
<h1 id="パート2-89"><a class="header" href="#パート2-89">パート2</a></h1>
<p>つまり上の逆順に、負ける最大の金額を探せばよい。</p>
<pre><code class="language-haskell">part2 = head $ filter (\(_,a1,g1) -&gt; not $ win a1 g1) $ reverse cags
</code></pre>
<!--
一般論で言えば `filter ... . reverse` は
`filter` で要素を減らしてから `reverse` する方がお得かもしれないが、
もしここで `win` の計算がとても重いような場合は、先に `reverse` する方がマシなので、
効率的なプログラムの構造は一意ではないぞ、とエディタのアシストに言いたい。
-->
<div style="break-before: page; page-break-before: always;"></div><p>コードにコメントを散々つけたので、それで読み解いて。
基本的に、忠実にシミュレーションを実行していく、
最小コストのものを見つけたいので、状態を保存する入れ物として</p>
<ul>
<li>スタック（LIFO, DFSになる）</li>
<li>キュー（FIFO, BFSになる）</li>
<li>優先度付きキュー（A*探索と呼ぶらしい）</li>
</ul>
<p>の最後のそれを使って、さらに、同じ状態を重複して計算しないように <code>Set</code> を使った。</p>
<pre><code class="language-haskell">import qualified Data.Set as S
import Data.Either
import Control.Monad

-- ゲームの各種状態を保持するレコード
data Status = Status
  { total :: Int    -- total used mana
  , bhp :: Int      -- boss hp
  , hp :: Int       -- player
  , mana :: Int     -- player
  , shield :: Int   -- count
  , poison :: Int   -- count
  , recharge :: Int -- count
  } deriving (Eq, Ord)
-- total を小さく抑えて、自分が勝てる方法があるか調べたいので、
-- totalの昇順キューを使ったA*探索で勝ち筋を探す。
-- 状況が重複する可能性があるので、Data.HeapでなくData.Setを用いる。
-- そのためtotalが先頭で、Ord型クラスが必要。

-- input.txt で与えられたパラメータ
bossHP = 51 :: Int
bossDamage = 9 :: Int

-- 自分の行動で起きる状態変化、または行動できないときNothing

-- マジックミサイル
splMissile :: Status -&gt; Maybe Status
splMissile stat
  | mana stat &lt; 53 = Nothing
  | True = Just ( stat { mana = mana stat - 53, bhp = bhp stat - 4
                       , total = total stat + 53 } )

-- ドレイン
splDrain :: Status -&gt; Maybe Status
splDrain stat
  | mana stat &lt; 73 = Nothing
  | True = Just ( stat { mana = mana stat - 73, hp = hp stat + 2, bhp = bhp stat - 2
                       , total = total stat + 73 } )

-- シールド
splShield :: Status -&gt; Maybe Status
splShield stat
  | mana stat &lt; 113 || shield stat &gt; 0 = Nothing
  | True = Just ( stat { mana = mana stat - 113, shield = 6, total = total stat + 113 } )

-- ポイズン
splPoison :: Status -&gt; Maybe Status
splPoison stat
  | mana stat &lt; 173 || poison stat &gt; 0 = Nothing
  | True = Just ( stat { mana = mana stat - 173, poison = 6, total = total stat + 173 } )

-- リチャージ
splRecharge :: Status -&gt; Maybe Status
splRecharge stat
  | mana stat &lt; 229 || recharge stat &gt; 0 = Nothing
  | True = Just ( stat { mana = mana stat - 229, recharge = 5, total = total stat + 229 } )

-- ターン開始時のカウントダウン
countdown :: Status -&gt; Status
countdown stat = stat
  { shield = max 0 (shield stat - 1)
  , poison = max 0 (poison stat - 1)
  , recharge = max 0 (recharge stat - 1)
  , bhp = bhp stat - if poison stat &gt; 0 then 3 else 0
  , mana = mana stat + if recharge stat &gt; 0 then 101 else 0
  }

-- 敵ボスからの攻撃
-- 自分が負ける場合はNothing
bossAttack :: Status -&gt; Maybe Status
bossAttack stat
  | hp1 &gt; 0 = Just ( stat { hp = hp1 } )
  | otherwise = Nothing
  where
    hp1 = hp stat - max 1 (bossDamage - if shield stat &gt; 0 then 7 else 0)

-- 初期状態
initial :: Status
initial = Status
  { hp = 50 , mana = 500
  , shield = 0 , poison = 0 , recharge = 0
  , bhp = bossHP
  , total = 0 }

{-
戦闘の過程で起きること

Player turn
1. countdown : poisonで決着する場合あり
2. spell : missile, drainで決着する場合あり
Boss turn
1. countdown : poisonで決着する場合あり
2. attack : 死亡での枝刈りあり

1,3,4は起きることは固定的、2は行動の選択肢がある
初期状態で1は何も起きない
ので、状態キューには1が終わった段階のものを格納し、
totalの小さい順に、2の選択肢ごとに状態の枝分かれを考える。
- 自分が死ぬ、MPが足りずにできない行動については捨てる
- ボスを倒す結果なら、最小結果を更新する(*)
- まだ続くなら、キューに追加する

(*)で最初に見つかったものが答えとは限らない。
キューでは後塵を拝しているけれど、次のターンで記録更新して勝利する場合もありうるから、
「これまでのベストスコア」を保持してループする。

キューの内容が（なにもまだしていないのに）これを上回ったら、その時点で探索は完了。
-}

compute1 :: Int -- 最小値
         -&gt; S.Set Status -- 調べる状態リスト
         -&gt; Int -- 結果
compute1 curTotal stats0
  | null stats0 = curTotal             -- 普通はないけれど、キューが空になったときはそれで終わり
  | curTotal &lt; total stat = curTotal   -- これ以上調べなくていい状態になったら終わり
  | otherwise = compute1 ct2 conts2    -- 状態遷移して続ける
      where
-- キューの先頭を取り出す
        (stat,stats) = S.deleteFindMin stats0
-- 行動によって異なる結果を仕分ける
        (ends,conts) = partitionEithers $
          do
-- プレイヤー行動
            Just stat1 &lt;- map ($ stat) [splMissile, splDrain, splShield, splPoison, splRecharge]
-- ボスを倒せたらLeftに
            if bhp stat1 &lt;= 0 then return (Left $ total stat1) else do
-- さもなくば続ける、ボスターンのカウントダウン
              let stat2 = countdown stat1
-- カウントダウンでボスが倒れたらLeftに
              if bhp stat2 &lt;= 0 then return (Left $ total stat2) else do
-- さもなくば続けて、ボスの攻撃
                Just stat3 &lt;- [bossAttack stat2]
-- 次のターンに入って、プレイヤーターンのカウントダウン
                let stat4 = countdown stat3
-- カウントダウンでボスが倒れたらLeftに まだ続くならRightに
                if bhp stat4 &lt;= 0 then return (Left $ total stat4) else return (Right stat4)
-- ベストスコアを更新
        ct2 = minimum (curTotal : ends)
-- 続ける場合をキューに追加
        conts2 = S.union stats $ S.fromList conts

-- パート1答え
part1 = compute1 maxBound (S.singleton initial)

-- パート2

-- パート1では初期状態でプレイヤーカウントダウンでは何も起きないのでそのまま入れたが、
-- 今回はプレイヤーカウントダウンでHPが1減って開始

initial2 = initial { hp = hp initial - 1 }

-- 基本的にcompute1と同じ。プレイヤーカウントダウン前にHP-1処理を挿入

compute2 :: Int -- 最小値
         -&gt; S.Set Status -- 調べる状態リスト
         -&gt; Int -- 結果
compute2 curTotal stats0
  | null stats0 = curTotal             -- 普通はないけれど、キューが空になったときはそれで終わり
  | curTotal &lt; total stat = curTotal   -- これ以上調べなくていい状態になったら終わり
  | otherwise = compute2 ct2 conts2    -- 状態遷移して続ける
      where
-- キューの先頭を取り出す
        (stat,stats) = S.deleteFindMin stats0
-- 行動によって異なる結果を仕分ける
        (ends,conts) = partitionEithers $
          do
-- プレイヤー行動
            Just stat1 &lt;- map ($ stat) [splMissile, splDrain, splShield, splPoison, splRecharge]
-- ボスを倒せたらLeftに
            if bhp stat1 &lt;= 0 then return (Left $ total stat1) else do
-- さもなくば続ける、ボスターンのカウントダウン
              let stat2 = countdown stat1
-- カウントダウンでボスが倒れたらLeftに
              if bhp stat2 &lt;= 0 then return (Left $ total stat2) else do
-- さもなくば続けて、ボスの攻撃
                Just stat3 &lt;- [bossAttack stat2]
-- パート2固有
-- 次のターンに入って、まずプレイヤーはHPを1失う。ここで倒れるならこの選択は捨てる
                let stat3a = stat3 { hp = hp stat3 - 1 }
                guard $ hp stat3a &gt; 0
-- パート2固有終わり
-- 次のターンに入って、プレイヤーターンのカウントダウン
                let stat4 = countdown stat3a
-- カウントダウンでボスが倒れたらLeftに まだ続くならRightに
                if bhp stat4 &lt;= 0 then return (Left $ total stat4) else return (Right stat4)
-- ベストスコアを更新
        ct2 = minimum (curTotal : ends)
-- 続ける場合をキューに追加
        conts2 = S.union stats $ S.fromList conts

-- パート2答え
part2 = compute2 maxBound (S.singleton initial2)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>（偶数を）半分にするとか（奇数を）3倍して1を足すとか、
どこかで聞いたような操作（コラッツ数列）しかないコンピュータだなぁ、と。</p>
<h1 id="入力-13"><a class="header" href="#入力-13">入力</a></h1>
<p>命令を観察すると、指定したレジスタの内容を演算して更新するものと、
レジスタの内容に関する条件によってジャンプをするもののふたつに分かれていることがわかる。
（無条件ジャンプも「常に成立する」条件が指定されていると見なせる。）</p>
<p>後で、レジスタの実体は配列で実現すると想定して、レジスタa,bは番号0,1で呼ぶことにする。
これらを踏まえて、命令を表す代数的データ型を定義する。</p>
<pre><code class="language-haskell">type Reg = Int
data Inst = Ialu (Int -&gt; Int) Reg | Ijmp (Int -&gt; Bool) Reg Int
</code></pre>
<p>命令一行を読み込む関数を定義する。
このとき命令に応じて妥当な関数を設定する。</p>
<pre><code class="language-haskell">parse :: String -&gt; Inst
parse xs =
  case words xs of
    ["hlf", reg] -&gt; Ialu (flip div 2) (regp reg)
    ["tpl", reg] -&gt; Ialu (3 *)        (regp reg)
    ["inc", reg] -&gt; Ialu succ         (regp reg)
    ["jmp", ofs] -&gt; Ijmp (const True) undefined (readofs ofs) -- 無条件
    ["jie", reg, ofs] -&gt; Ijmp even   (regp reg) (readofs ofs)
    ["jio", reg, ofs] -&gt; Ijmp (1 ==) (regp reg) (readofs ofs)
  where
    regp ('a':_) = 0             -- 後ろのコンマを無視できるように
    regp ('b':_) = 1
    readofs ('+':cs) = read cs   -- 数値は'+'付きだとreadできない
    readofs cs = read cs
</code></pre>
<p>プログラムはランダムアクセスするので、配列に格納しておこう。</p>
<pre><code class="language-haskell">import Data.Array

runner i f = do
  src &lt;- map parse . lines &lt;$&gt; readFile i
  let prog = listArray (1, length src) src
  print $ f $ prog

# パート1

プログラムカウンタが逸脱するまで命令を実行し続けるCPUエミュレータを作る。

```haskell
exec :: Array Int Inst -&gt; Int -&gt; Array Reg Int -&gt; Array Reg Int
exec prog pc regF
  | not $ inRange (bounds prog) pc = regF
  | otherwise =
    case prog ! pc of
      Ialu f r -&gt; exec prog (succ pc) (regF // [(r, f $ regF ! r)])
      Ijmp p r ofs | p (regF ! r) -&gt; exec prog (pc + ofs) regF
                   | otherwise    -&gt; exec prog (succ pc)  regF
</code></pre>
<p>入力を読み込み、レジスタを0に初期化して実行し、レジスタの最終状態を観察する。</p>
<pre><code class="language-haskell">part1 prog = exec prog 1 (listArray (0,1) [0,0])
</code></pre>
<h1 id="パート2-90"><a class="header" href="#パート2-90">パート2</a></h1>
<p>レジスタの初期値を変えて実行するだけ。</p>
<pre><code class="language-haskell">part1 prog = exec prog 1 (listArray (0,1) [1,0])
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><details><summary>解説</summary><div>
<p>入力の行数から、包みの個数はほどほどで、部分集合をビット表現するのに整数で足りる。
包みの部分集合について、その合計重量をキー、部分集合のビット表現のリストを値とするマップを、
「0個の取り合わせは0」から始めて、荷物をひとつずつ追加することで、全ての組み合わせの合計重量を求める。
ただし、総重量の1/3を超えるものは不要なので作らないようにする。
このマップの、総重量の1/3になる選択群から、条件を満たすものを選択する。</p>
<pre><code class="language-haskell">import qualified Data.IntMap as IM
import Data.Bits
import Data.List

compute1 xs = ...
  where
-- 重量の1/3、目標値
    w3 = div (sum xs) 3
-- 重量0にする方法は荷物なし、のみの初期値から、荷物を一つずつ追加
    im = foldl' step (IM.singleton 0 [0]) $ zip xs [0..]
-- i個めの重量xの荷物を追加したパターンをマップに追加
    step im (x, i) = IM.unionWith (++) im $ IM.fromAscList $
      [(w1, map (bit i .|.) bs) | (w,bs) &lt;- IM.assocs im, let w1 = w + x, w1 &lt;= w3]
-- 重量w3な全ての組み合わせが得られた
    bs = im IM.! w3 :: [Int]
</code></pre>
<p>見つかった組み合わせを、その要素数順、次に量子もつれの順で整列する。
これを小さい方から試して、3つの組み合わせで、互いに重なりないようなものが、探したいものである。</p>
<pre><code class="language-haskell">compute1 xs = ans
  where
    ...
-- 品数はpopCountで数える、量子もつれは重量の積、前者優先で昇順に整列
    cands = sort [(popCount b, qe, b) | b &lt;- bs, let qe = product [x | (i,x) &lt;- zip [0..pred num] xs, testBit b i]]
-- のこり2つの荷物について、使う荷物が重複しない組み合わせを探す
    ans = head
      [ qe
      | (_,qe,b1):cands1 &lt;- tails cands
      , (_,_ ,b2):cands2 &lt;- tails cands1, b1  .&amp;. b2 == 0, let b12 = b1 .|. b2
      , (_,_ ,b3)        &lt;-       cands2, b12 .&amp;. b3 == 0
      ]

main = readFile "input.txt" &gt;&gt;= print . compute1 . map read . lines
</code></pre>
<h1 id="パート2-91"><a class="header" href="#パート2-91">パート2</a></h1>
<p>分割が4つになるだけで、やることは変わらない。</p>
<pre><code class="language-haskell">compute2 xs = ans
  where
    w4 = div (sum xs) 4
    im = ...
    step im (x, i) = ...
    bs = im IM.! w4 :: [Int]
    cands = ...
    ans = head
      [ qe
      | (_,qe,b1):cands1 &lt;- tails cands
      , (_,_ ,b2):cands2 &lt;- tails cands1, b1   .&amp;. b2 == 0, let b12  = b1  .|. b2
      , (_,_ ,b3):cands3 &lt;- tails cands2, b12  .&amp;. b3 == 0, let b123 = b12 .|. b3
      , (_,_ ,b4)        &lt;-       cands3, b123 .&amp;. b4 == 0
      ]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><details><summary>解説</summary><div>
<p>行 <code>theRow</code> 列 <code>theCol</code> の値を聞かれている。
まず、それが数列の何個目の値かを、ひとつめの表を見ながら考える。</p>
<p>斜めの列の \(K\) 本めを考える。
それぞれの長さは順に \(1,2,3,\dots\) なので、その末尾の数は \(1 + 2 + \dots + K = K (K + 1) / 2\) となる。
またそれは行\(1\)列\(K\)の位置にある。</p>
<p>行 \(r\) 列\(c\) のマスは、そこから右上マスに\(r-1\)回移動した先にある、行\(1\)列\(c+r-1\)と同じ斜め列に属する。つまり \(K = c + r - 1\) 行に属する。
そのひとつ手前、\(K-1\)本めの斜め列の最後のマスの番号は \((K-1)K/2\) で、
行\(r\)列\(c\)のマスはそれからさらに\(c\)マス先にあるので \((c+r-2)(c+r-1)/2 + c\) 番である。</p>
<pre><code class="language-haskell">index r c = div ((c + r - 2) * (c + r - 1)) 2 + c
</code></pre>
<p>次に、数列の <code>index theRow theCol</code> 番めの値を求める。
第1項は <code>20151125</code>, 直前の項から次の項を得る漸化式から列を作る。</p>
<pre><code class="language-haskell">theSeed = 20151125
theMag  = 252533
modBase = 33554393

step :: Int -&gt; Int
step x = mod (x * theMag) modBase

theSeq = 0 : iterate step theSeed

part1 = theSeq (index theRow theCol)
</code></pre>
<p>しかし計算が終わらない。繰り返し回数が大きすぎる。</p>
<p>ここで、数列の定義をもう一度見てみる。</p>
<p>\(a_1 = 20151125\)<br />
\(a_{i+1} = a_i \times 252533 \bmod 33554393\)</p>
<p>剰余で考えればよいので、これはモジュロ演算で</p>
<p>\(a_i \equiv 20151125 \times 252533^{i-1} \bmod 33554393\)</p>
<p>と等しい。このべき乗は、2進数に基づいて高速に計算する定番の方法がある。</p>
<pre><code class="language-haskell">-- @gotoki_no_joe
powerish mul i a b = foldl' mul i [p | (True, p) &lt;- zip bs ps]
  where
    bs = map odd $ takeWhile (0 &lt;) $ iterate (flip div 2) b
    ps = iterate (\x -&gt; mul x x) a

part1a = powerish mul theSeed theMag $ pred $ index theRow theCol

mul x y = mod (x * y) modBase
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-14"><a class="header" href="#入力-14">入力</a></h1>
<p>入力は2つの数の対の並びになっているが、縦にグループで考えるようだ。
二つの <code>[Int]</code> にしておくといいだろう。</p>
<pre><code class="language-haskll">import Data.List

runner i f = do
  [xs, ys] &lt;- transpose . map (map read . words) . lines &lt;$&gt; readFile i
  let ans = f xs ys
  print ans

test1 = runner "sample.txt" part1
main1 = runner "input.txt" part1

part1 :: [Int] -&gt; [Int] -&gt; Int
part1 xs ys = ...
</code></pre>
<h1 id="パート1-20"><a class="header" href="#パート1-20">パート1</a></h1>
<p>最小値を選び、差を求め、それらを取り除き…と素朴にしなくても、もちろん、昇順に整列して要素毎に比べればよい。</p>
<pre><code class="language-haskell">part1 xs ys = sum $ map abs $ zipWith (-) (sort xs) (sort ys)
</code></pre>
<h1 id="パート2-92"><a class="header" href="#パート2-92">パート2</a></h1>
<p>入力データをざっくり眺めると、全て5桁の数のようなので、それを覆う配列に右の数の個数を集計しておいて、左の数で読み出すことでできる。
<code>IntMap</code> を使えば、データの範囲を気にする必要がなくなる。</p>
<p>後で同じ数を掛けるなら、右の数について個数でなくてその数の合計、を求めておけば掛け算もいらなくなる。</p>
<p><code>IntMap</code> 版</p>
<pre><code class="language-haskell">import qualified Data.IntMap as IM

test2 = runner "sample.txt" part2
main2 = runner "input.txt" part2

part2 :: [Int] -&gt; [Int] -&gt; Int
part2 xs ys = sum [IM.findWithDefault 0 x cnt | x &lt;- xs]
  where
    cnt = IM.fromListWith (+) [(y, y) | y &lt;- ys]
</code></pre>
<p>配列版</p>
<pre><code class="language-haskell">import Data.Array

part2a :: [Int] -&gt; [Int] -&gt; Int
part2a xs ys = sum $ map (cnt !) xs
  where
    cnt = accumArray (+) 0 (0,99999) $ zip ys ys
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-15"><a class="header" href="#入力-15">入力</a></h1>
<p>数値列の列、をリストにして渡すことにする。</p>
<pre><code class="language-haskell">runner i f = do
  xss &lt;- map (map read . words) . lines &lt;$&gt; readFile i
  print $ f xss

test1 = runner "sample.txt" part1
main1 = runner "input.txt"  part1

part1 :: [[Int]] -&gt; Int
part1 xss = ...
</code></pre>
<h1 id="パート1-21"><a class="header" href="#パート1-21">パート1</a></h1>
<p>隣接する要素の差をとったとき、全て 1 以上 3 以下である（上昇列）か、
全て -1 以下 -3 以上である（下降列）であるときが安全の条件になる。
ひとつの列に対して、この条件を満たすか判定する述語を作る。</p>
<pre><code class="language-haskell">prop1 :: [Int] -&gt; Bool
prop1 xs = all (1 &lt;=) ds &amp;&amp; all (3 &gt;=) ds || all (-3 &lt;=) ds &amp;&amp; all (-1 &gt;=) ds
  where
    ds = zipWith (-) xs $ tail xs
</code></pre>
<p>これを満たす列の個数を数える。</p>
<pre><code class="language-haskell">part1 = length . filter prop1
</code></pre>
<h2 id="少しこすいやり方"><a class="header" href="#少しこすいやり方">少しこすいやり方</a></h2>
<p>全ての要素を真面目に調べる代わりに、差の最小値と最大値だけ見比べる、でもできる。
が、最大値と最小値を取り出すのに同じ計算量がかかるので、オーダーは変わらない。
ちなみに、最小値と最大値を同時に求める計算を使えば計算量は半分にはできる。</p>
<pre><code class="language-haskell">prop1 :: [Int] -&gt; Bool
prop1 xs = -3 &lt;= dmin &amp;&amp; dmax &lt;= -1 || 1 &lt;= dmin &amp;&amp; dmax &lt;= 3
  where
    (dmin, dmax) = minmaximum $ zipWith (-) xs $ tail xs

minmaximum :: Ord a =&gt; [a] -&gt; (a, a)
minmaximum (x:xs) = loop x x xs
  where
    loop l u [] = (l,u)
    loop l u (x:xs)
      | x &lt; l = loop x u xs
      | u &lt; x = loop l x xs
      | True  = loop l u xs
</code></pre>
<h1 id="パート2-93"><a class="header" href="#パート2-93">パート2</a></h1>
<p>ひとつひとつの列は大した長さではないので、総当たりでいく。
リストから、いずれかひとつの要素を取り除いた列全て、をがんばって再帰関数で作ってもいいが、
そうしなくてもいい。</p>
<pre><code class="language-haskell">import Data.List

drop1 xs = zipWith (++) (inits xs) (tail $ tails xs)

prop2 :: [Int] -&gt; Bool
prop2 xs = any prop1 $ xs : drop1 xs

part2 :: [[Int]] -&gt; Int
part2 = length . filter prop2

test2 = runner "sample.txt" part2
main2 = runner "input.txt"  part2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-16"><a class="header" href="#入力-16">入力</a></h1>
<p>単なる長い一行なので、読み込むしかない。
<code>readFile</code>は末尾の改行文字を残すので注意。</p>
<pre><code class="language-haskell">runner i f = readFile i &gt;&gt;= print . f . init

test1 = runner "sample.txt" part1
main1 = runner "input.txt" part1

part1 :: String -&gt; Int
part1 xs = ...
</code></pre>
<p>正規表現あったら楽な話だねこれ…</p>
<h1 id="パート1-22"><a class="header" href="#パート1-22">パート1</a></h1>
<h2 id="凝らない普通のプチ富豪的なやり方"><a class="header" href="#凝らない普通のプチ富豪的なやり方">凝らない、普通の、プチ富豪的なやり方</a></h2>
<p>パターンは重なり合うこともないので、<code>tails</code> を使って文字列の全ての途中から調べて、
目標のパターンが見つかったら結果を返して集計する、とできそう。</p>
<pre><code class="language-haskell">import Data.List

part1 xs = sum $ map findit $ tails xs
</code></pre>
<p><code>findit</code> は、まず先頭4文字を取り出して、それが <code>mul(</code> でなければ失敗する。
次に、数字文字が続くだけ切り出して、それが1文字以上3文字以下でなければ失敗する。
その続きが <code>,</code> でなければ失敗する。
その次もまた数字文字の連続を切り出す。
最後に <code>)</code> を確認する。</p>
<pre><code class="language-haskell">import Data.Char

findit :: String -&gt; Int
findit xs
  | c1, c2, c3, c4, c5 = read xs3 * read xs5
  | otherwise = 0
  where
    (xs1,xs2) = splitAt 4 xs               -- 先頭4文字が "mul(" で
    c1 = xs1 == "mul("
    (xs3,xs4) = span isDigit xs2           -- つづく数字列が
    l1 = length xs3
    c2 = 1 &lt;= l1 &amp;&amp; l1 &lt;= 3                -- 3文字以下で
    c3 = not (null xs4) &amp;&amp; head xs4 == ',' -- コンマがあって
    (xs5,xs6) = span isDigit $ tail xs4    -- 3文字までの数字列があって
    l2 = length xs5
    c4 = 1 &lt;= l2 &amp;&amp; l2 &lt;= 3
    c5 = not (null xs6) &amp;&amp; head xs6 == ')' --カッコ閉じで終わる
</code></pre>
<h2 id="カイゼン"><a class="header" href="#カイゼン">カイゼン</a></h2>
<p>確かにこれで答えは出るけど、なんとも書き捨て感がある。
「固定の文字列があるか確認して、あれば続きを返す、なければ失敗する」
「3文字までの数字列があるか確認して、あればその数値と続きを返す、なければ失敗する」
という計算にパターンを括りだしてみよう。</p>
<pre><code class="language-haskell">str pat xs
  | as == pat = Just bs
  | otherwise = Nothing
  where
    (as,bs) = splitAt (length pat) xs

-- 調べたらこれ Data.List.stripPrefix だった。

num3 xs
  | 1 &lt;= l &amp;&amp; l &lt;= 3 = Just (read as, bs)
  | otherwise = Nothing
  where
    (as,bs) = span isDigit xs
    l = length as
</code></pre>
<p>すると、これを利用する上位の計算は、<code>Maybe</code>モナドで流れを制御できる。</p>
<pre><code class="language-haskell">findit :: String -&gt; Maybe Int
findit xs = do
  xs1 &lt;- stripPrefix "mul("
  (n1, xs2) &lt;- num3 xs1
  xs3 &lt;- stripPrefix "," xs2
  (n2, xs3) &lt;- num3 xs3
  str ")"
  return $ n1 * n2
</code></pre>
<p>呼び出し元はこうなる。</p>
<pre><code class="language-haskell">import Data.List

part1 xs = sum $ mapMaybe findit $ tails xs
</code></pre>
<p>失敗した瞬間に <code>findit</code> 全体を放棄できるのはいいが、
「残りの文字列」をいちいち受け取っては次に送るところがダルい。
それは State モナドを使えば配管を裏に通せるはずだ。</p>
<pre><code class="language-haskell">import Control.Monad
import Control.Monad.State

str :: String -&gt; StateT String Maybe () -- 裏の状態としてStringを持つStateモナドで、
str x = do                              -- 表の実行制御はMaybeモナドで、このアクションの結果は ()
  (s1,s2) &lt;- splitAt (length x) &lt;$&gt; get
  guard $ s1 == x                       -- Maybeモナドで失敗を制御
  put s2

-- モナド全開版
str x = get &gt;&gt;= lift . stripPrefix x &gt;&gt;= put

number :: StateT String Maybe Int
number = do
  (s1,s2) &lt;- span isDigit &lt;$&gt; get
  let dlen = length s1
  guard $ 1 &lt;= dlen &amp;&amp; dlen &lt;= 3
  put s2
  return $ read s1

mulCmd :: StateT String Maybe Int
mulCmd = do
  str "mul("
  n1 &lt;- number
  str ","
  n2 &lt;- number
  str ")"
  return $ n1 * n2

findit :: String -&gt; Maybe Int
findit xs = evalStateT mulCmd xs
</code></pre>
<p><code>mulCmd</code> のコードは、関心のあることだけに集中できてかなりいい感じ。
いつの間にか、簡単なパーサコンビネータみたいになっている。</p>
<h2 id="完成"><a class="header" href="#完成">完成</a></h2>
<p>ここまで来たら</p>
<ul>
<li>一度パターンの読み取りに成功したら、その次から続行</li>
<li>パターンが見つからなければ、1文字は読み飛ばし、さらに <code>m</code> でない文字を全て読み飛ばしてから再挑戦</li>
<li>文字列が空になったら終わり</li>
<li>見つかった積の結果は次に伝えて累積する</li>
</ul>
<p>という形まで昇華させよう。</p>
<pre><code class="language-haskell">import Control.Applicative

part1 :: String -&gt; Maybe Int
part1 xs = evalStateT (topLevel 0) xs

endOfFile :: StateT String Maybe ()
endOfFile = do
  s &lt;- get
  guard $ null s

topLevel :: Int -&gt; StateT String Maybe Int
topLevel acc =
  do
    endOfFile
    return acc
  &lt;|&gt;
  do
    n &lt;- mulCmd
    topLevel $! acc + n
  &lt;|&gt;
  do -- 不要な文字読み飛ばし
    modify $ dropWhile ('m' /=) . drop 1
    topLevel acc
</code></pre>
<p><code>topLevel</code> 内の、不要な文字読み飛ばしの位置関係が繊細で、間違えると分岐が爆発して帰ってこなくなる。どうしてそうなのかちょっとよくわからない。</p>
<h1 id="パート2-94"><a class="header" href="#パート2-94">パート2</a></h1>
<p>パート1の完成版をベースにして、<code>topLevel</code> を disabled なものと相互参照するようにすればすぐできる。</p>
<pre><code class="language-haskell">test2 = runner "sample2.txt" part2
main2 = runner "input.txt" part2

part2 :: String -&gt; Maybe Int
part2 xs = evalStateT (topLevel2 0) xs

topLevel2 :: Int -&gt; StateT String Maybe Int
topLevel2 acc =
  do
    endOfFile
    return acc
  &lt;|&gt;
  do
    n &lt;- mulCmd
    topLevel2 $! acc + n
  &lt;|&gt;
  do
    str "don't()"
    disabled acc
  &lt;|&gt;
  do
    modify $ dropWhile (\c -&gt; c /= 'm' &amp;&amp; c /= 'd') . drop 1
    topLevel2 acc

disabled :: Int -&gt; StateT String Maybe Int
disabled acc =
  do
    endOfFile
    return acc
  &lt;|&gt;
  do
    str "do()"
    topLevel2 acc
  &lt;|&gt;
  do
    modify $ dropWhile ('d' /=) . drop 1
    disabled acc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-17"><a class="header" href="#入力-17">入力</a></h1>
<p>二次元配列に読み込んでおけばよいだろう。</p>
<pre><code class="language-haskell">import Data.Array

runner i f = do
  ls &lt;- lines &lt;$&gt; readFile i
  let h = length ls
      w = length $ head ls
      arr = listArray ((1,1),(h,w)) $ concat ls
  print $ f arr

test1 = runner "sample.txt" part1
main1 = runner "input.txt" part1

part1 :: Array (Int,Int) Char -&gt; Int
part1 arr = ...
</code></pre>
<h1 id="パート1-23"><a class="header" href="#パート1-23">パート1</a></h1>
<p>まず、配列の外まで踏み出してアクセスしてしまったときにエラーにならないようなラッパーを作っておく。</p>
<pre><code class="language-haskell">readArr arr i
  | inRange (bounds arr) i = arr ! i
  | otherwise = '#'
</code></pre>
<p>全てのマスについて、先頭が <code>X</code> であるとき、
8方向全てについて、</p>
<ol>
<li>次に <code>M</code> があり</li>
<li>その次に <code>A</code> があり</li>
<li>その次に <code>S</code> がある</li>
</ol>
<p>ような向きを数え上げればよい。</p>
<pre><code class="language-haskell">part1 :: Array (Int,Int) Char -&gt; Int
part1 arr = length
  [ ()
  | (p, 'X') &lt;- assocs arr
  , d &lt;- ds
  , let p1 = add p  d, readArr arr p1 == 'M'
  , let p2 = add p1 d, readArr arr p2 == 'A'
  , let p3 = add p2 d, readArr arr p3 == 'S'
  ]

ds :: [(Int, Int)]
ds = [(i,j) | i &lt;- [-1 .. 1], j &lt;- [-1 .. 1], (i,j) /= (0,0)]

add :: (Int, Int) -&gt; (Int, Int) -&gt; (Int, Int)
add (a,b) (c,d) = (a+c, b+d)
</code></pre>
<h1 id="パート2-95"><a class="header" href="#パート2-95">パート2</a></h1>
<p><code>A</code> がある位置全てについて、（左上、右下）の文字の組と、（左下、右上）の文字の組を考える。
どちらとも <code>('M', 'S')</code> または <code>('S', 'M')</code> の組み合わせならば、それは <code>X-MAS</code> である。</p>
<pre><code class="language-haskell">test2 = runner "sample.txt" part2
main2 = runner "input.txt" part2

part2 :: Array (Int,Int) Char -&gt; Int
part2 arr = length
  [ ()
  | (p, 'A') &lt;- assocs arr
  , let c7 = readArr arr $ add p (-1,-1)
  , let c3 = readArr arr $ add p ( 1, 1)
  , mssm c7 c3
  , let c9 = readArr arr $ add p (-1, 1)
  , let c1 = readArr arr $ add p ( 1,-1)
  , mssm c1 c9
  ]

mssm :: Char -&gt; Char -&gt; Bool
mssm 'M' 'S' = True
mssm 'S' 'M' = True
mssm _ _ = False
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-18"><a class="header" href="#入力-18">入力</a></h1>
<p>二つの異なる種類のデータが入力される面倒なタイプ。</p>
<p>まず、デリミタである空行で前半と後半に分ける。
ページ番号に負はないし、あとはいつものように <code>wordsBy (not . isDigit)</code> で読み込めばいい。
前半はペアにしておきたい気もするが、リストでも別にいいだろう。</p>
<p>というか、先に数値読み取りを済ませてからの方が楽だ。</p>
<pre><code class="language-haskell">import Data.List
import Data.List.Split
import Data.Char

runner i f = do
  nss &lt;- map (map read . wordsBy (not . isDigit)) . lines &lt;$&gt; readFile i
  let (nss1, _:nss2) = break null nss
  print $ f nss1 nss2

test1 = runner "sample.txt" part1
main2 = runner "input.txt" part1

part1 :: [[Int]] -&gt; [[Int]] -&gt; Int
part1 rules updates = ...
</code></pre>
<h1 id="パート1-24"><a class="header" href="#パート1-24">パート1</a></h1>
<h2 id="分かりやすいけど重いやり方"><a class="header" href="#分かりやすいけど重いやり方">分かりやすいけど重いやり方</a></h2>
<p>ひとつの更新について、正しいかどうかを判定する。
個々の規則 <code>x|y</code> について、更新の中に <code>x</code>, <code>y</code> が現れる位置を <code>elemIndex</code> で調べ、
両方とも存在する場合、位置関係を確認する。
片方でも見つからない場合は、規則が適用されないだけになる。</p>
<pre><code class="language-haskell">part1 :: [[Int]] -&gt; [[Int]] -&gt; Int
part1 rules = sum . map getCenter . filter (validate rules)

getCenter xs = xs !! div (length xs) 2

validate rules update = and
  [ valid i j
  | l:r:_ &lt;- rules
  , let i = elemIndex l update
  , let j = elemIndex r update]
  where
    valid (Just a) (Just b) = a &lt; b
    valid _ _ = True
</code></pre>
<h2 id="あたまの混乱するやり方"><a class="header" href="#あたまの混乱するやり方">あたまの混乱するやり方</a></h2>
<p>前から順にページを確定させていったとき、ページ <code>x</code> を確定させると、
規則ではそのページより前になければならないページは、これ以降に入れることはできなくなる。
ページを追加するごとにそのような制約が増えていき、
各時点での制約に反していないページが追加されている限りは問題ない、
とすると、必要なことだけを確認する、より高速な手順ができるだろう。</p>
<p>これを実行するために必要な下準備は、各ページ <code>x</code> に対して、
それが右側に現れている規則の左側のページ番号の集合を取り出せるようにしておくことである。
なお、パズル入力ではページ番号は全て2桁の数字のようなので、配列を使う。</p>
<pre><code class="language-haskell">test1a = runner "sample.txt" part1a
main1a = runner "input.txt" part1a

part1a :: [[Int]] -&gt; [[Int]] -&gt; Int
part1a rules = sum . map getCenter . filter (validate2 ra)
  where
    ra = fmap IS.fromList $ accumArray (flip (:)) [] (1,99) [(r, l) | l:r:_ &lt;- rules]

validate2 ra update = loop IS.empty update
  where
    loop _ [] = True
    loop prohibited (x:xs) = IS.notMember x prohibited &amp;&amp; loop (IS.union prohibited $ ra ! x) xs
</code></pre>
<h1 id="パート2-96"><a class="header" href="#パート2-96">パート2</a></h1>
<p>規則に反していると判定された更新一つについて、正しい並べ方を作る方法を考える。</p>
<h2 id="探索解法"><a class="header" href="#探索解法">探索解法</a></h2>
<p><code>Data.List.permutations</code> で順列を全て作り、<code>validate2</code> が通るものを選ぶ、というのはいかにも乱暴である。
実際それは間に合わない。</p>
<p>しかし高速な <code>validate2</code> の計算を参考にして、
次に印刷するページの候補は、残りのページ集合（自分も含めて良い）と、自分が禁止するページ集合がdisjointであること。
つまり、他のまだ残っているページを誰も禁止にしないものなら選ぶことができる。
（そうでないと、一度禁止されたページはそれ以降決して出せないから。）<br />
これで全てのページが並べられたら成功である。</p>
<pre><code class="language-haskell">test2 = runner "sample.txt" part2
main2 = runner "input.txt" part2

part2 :: [[Int]] -&gt; [[Int]] -&gt; Int
part2 rules = sum . map (getCenter . makeCorrect ra) . filter (not . validate2 ra)
  where
    ra = fmap IS.fromList $ accumArray (flip (:)) [] (1,99) [(r, l) | l:r:_ &lt;- rules]

makeCorrect ra update = head $ loop $ IS.fromList update
  where
    loop upd
      | IS.null upd = [[]]
      | otherwise =
        [ p : qs
        | p &lt;- IS.elems upd, IS.disjoint upd $ ra ! p
        , qs &lt;- loop $ IS.delete p upd]
</code></pre>
<h2 id="グラフアルゴリズムによる解法"><a class="header" href="#グラフアルゴリズムによる解法">グラフアルゴリズムによる解法</a></h2>
<p>規則 <code>x|y</code> は、<code>y</code> よりも <code>x</code> が先に選ばれる必要があることを意味している。
このような関係が要素を制約しているとき、
要素をノード、関係を有向辺とするグラフに対するトポロジカルソートが、制約を満たす順序を与える。
これは標準ライブラリ <code>Data.Graph</code> にあるので、これを使ってもこの問題は解ける。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-19"><a class="header" href="#入力-19">入力</a></h1>
<p>状況の地図をそのまま配列にして渡せばよいだろう。</p>
<pre><code class="language-haskell">import Data.Array.Unboxed

runner i f = do
  ls &lt;- lines &lt;$&gt; readFile i
  let h = length ls
      w = length $ head ls
      arr = listArray ((1,1),(h,w)) $ concat ls
  print $ f arr

test1 = runner "sample.txt" part1
main1 = runner "input.txt" part1

part1 arr = ...
</code></pre>
<h1 id="パート1-25"><a class="header" href="#パート1-25">パート1</a></h1>
<p>移動方向に関して、90度右回転した後の移動方向を求める計算と、
移動ベクトルを座標に足し込んで一歩進む計算：</p>
<pre><code class="language-haskell">rot :: (Int,Int) -&gt; (Int,Int)
rot (dx,dy) = (dy, - dx)

add :: (Int, Int) -&gt; (Int, Int) -&gt; (Int, Int)
add (a,b) (c,d) = (a+c,b+d)
</code></pre>
<p>守衛の出発地点から、範囲外に落ちるまで、忠実にシミュレーションをかける。
一度踏んだ場所に足跡をつけ、踏まれたマスを数える。</p>
<pre><code class="language-haskell">import Data.Array.ST
import Control.Monad.ST
import Control.Monad

part1 :: UArray (Int, Int) Char -&gt; Int
part1 arr = runST $ do
      stain &lt;- newArray bnds False -- 足跡
      writeArray stain pos0 True   -- 初期位置を踏む
      walking stain pos0 (-1,0)
      length . filter id &lt;$&gt; getElems stain
  where
    bnds = bounds arr
    -- 守衛の最初の位置
    pos0 = head [p | (p, '^') &lt;- assocs arr]
    walking :: STUArray s (Int, Int) Bool
            -&gt; (Int, Int) -&gt; (Int, Int) -&gt; ST s ()
    walking stain pos dir
      | not (inRange bnds pos1) = return () -- 踏み出すと落ちるなら終わり
      | arr ! pos1 /= '#' = writeArray stain pos1 True &gt;&gt; walking stain pos1 dir -- 進めるなら進む
      | otherwise = walking stain pos (rot dir) -- 進めないなら右を向く
      where
        pos1 = add pos dir
</code></pre>
<h1 id="パート2-97"><a class="header" href="#パート2-97">パート2</a></h1>
<p>障害物を追加して意味があるのは、パート1で足跡の付いた位置のみ。ただし初期位置を除く。
なので、そのような場所を記録した配列を作る計算をコードクローンで作る。</p>
<pre><code class="language-haskell">test2 = runner "sample.txt" part2
main2 = runner "input.txt" part2

part2 :: UArray (Int, Int) Char -&gt; Int
part2 arr = ...
  where
    bnds@(l,u) = bounds arr
    -- 守衛の最初の位置
    pos0 = head [p | (p, '^') &lt;- assocs arr]
    -- 障害物なしで踏む場所
    strain = runSTUArray $ do
      stain &lt;- newArray bnds False -- 足跡
      walking stain pos0 (-1,0)
      writeArray stain pos0 False   -- 初期位置を除外
      return stain
    walking ... -- 変わらず
</code></pre>
<p>どこかで落ちてしまうことは、落ちたときにわかる。
一方、どこまでも落ちずに歩き続けられることは、判定が面倒くさい。守衛の停止性問題。</p>
<ul>
<li>方策1:
守衛がループせずに歩ける最大の歩数は、上下左右どちらの向きからそのマスに入るかの数で数えて、
空間のマスの個数の4倍。これを越えて、端から落ちずに歩き続けられるということは、
どこかでループに入っているはずである。<br />
これは、コーディングは楽だが実行時間が長そう。</li>
<li>方策2:
足跡の情報を拡張し、そのマスにどの向きから入ったかを記録する。
以前同じ方向からそのマスに入ったことがあるなら、その時点でループが発生している。<br />
ループが発生した瞬間を捕まえられるが、コーディングが面倒。</li>
</ul>
<p>せっかくなので後者でやろう。</p>
<p>まず、向きごとに <code>strain</code> を拡張して4面にする。
進入する向きを添え字に変換する関数を立てておく。</p>
<pre><code class="language-haskell">d2i :: (Int,Int) -&gt; Int
d2i (-1,0) = 0
d2i ( 0,1) = 1
d2i ( 1,0) = 2
d2i (0,-1) = 3
</code></pre>
<p>拡張した <code>strain</code> を使う <code>walking</code> の拡張版を作る。
ループしたか端で落ちたかのオチだけ教えてくれればいい。</p>
<pre><code class="language-haskell">    causeLoop arr2 = runST $ do
      strain &lt;- newArray ((l,0),(u,3)) False
      walking2 arr2 strain pos0 (-1,0)
    walking2 :: UArray (Int,Int) Char
             -&gt; STUArray s ((Int, Int), Int) Bool
             -&gt; (Int, Int) -&gt; (Int, Int) -&gt; ST s Bool
    walking2 arr2 stain pos dir
      | not (inRange bnds pos1) = return False        -- 落ちた
      | arr2 ! pos1 /= '#' = do                       -- 進める
          b &lt;- readArray stain (pos1, d2i dir)
          if b then return True else do               -- ループ検出
            writeArray stain (pos1, d2i dir) True
            walking2 arr2 stain pos1 dir              -- 進む
      | otherwise = walking2 arr2 stain pos (rot dir) -- 進めないなら右を向く
      where
        pos1 = add pos dir
</code></pre>
<p>ほぼコードクローンだ。</p>
<p>障害物を置いたマップを作成しては <code>causeLoop</code> でチェックし、ループになったものを数える。</p>
<pre><code class="language-haskell">part2 arr = length
    [ ()
    | (obs, True) &lt;- assocs strain
    , let arr2 = arr // [(obs, '#')]
    , causeLoop arr2 ]
  where
    ...
</code></pre>
<p><code>ghci</code> だとちょっと時間かかるので、コンパイルして動かそう。</p>
<pre><code class="language-haskell">main = test1 &gt;&gt; main1 &gt;&gt; test2 &gt;&gt; main2
</code></pre>
<p>とやっているうちにインタプリタでも結果が出ていた。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-20"><a class="header" href="#入力-20">入力</a></h1>
<p>たまには真面目に、行ごとに、コロンの前後で分けて、前半はひとつの整数、後半は整数列にして対にする。</p>
<pre><code class="language-haskell">runner i f = do
  ls &lt;- lines &lt;$&gt; readFile i
  print $ f $ map parse ls

parse :: String -&gt; (Int, [Int])
parse l = (read as, map read $ words bs)
  where
    (as,_:bs) = break (':' ==) l

test1 = runner "sample.txt" part1
main1 = runner "input.txt" part1

part1 :: [(Int,[Int])] -&gt; Int
part1 rxss = ...
  where
</code></pre>
<h1 id="パート1-26"><a class="header" href="#パート1-26">パート1</a></h1>
<p>右の先頭の値から始めて、それぞれのステップまでで作れる数のリストを維持して、
二つの演算の結果でリストを伸ばしていく方法でやってみる。</p>
<pre><code class="language-haskell">    compute (x:xs) = foldl step [x] xs
    step ys x = map (x +) ys ++ map (x *) ys
</code></pre>
<p>右の結果の中に左が含まれているものを選び出し、総和を求める。</p>
<pre><code class="language-haskell">part1 rxss = sum [ r | (r,xs) &lt;- rxss, elem r $ compute xs]
  where
    ...
</code></pre>
<p>右の数ごとに要素は倍に増えるのでどうかと思ったが、特に時間がかかることもなかった。
このままで最適化するとすれば、左の数を超えたら途中でも捨てる、くらいか。</p>
<h1 id="パート2-98"><a class="header" href="#パート2-98">パート2</a></h1>
<p>演算が増えただけ。<code>‖</code> 演算は、右の桁数だけの10の階乗を左に掛けて、右を足せばいい。
<code>read (show l ++ show r)</code> でもいいけど…</p>
<pre><code class="language-haskell">    ll x y = y * mag + x
      where
        mag = 10 ^ length (show x)
-- ズボラな版
    ll x y = read $ show y ++ show x
</code></pre>
<pre><code class="language-haskell">test2 = runner "sample.txt" part2
main2 = runner "input.txt" part2

part2 :: [(Int,[Int])] -&gt; Int
part2 rxss = sum [ r | (r,xs) &lt;- rxss, elem r $ compute r xs]
  where
    compute r (x:xs) = foldl (step r) [x] xs
    step r ys x = filter (r &gt;=) $ map (x +) ys ++ map (x *) ys ++ map (ll x) ys
</code></pre>
<p>打ち切りを入れた。それでもまだ遅い。
値の重複がキャンセルされることを期待して、<code>IntSet</code> を使ってみる。</p>
<pre><code class="language-haskell">test2a = runner "sample.txt" part2a
main2a = runner "input.txt" part2a

part2a :: [(Int,[Int])] -&gt; Int
part2a rxss = sum [ r | (r,xs) &lt;- rxss, IS.member r $ compute r xs]
  where
    compute r (x:xs) = foldl (step r) (IS.singleton x) xs
    step r ys x = fst $ IS.split (succ r) $ IS.unions
      [IS.mapMonotonic (x +) ys, IS.mapMonotonic (x *) ys, IS.mapMonotonic (ll x) ys]
    ll x y = y * mag + x
      where
        mag = 10 ^ length (show x)
</code></pre>
<p>割と本気だったのだけど、測ってみると(ghciで)</p>
<pre><code class="language-haskell">timeit action = do
  t1 &lt;- getCPUTime
  action
  t2 &lt;- getCPUTime
  print $ t2 - t1
</code></pre>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">実装</th><th style="text-align: left">時間</th></tr></thead><tbody>
<tr><td style="text-align: center">リスト</td><td style="text-align: left">5秒</td></tr>
<tr><td style="text-align: center">IntMap</td><td style="text-align: left">6.5秒</td></tr>
</tbody></table>
</div>
<p>リストの方が速かった。残念。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-21"><a class="header" href="#入力-21">入力</a></h1>
<p>アンテナの記号ごとに、その位置する座標を集めてリストにしたものがあればよさそうだ。
それほど急ぐわけでもないので、文字からリストへの <code>Map</code> で表現しよう。
（速度が気になるなら、文字を例えば "AB...Zab...z0..9" の順に背番号を振って、これを添え字として配列で扱う手もある。）</p>
<p>フィールドの広さも必要。</p>
<pre><code class="language-haskell">import qualified Data.Map as M

runner i f = do
  ls &lt;- lines &lt;$&gt; readFile i
  let h = length ls
      w = length $ head ls
      m = buildMap ls
  print $ f h w m

buildMap :: [String] -&gt; M.Map Char [(Int,Int)]
buildMap ls = M.fromListWith (++) [(c,[(i,j)]) | (i, l) &lt;- zip [1 ..] ls, (j, c) &lt;- zip [1 ..] l, c /= '.']

test1 = runner "sample.txt" part1
main1 = runner "input.txt" part1

part1 :: Int -&gt; Int -&gt; M.Map Char [(Int,Int)] -&gt; Int
part1 h w m = ...
</code></pre>
<h1 id="パート1-27"><a class="header" href="#パート1-27">パート1</a></h1>
<p>同じ周波数のアンテナについて、その中から2つを選ぶ全ての組み合わせに関して、
片方からもう片方を中心とする点対称の位置に、つまり両側に二つの波腹が発生する。
ただし、フィールドの範囲を外れるものは無視する。</p>
<pre><code class="language-haskell">part1 h w m = S.size antinodes
  where
    antinodes = S.fromList
      [ anti
      | ps &lt;- M.elems m
      , (a,b):cds &lt;- tails ps, (c,d) &lt;- cds
      , anti &lt;- [(c+c-a,d+d-b), (a+a-c,b+b-d)]
      , inRange ((1,1),(h,w)) anti
      ]
</code></pre>
<h1 id="パート2-99"><a class="header" href="#パート2-99">パート2</a></h1>
<p>この説明だけでは、例えば(0,0)と(2,2)にアンテナがあったとき、
(4,4)は数えることはわかるが、(1,1)を数えるべきかがはっきりしない。
まずは、それを考慮する必要があるかどうかを確認する。</p>
<p>これは、アンテナの相対位置が、1より大きい公約数を持たずに互いに素であればよい。
互いに素とは、最大公約数が1であることなので、全ての組み合わせについてそれを求め、
値ごとの個数を数えてみる。</p>
<pre><code class="language-haskell">cntGCD h w m = gcdCnt
  where
    gcdCnt = M.fromListWith (+)
      [ (gcd (abs $ a - c) (abs $ b - d), 1)
      | ps &lt;- M.elems m
      , (a,b):cds &lt;- tails ps, (c,d) &lt;- cds
      ]
</code></pre>
<p>結局、そういう場合はなく、相対位置の整数倍だけ考えればよいとわかった。
もしそういう場合が含まれるのなら、最大公約数で相対ベクトルを割ってからやればいいだけなので、
実際には大して違いはない。</p>
<p>そして、Haskellのレンジ記法を用いると、パート1よりも無精して計算できる。</p>
<pre><code class="language-haskell">test2 = runner "sample.txt" part2
main2 = runner "input.txt" part2

part2 :: Int -&gt; Int -&gt; M.Map Char [(Int,Int)] -&gt; Int
part2 h w m = S.size antinodes
  where
    antinodes = S.fromList
      [ anti
      | ps &lt;- M.elems m
      , (a,b) &lt;- ps, (c,d) &lt;- ps, (a,b) /= (c,d)
      , anti &lt;- takeWhile (inRange ((1,1),(h,w))) $ zip [a, c ..] [b, d ..]
      ]
</code></pre>
<p>むしろパート1から、この <code>zip</code> が生成するリストの <code>(!! 2)</code> として無精することに気づかなかったのが「負け」だったかも。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-22"><a class="header" href="#入力-22">入力</a></h1>
<p>1文字ごとの数に直したリストを渡そう。
本番データは20,000文字ある。全て9の最悪の場合で180,000ブロック。
直接扱ってもまだ対応できる規模。</p>
<pre><code class="language-haskell">import Data.Char

runner i f = readFile i &gt;&gt;= print . f . map digitToInt

test1 = runner "sample.txt" part1
main1 = runner "input.txt" part1

part1 :: [Int] -&gt; Int
part1 ds = ...
</code></pre>
<h1 id="パート1-28"><a class="header" href="#パート1-28">パート1</a></h1>
<p>1ブロックごとに空きをギチギチに詰めるし、とりあかずナイーブな方法で計算する。
ブロックの位置と、ファイル番号(0～)または空き(-1)という情報のペアのリストに展開する。</p>
<pre><code class="language-haskell">-- 位置と内容の対のリストにする
    ijs, ijs0 :: [(Int,Int)]
    ijs = zip [0 ..] $ concat $ zipWith replicate ds $ intersperse (-1) [0 ..]
-- 実際こんなコードをいきなり書けなくて、下の垢抜けないコードで最初は突破した
    ijs0 = zip [0 ..] $ genFile 0 ds
    genFile  fid (d:ds) = replicate d fid  ++ genSpace (succ fid) ds
    genSpace fid (d:ds) = replicate d (-1) ++ genFile fid ds
    genSpace _ [] = []
</code></pre>
<p>このリストを前と後ろからの両方から読み、</p>
<ul>
<li>後ろの空白は読み飛ばす、ファイルは前方の空白に移動させる</li>
<li>前のファイルは出力する、空白は後方のファイルを持ってくる</li>
<li>前と後ろの位置関係が逆転したら処理完了</li>
</ul>
<p>とやれば、移動後の各ファイルの位置が得られる。</p>
<pre><code class="language-haskell">-- 消費する
    consume ijijs@((i,j):ijs) pqpqs@((p,q):pqs)
      | i &gt; p     = []                         -- 前と後ろが交差したら終わり
      | j /= -1   = (i,j) : consume ijs pqpqs  -- 前がファイルなら送り出す
                                               -- 前が空白のとき
      | q /= -1   = (i,q) : consume ijs pqs    -- 後ろにファイルがあれば前の空白に移動させて出力
                                               -- 後ろが空白なら
      | otherwise = consume ijijs pqs          -- 読み飛ばす
</code></pre>
<p>ファイルの位置だけが出てくるので、掛け合わせて足せば答えになる。</p>
<pre><code class="language-haskell">part1 :: [Int] -&gt; Int
part1 ds = sum $ map (uncurry (*)) $ consume ijs $ reverse ijs
  where
    ...
</code></pre>
<p><code>consume</code> の時点で掛け算してしまえば早かったが、SRPということで。</p>
<h1 id="パート2-100"><a class="header" href="#パート2-100">パート2</a></h1>
<p>後ろのファイルが入りきるような、最も手前の空白に移動させる、を、後ろのファイルから順に全てについて行う。
パート1のような持ち方だと、長さを毎回数えることになって無駄すぎる。</p>
<p>その要素の長さと、ファイル番号(0～)または空き(-1)の対のリストを管理し、
また、別でファイルそれぞれの大きさを調べておき、後ろのファイルから順に</p>
<ul>
<li>リストを前から調べ、自分の収まる空きを探し
<ul>
<li>それを見つける前に自分自身と遭遇したときは移動なし、元のリストのままにする</li>
<li>空白が見つかったならば、そこに自分を収め、まだ空きが残るならお釣りの分の空きを新たに作り、
さらに後ろに移動前の自分が出てくるのでそれを空きに変える</li>
</ul>
</li>
</ul>
<p>（ファイルを移動させた際、後ろ側にできた空きの前後に空きがあっても、
これを連結するような正規化処理は不要。処理は後ろのファイルから順に行われ、
自分より後ろに移動することはないから。）</p>
<p>このリストは長さ $N = 2 \times 10^4$ で、リストを $O(N)$ 回舐めるので、 $O(N^2) = 4 \times 10^8$ の計算量になる。
実行時間的にかなりギリギリ寄りだ。
実際これでやると、インタプリタでは待てない。コンパイルして実行すると割とすぐに終わるけれど、
それで終わらせるのはちょっと残念。</p>
<p>動作の様子を少し想像してみると、リストの中にファイル要素が入っている必要は一切なく、</p>
<ul>
<li>空きブロック列の開始位置と大きさ</li>
<li>各ファイルの（番号と）開始位置と大きさ</li>
</ul>
<p>を別に持っておき、ファイルを後者から順に調べて、より前に移動できる空きブロックがあればそこに移動したように修正する、
を繰り返せばよい。そしてファイルの方の情報だけからチェックサムは算出できる。
これで、リストで表現したままでもリスト長が半分になり、その分軽くなる。</p>
<p>さらに、リストを前から舐める計算をなくせないか考えてみる。
移動させようとしているファイルより前にある空きブロックは元からあるもの（か、それが縮んだもの）だけで、
つまり大きさはたかだか1～9の範囲しかない。
そして知りたいことは、今移動させようとしているファイルサイズ以上のものの中で、最も手前にあるものの位置と大きさである。
空きブロックを、その大きさごとに、位置の順にリストにした配列で管理しておき、
移動させるファイルの大きさ以上の項目について、リストの先頭要素の最小値を見るだけでその答えは得られる。</p>
<p>移動を行ったらなら、その空きブロックが消費され、少し後ろにより短い空きブロックが出現することを
このデータ構造に反映させれば、線形探索がなくなる分ずっと軽い計算になるだろう。</p>
<p>ファイル番号 $i$ が位置 $p$ からサイズ $s$ であるとき、その分のチェックサムは
$i \times \left (p + (p+1) + \dots + (p+s-1) \right)$
で、<code>i * sum [p .. p + pred s]</code> としても <code>i * div (s * (p + p + pred s)) 2</code> としてもいい。</p>
<p>結局こんな感じになる。</p>
<pre><code class="language-haskell">test2 = runner "sample.txt" part2
main2 = runner "input.txt" part2

part2 :: [Int] -&gt; Int
part2 ds = sum $ zipWith checksum [0 ..] filesZ
  where
-- 各要素の開始位置は長さの累積和で求められる
    ps = scanl (+) 0 ds
-- 空きブロックをそのサイズごとに分別して位置をリストに集め、昇順にしておく
    spaces0 = fmap sort $ accumArray (flip (:)) [] (0, 9) $
              [sp | (sp, True) &lt;- zip (zip ds ps) $ cycle [False, True]]
-- ファイルのサイズと開始位置のリスト
    files0 = [sp | (sp, True) &lt;- zip (zip ds ps) $ cycle [True, False]]
-- ファイルのリストを後ろから順に再配置
    (_spacesZ, filesZ) = mapAccumR step spaces0 files0
-- サイズsz,位置posのファイルをspacesのどれかの位置に動かすステップ動作
    step spaces f@(sz, pos)
      | null cands = (spaces, f) -- 引っ越し先なし
      | otherwise  = (spaces1, (sz,spos)) -- 移動実行
      where
-- 再配置候補の位置とサイズのリスト
        cands = [(head ps, s) | s &lt;- [sz .. 9], let ps = spaces ! s, not $ null ps, let p = head ps, p &lt; pos]
-- 最も手前にある再配置候補の位置とサイズ
        (spos, ssz) = minimum cands
-- 空き領域データを修正：サイズsszの先頭を削除、サイズ ssz - sz の空きブロックが位置 spos + sz に出現
        spaces1 = accum (flip ($)) spaces [(ssz, tail), (ssz - sz, insert (spos + sz))]
-- ファイル番号、サイズ、位置からチェックサム
--    checksum i (s, p) = i * sum [p .. p + pred s]
    checksum i (s, p) = i * div (s * (p + p + pred s)) 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-23"><a class="header" href="#入力-23">入力</a></h1>
<p>標高の二次元配列を渡せばよいだろう。
数字文字 <code>Char</code> から整数 <code>Int</code> に直す必要すらないだろう。（なぜわかる？）</p>
<pre><code class="language-haskell">import Data.Array

import qualified Data.Set as S

runner i f = do
  ls &lt;- lines &lt;$&gt; readFile i
  let h = length ls
      w = length $ head ls
      arr = listArray ((1,1),(h,w)) $ concat ls
  print $ f arr

test1 = runner "sample.txt" part1
main1 = runner "input.txt" part1

part1 :: Array (Int,Int) Char -&gt; Int
part1 arr = ...
</code></pre>
<h1 id="パート1-29"><a class="header" href="#パート1-29">パート1</a></h1>
<p>命令型言語だと探索アルゴリズムの出番だが、遅延評価配列を使った集めるDPで簡単に求められる。</p>
<ul>
<li>標高9のマスは、自分自身に到達できる</li>
<li>標高 $h$ のマスは、周囲のマスのうち、標高 $h+1$ のマスが到達できる頂上全てに到達できる</li>
</ul>
<p>ここで、標高により、自分自身の内容を判定する相手が静的に定められることが重要で、
これが相互参照するような問題にはこの方法は使えない。</p>
<p>そのようなDPを行う計算を一般化する。</p>
<pre><code class="language-haskell">-- 範囲bndsの位置iのマスに対して、n i で与えられる周囲のマス j について
-- jとDP結果のタプルのリストjdsから f i jds でDP結果を求める
dp :: Ix i =&gt; (i, i) -&gt; (i -&gt; [(i, b)] -&gt; b) -&gt; (i -&gt; [i]) -&gt; Array i b
dp bnds f n = dpArr
  where
    dpArr = listArray bnds [ f i [(j, dpArr ! j) | j &lt;- n i] | i &lt;- range bnds]
</code></pre>
<p>これを使えば全てのマスについて、そこから到達できる <code>9</code> のマスの一覧が得られる。
そして <code>0</code> のマスの集合の要素数の合計が答え。</p>
<pre><code class="language-haskell">part1 :: Array (Int,Int) Char -&gt; Int
part1 arr = sum [S.size s | ('0', s) &lt;- zip (elems arr) (elems score)] -- 標高0のそれの個数の和
  where
    score = dp (bounds arr) gather (upways arr)   -- それぞれのマスから行ける9のマスの位置集合
    gather i jds                                  -- 集める計算
      | arr ! i == '9' = S.singleton i            -- 頂上は自分自身
      | otherwise      = S.unions $ map snd jds   -- 周囲の結果を統合

upways arr p@(i,j) =                                          -- 集める元のマスリスト
  [ q
  | q &lt;- [(pred i, j), (succ i, j), (i, pred j), (i, succ j)] -- 上下左右に隣接して
  , inRange (bounds arr) q                                    -- はみ出していなくて
  , succ (arr ! p) == arr ! q]                                -- 標高が1大きい
</code></pre>
<h1 id="パート2-101"><a class="header" href="#パート2-101">パート2</a></h1>
<p>到達できる <code>9</code> への経路の本数を数えるものに <code>gather</code> を差し替えるだけ。</p>
<pre><code class="language-haskell">test2 = runner "sample.txt" part2
main2 = runner "input.txt" part2

part2 :: Array (Int,Int) Char -&gt; Int
part2 arr = sum [s | ('0', s) &lt;- zip (elems arr) (elems score)] -- 標高0の経路数の和
  where
    score = dp (bounds arr) gather (upways arr) -- それぞれのマスから行ける9のマスへの経路数
    gather i jds                                -- 集める計算
      | arr ! i == '9' = 1                      -- 頂上は経路数1
      | otherwise      = sum $ map snd jds      -- 周囲の経路数の合計
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-24"><a class="header" href="#入力-24">入力</a></h1>
<p>入力が少量な珍しいパターン。
<code>[Int]</code> で表せばよいだろう。</p>
<pre><code class="language-haskell">sample0 :: [Int]
sample0 = map read $ words "0 1 10 99 999"

runner i f = readFile i &gt;&gt;= print . f . map read . words

main1 = runner "input.txt" part1

part1 :: [Int] -&gt; Int
part1 xs = ...
</code></pre>
<h1 id="パート1-30"><a class="header" href="#パート1-30">パート1</a></h1>
<p>一度のまばたきでの石の列の変化を計算する。</p>
<pre><code class="language-haskell">blink :: [Int] -&gt; [Int]
blink = foldr step []
  where
    step 0 = (1 :)
    step x
      | even l = (read as :) . (read bs :)
      | otherwise = (x * 2024 :)
      where
        ds = show x
        l = length ds
        (as,bs) = splitAt (div l 2) ds
</code></pre>
<pre><code>ghci&gt; blink sample0
[1,2024,1,0,9,9,2021976]
ghci&gt; length (iterate blink [125, 17] !! 6)
22
ghci&gt; length (iterate blink [125, 17] !! 25)
55312
</code></pre>
<p>同じことをすればいいので</p>
<pre><code class="language-haskell">part1 :: [Int] -&gt; Int
part1 xs = length $ iterate blink xs !! 25
</code></pre>
<p>できた。</p>
<h1 id="パート2-102"><a class="header" href="#パート2-102">パート2</a></h1>
<p>回数が上がるだけ？</p>
<pre><code class="language-haskell">part2 :: [Int] -&gt; Int
part2 xs = length $ iterate blink xs !! 75

main2 = runner "input.txt" part2
</code></pre>
<p>もちろんそんなに甘くない。</p>
<p>パート1の例で、長さ2の列が25回で55312になった。
ざっくり、1つの石が30000個に増えたと近似する。
75回は25回を3回なので、 $30000 ^ 3 = 27,000,000,000,000$ 個になる。</p>
<p>問題文で「順序が変わらない」と妙に強調しているが、答えとして求められているのは石の個数だけである。
石の変化規則も、前後の石に影響されることなく、自分の状態だけから次が決まる。
なので、「何番の石が何個あるか」という <code>IntMap</code> で列の内容を表現することで、計算を縮小できるはず。</p>
<pre><code class="language-haskell">part2 = sizeMap . (!! 75) . iterate blinkMap . makeMap

makeMap :: [Int] -&gt; IM.IntMap Int
makeMap xs = IM.fromListWith (+) [(x,1) | x &lt;- xs]

blinkMap :: IM.IntMap Int -&gt; IM.IntMap Int
blinkMap xm = IM.fromListWith (+) [(j,v) | (k,v) &lt;- IM.assocs xm, j &lt;- single k]
  where
    single 0 = [1]
    single x
      | even l = [read a, read b]
      | otherwise = [x * 2024]
      where
        ds = show x
        l = length ds
        (a,b) = splitAt (div l 2) ds

sizeMap = sum . IM.elems
</code></pre>
<p>できました。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-25"><a class="header" href="#入力-25">入力</a></h1>
<p>文字の二次元配列に取り込んでおけばよさそうだ。</p>
<pre><code class="language-haskell">import Data.Array

runner i f = do
  ls &lt;- lines &lt;$&gt; readFile i
  let h = length ls
      w = length $ head ls
      garden = listArray ((1,1),(h,w)) $ concat ls
      ans = f garden
  print ans

test1 = runner "sample.txt" part1
main1 = runner "input.txt"  part1

part1 garden = ...
</code></pre>
<h1 id="パート1-31"><a class="header" href="#パート1-31">パート1</a></h1>
<h2 id="領域を特定"><a class="header" href="#領域を特定">領域を特定</a></h2>
<p>領域は文字だけでは判別できない。同じ文字で連続していない位置に現れる可能性もある。
こういうときは Union-Find の出番だ。</p>
<details><summary>Union-Find実装</summary>
<pre><code class="language-haskell">import Data.Array.ST
import Control.Monad.ST
import Control.Monad

-- Union-Find

-- 自分の番号を指しているとき、自分が代表元
type UnionFind s = STUArray s Int Int

-- Union-Find構造体を作る
newUF :: (Int,Int) -&gt; ST s (UnionFind s)
newUF bnds = newListArray bnds $ range bnds

-- 代表元を得る
getRoot :: UnionFind s -&gt; Int -&gt; ST s Int
getRoot uf i = loop i
  where
    loop j = do
      k &lt;- readArray uf j
      if k == j then return j else do
        r &lt;- loop k
        when (r /= k) $ writeArray uf j r
        return r

-- 統合する。
-- 元々同じ分割に属していたらfaを実行する
-- 統合が実際に行われたとき、元の代表元2つをペアにして返す（sndが統合後の代表元）
uniteUF :: UnionFind s -&gt; Int -&gt; Int -&gt; ST s (Maybe (Int,Int))
uniteUF uf i j = do
  a &lt;- getRoot uf i
  b &lt;- getRoot uf j
  if a == b then return Nothing else do
    writeArray uf a b
    return $ Just (a,b)
</code></pre>
</details>
<p>それぞれのマスは、<code>Data.Ix</code> を使って背番号で呼ぶ。
右隣、または左隣と文字が同じとき、結合を行う。
全て結合が終わったら、全てのマスに対してそれが属する分割の代表元（の背番号）を取り出せる配列<code>root</code>に変換しておく。</p>
<pre><code class="language-haskell">part1 garden = ...
  where
    -- 庭の座標系
    bnds@(_,(h,w)) = bounds garden
    -- 背番号の範囲
    ub = h * w - 1
    unites =
      [(index bnds (i,j), index bnds (i, succ j))  -- 右隣と文字が同じとき結合
      | i &lt;- [1 .. h], j &lt;- [1 .. pred w]
      , garden ! (i,j) == garden ! (i, succ j)] ++
      [(index bnds (i,j), index bnds (succ i, j))  -- 下隣と文字が同じとき結合
      | i &lt;- [1 .. pred h], j &lt;- [1 .. w]
      , garden ! (i,j) == garden ! (succ i, j)]
    -- Union-Findを実行し、getRootの結果を集めた配列を作る
    root :: Array (Int,Int) Int
    root = runSTArray $ do
      uf &lt;- newUF (0, ub)
      forM_ unites (uncurry (uniteUF uf))
      rs &lt;- forM [0 .. ub] (getRoot uf)
      newListArray bnds rs
</code></pre>
<h2 id="面積と周長を数える"><a class="header" href="#面積と周長を数える">面積と周長を数える</a></h2>
<p>面積は、それぞれのマスについて、代表元に1を足し込めば集められる。</p>
<pre><code class="language-haskell">    -- 面積
    region :: Array Int Int
    region = accumArray (+) 0 (0, ub) [(r,1) | p &lt;- range bnds, let r = root ! p]
</code></pre>
<p>周長は、それぞれのマスについて、上下左右と見比べて、文字が違うときそれぞれ1を数えたものを、
やはり代表元に集めることで求められる。
<code>garden</code>の範囲の外とも柵を立てる必要があるので、外をみたときはアルファベットでない文字を返すようにする。</p>
<pre><code class="language-haskell">    -- 周長
    getg p
      | inRange bnds p = garden ! p
      | otherwise      = '#'
    peri :: Array Int Int
    peri = accumArray (+) 0 (0, ub)
        [ (r, 1)
        | p@(i,j) &lt;- range bnds, let r = root ! p, let gp = garden ! p
        , q &lt;- [(pred i,j),(succ i,j),(i, pred j),(i, succ j)]
        , gp /= getg q
        ]
</code></pre>
<p>これらの配列は、代表元でないところは0のままである。
面積と周長が得られたら、積和で答えが出る。</p>
<pre><code class="language-haskell">part1 garden = sum $ zipWith (*) (elems region) (elems peri)
  where
    ...
</code></pre>
<p>パート1はこれで完成。</p>
<h1 id="パート2-103"><a class="header" href="#パート2-103">パート2</a></h1>
<p>人間が頭で考えるなら簡単な話なのに、計算機にやらせようとすると、
どうすればいいのかなかなか悩ましい問題。
真っ直ぐ続いているものは同一視させて…と、わからない訳ではないのだが、綺麗な実装が思い浮かばない。</p>
<p>ここで発想を転換すると、柵の「角」の個数がちょうど辺の数と同じであるとわかる。
格ゲーのようにテンキーで考えて、注目しているマスを5と呼ぶと、</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">.</th><th style="text-align: center">.</th><th style="text-align: center">.</th></tr></thead><tbody>
<tr><td style="text-align: center">7</td><td style="text-align: center">8</td><td style="text-align: center">9</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">5</td><td style="text-align: center">6</td></tr>
<tr><td style="text-align: center">1</td><td style="text-align: center">2</td><td style="text-align: center">3</td></tr>
</tbody></table>
</div>
<ul>
<li>2, 4が違う色のとき、左下は凸角</li>
<li>2, 6が違う色のとき、右下は凸角</li>
<li>4, 8が違う色のとき、左上は凸角</li>
<li>6, 8が違う色のとき、右上は凸角</li>
<li>2, 4が同じ色で、1が違う色のとき、左下は凹角</li>
<li>2, 6が同じ色で、3が違う色のとき、右下は凹角</li>
<li>4, 8が同じ色で、7が違う色のとき、左上は凹角</li>
<li>6, 8が同じ色で、9が違う色のとき、右上は凹角</li>
</ul>
<p>これらのどれでもない角は、真っ直ぐに柵が続いているか、そもそも壁がないかのいずれか。</p>
<p>この計算結果を <code>region</code> 同様に足し込むだけ。
それ以外はパート1と変わらない。
なので、共通部をコピペするよりは、せめてスイッチ切り替え式に改造しよう。</p>
<!-- パート2で共通化できる部分が、パート1を正解するまで見られないところがちょっとひっかかるよね。-->
<pre><code class="language-haskell">test1 = runner "sample.txt" (part12 1)
main1 = runner "input.txt"  (part12 1)
test2 = runner "sample.txt" (part12 2)
main2 = runner "input.txt"  (part12 2)

part12 sw garden
  | sw == 1 = sum $ zipWith (*) (elems region) (elems peri)
  | sw == 2 = sum $ zipWith (*) (elems region) (elems edges)
  where
    ....
    -- 角の個数
    countEdge (i,j) = length $ filter id
      [e2 &amp;&amp; e4 &amp;&amp; n1, n2 &amp;&amp; n4  -- 左下、凹、凸
      ,e8 &amp;&amp; e4 &amp;&amp; n7, n8 &amp;&amp; n4  -- 左上、凹、凸
      ,e2 &amp;&amp; e6 &amp;&amp; n3, n2 &amp;&amp; n6  -- 右下、凹、凸
      ,e6 &amp;&amp; e8 &amp;&amp; n9, n6 &amp;&amp; n8  -- 右上、凹、凸
      ]
      where
        gs = [getg (p,q) | p &lt;- [pred i .. succ i], q &lt;- [pred j .. succ j]]
        [_ ,e2,_ ,e4,_,e6,_ ,e8,_ ] = map (gs !! 4 ==) gs
        [n1,n2,n3,n4,_,n6,n7,n8,n9] = map (gs !! 4 /=) gs
    edges :: Array Int Int
    edges = accumArray (+) 0 (0, ub) [(root ! p, countEdge p) | p &lt;- range bnds]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-26"><a class="header" href="#入力-26">入力</a></h1>
<p>不要な文字が多い書式でぎょっとする。
エディタで検索をかけてみて、マイナス文字はないことを確認する。負の値はない。</p>
<p>数字以外の文字は全て空白に置き換えてしまえば、<code>words</code> で数字の並びだけ取り出せる。
間違えて <code>filter isDigit</code> すると全て詰まってしまうので注意。
さらに、ひとつのデータが6個の数字からなるので、<code>Data.List.Split.chunksOf</code> で切り飛ばしておこう。</p>
<p>もう少しマニュアルを調べると、<code>Data.List.Split.wordsBy (not . isDigit)</code> で前半が済むとわかると今知った。</p>
<pre><code class="language-haskell">import Data.Char
import Data.List.Split

runner i f = readFile i &gt;&gt;= print . f . chunksOf 6 . map read . wordsBy (not . isDigit)

test1 = runner "sample.txt" part1
main1 = runner "input.txt"  part1
</code></pre>
<h1 id="パート1-32"><a class="header" href="#パート1-32">パート1</a></h1>
<p>ひとつのデータについて、解があれば返す関数が問題の中核をなす。
<code>Data.Maybe.mapMaybe</code> は、<code>map</code>した結果の<code>Just</code>だけ並べたリストを作る。
<code>catMaybes . map f</code> と書いたら IDE に突っ込まれて今知った。</p>
<pre><code class="language-haskell">import Data.Maybe

part1 = sum . mapMaybe compute1

compute1 :: [Int] -&gt; Maybe Int
compute1 [ax, ay, bx, by, px, py] = ...
</code></pre>
<p>ボタンAを <code>i</code> 回押すとXに <code>i * ax</code> Y に <code>i * ay</code> 動くので、これが <code>px</code>, <code>py</code> を越えない範囲で調べる。
残りの移動をボタンBで行うためには、X方向もY方向も割り切れて、かつ回数が同じになる必要がある。
そのような候補を全て調べ、コストの最小値を選ぶ。
一つもない場合もあるので注意。</p>
<pre><code class="language-haskell">compute1 [xa, ya, xb, yb, px, py]
  | null cands = Nothing
  | otherwise  = Just $ minimum cands
  where
    cands = [ 3 * i + j
            | i &lt;- [0 .. min (div px xa) (div py ya)]
            , let (j, r) = divMod (px - xa * i) xb, r == 0
            , ya * i + yb * j == py
            ]
</code></pre>
<p>ボタンBを押す回数<code>j</code>を、X方向だけで調べ、Y方向には矛盾がないことを確認するだけにした。</p>
<p>パート1はこれで完成。</p>
<h1 id="パート2-104"><a class="header" href="#パート2-104">パート2</a></h1>
<p><code>px</code>, <code>py</code> が大きくなる以外はやることは変わらないので、とりあえずやってみる。</p>
<pre><code class="language-haskell">test2 = runner "sample.txt" part2
main2 = runner "input.txt"  part2

part2 = sum . mapMaybe (compute1 . offset)

offset args = as ++ map (10000000000000 +) bs
  where
    (as,bs) = splitAt 4 args
</code></pre>
<p>…ビクともしない。
最初のサンプルでいうと、<code>i</code> のスキャン上限は <code>div (10000000000000 + 8400) 94 = 106382978812</code>
$\fallingdotseq 10^{11}$ で、今の計算機で総当たりするのはちょっと現実的でない。</p>
<h2 id="数学のお時間"><a class="header" href="#数学のお時間">数学のお時間</a></h2>
<p>つまり、下の連立方程式の解を求めたい。2直線の交点を求めるのと同じ。</p>
<p>$ax \cdot i + bx \cdot j = px$<br />
$ay \cdot i + by \cdot j = py$</p>
<p>$i$ の係数が同じになるように掛けて</p>
<p>$ay \cdot ax \cdot i + ay \cdot bx \cdot j = ay \cdot px$<br />
$ax \cdot ay \cdot i + ax \cdot by \cdot j = ax \cdot py$</p>
<p>辺どうし引いて</p>
<p>$(ay \cdot bx - ax \cdot ay) \cdot j = ay \cdot px -  ax \cdot py$</p>
<p>$ay \cdot bx - ax \cdot ay = \det \neq 0$ を仮定して、<br />
$j = (ay \cdot px -  ax \cdot py) / (ay \cdot bx - ax \cdot ay)$<br />
$i = (px - bx \cdot j)/ax$<br />
結局これが唯一の解なので、割り切れて整数であることと、 $i,j \geq 0$ であることをダメ押しで確認して終わり。</p>
<p>行列式が0になる場合、連立方程式は係数が同じ比になっていて、<br />
$ax / ay = bx / by = r$ となる。
これは2直線が平行であるか、完全に重なっているかのどちらか。<br />
$px / py = r$ なら重なっていて、その上には無数の点がある。
（ただし、格子点を通るとは限らない。）
$px / py \neq r$ なら平行しており、解は全くない。</p>
<p>$px / py = r$ の場合に、格子点を探してその中からコスト最小のものを選択するのは振り出しに戻ったような感じ。</p>
<p>しかしここで、実は $px, py$ は元々せいぜい 20000 程度の値（<code>input.txt</code>を覗いて確認しよう）で、
これに 10000000000000 を足した、どちらもほぼ 10000000000000 に近い値であることを思い出そう。
そのような値どうしで $px / py = r$ となるには、 $px = py, r = 1$ とするしかない。
すると $ax = ay, bx = by$ と単純化されるが、とはいえ途方もない探索範囲がある。
万一そのような場合に遭遇したらエラーを出すように仕込むことにしよう。</p>
<h2 id="プログラミングのお時間"><a class="header" href="#プログラミングのお時間">プログラミングのお時間</a></h2>
<pre><code class="language-haskell">part2 = sum . mapMaybe compute2

compute2 :: [Int] -&gt; Maybe Int
compute2 args@[xa, ya, xb, yb, px0, py0]
  | det == 0, px == py = error $ show args -- 緊急事態、要対応
  | det == 0           = Nothing           -- 解なし
  | isOK               = Just $ 3 * i + j  -- 唯一解
  | otherwise          = Nothing           -- 自然数解でない
  where
    px = px0 + 10000000000000
    py = py0 + 10000000000000
    det = xb * ya - yb * xa
    (j, r) = divMod (ya * px - xa * py) det
    (i, s) = divMod (px - xb * j) xa
    isOK = r == 0 &amp;&amp; s == 0 &amp;&amp; i &gt;= 0 &amp;&amp; j &gt;= 0
</code></pre>
<p>緊急事態は発生することなく答えが出た。そういう入力は混じらないように配慮されていると思われる。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-27"><a class="header" href="#入力-27">入力</a></h1>
<p>今回、数字文字に加えてマイナス記号を残せば、必要な情報が残る。
また、ステージの広さが別パラメータになっているので、外から渡す。</p>
<pre><code class="language-haskell">import Data.Char
import Data.List.Split

runner i f = readFile i &gt;&gt;= print . f. map (map read . wordsBy (not . dm)) . lines

dm '-' = True
dm c = isDigit c

test1 = runner "sample.txt" (part1 11 7)

main1 = runner "input.txt" (part1 101 103)

part1 :: Int -&gt; Int -&gt; [[Int]] -&gt; Int
part1 wide tall robos = ...
  where
</code></pre>
<h1 id="パート1-33"><a class="header" href="#パート1-33">パート1</a></h1>
<p>座標は初めから 0～wide-1, 0～tall-1 の範囲で与えられているので、
剰余をとれば指定の時刻の位置が求められる。
全員の座標を一度に求める計算を括りだしておく。</p>
<pre><code class="language-haskell">roboPos :: Int -&gt; Int -&gt; Int -&gt; [[Int]] -&gt; [(Int, Int)]
roboPos wide tall t nss =
  [ (mod (x + t * vx) wide, mod (y + t * vy) tall)
  | [x,y,vx,vy] &lt;- nss
  ]
</code></pre>
<p>分類によって集計するのは <code>Data.Array.accumArray</code> の出番。
そして象限の値を掛け合わせれば終わり。</p>
<pre><code class="language-haskell">import Data.Array

part1 :: Int -&gt; Int -&gt; [[Int]] -&gt; Int
part1 wide tall nss = product $ map (cnt !) [(LT,LT),(LT,GT),(GT,LT),(GT,GT)]
  where
    cnt = accumArray (+) 0 ((LT,LT),(GT,GT))
          [ ((compare x100 ox, compare y100 oy),1)
          | (x100, y100) &lt;- roboPos wide tall 100 nss]
    ox = div wide 2
    oy = div tall 2
</code></pre>
<h1 id="パート2-105"><a class="header" href="#パート2-105">パート2</a></h1>
<p>全然使用として成り立ってない問題の要求…つら…</p>
<p>ロボットはワープして動き回っているので、全員が同時に出発点に戻る周期があるはず。</p>
<p>幅 $W$ として、ロボットのX座標について、時刻 $k$ で元に戻るとすると<br />
$(x + k \cdot vx) \bmod W = x$<br />
$x + k \cdot vx = x \mod W$<br />
$k \cdot vx = 0 \mod W$<br />
任意の $vx$ についてこれが成り立つ $k$ とはつまり $k = W$<br />
Y座標についても同様なので、つまり周期は高さ $T$ として $\textrm{lcm}(W,T) = 10403$ となる。
画像で出力してひたすら眺めて探す、でも何とか行けそうな数字だが…</p>
<h2 id="統計学"><a class="header" href="#統計学">統計学</a></h2>
<p>標準偏差とは、データの散らばり具合を数値化するものである。
標準偏差は分散の平方根で、分散は平均値からの差の二乗の平均値で定義される。
各時刻でのロボットの散らばり具合を分散で表現して、その小さい順に時刻をいくつかピックアップしてみよう。</p>
<p>特定の時刻の分散を求める関数を立てる。</p>
<pre><code class="language-haskell">distrib wide tall nss t = ...
  where
    xys = roboPos wide tall t nss
</code></pre>
<p>まず平均値が必要。面倒なので整数のままでざっくり近似する。</p>
<pre><code class="language-haskell">    n = length nss
    xave = div (sum $ map fst xys) n
    yave = div (sum $ map snd xys) n
</code></pre>
<p>平均値との差の二乗を求めるのだが、これも距離の二乗で近似する。</p>
<pre><code class="language-haskell">distrib wide tall nss t = dist
  where
    ...
    dist = div (sum [(x - xave)^2 + (y - yave)^2 | (x,y) &lt;- xys]) n
</code></pre>
<p>周期の全ての時刻について分散を求めて、
小さい方から10シーンを取り出す。</p>
<pre><code class="language-haskell">main2D = runner "input.txt" (part2D 101 103)

part2D :: Int -&gt; Int -&gt; [[Int]] -&gt; [(Int,Int)]
part2D wide tall nss = take 10 dts
  where
    dts = sort [(distrib wide tall nss t, t) | t &lt;- [0 .. lcm wide tall]]
</code></pre>
<p>左が分散、右が時刻。抜きんでて先頭の分散が小さくなっているのは、多分そういうことだろう。
その時刻の様子をアスキーアートで取り出そう。</p>
<pre><code class="language-haskell">main2I t = readFile "input.txt" &gt;&gt;= putStrLn . part2I 101 103 t . map (map read . wordsBy (not . dm)) . lines

part2I :: Int -&gt; Int -&gt; Int -&gt; [[Int]] -&gt; String
part2I wide tall t nss =
    intercalate "\n" $ transpose $ chunksOf tall $ elems arr
  where
    arr = accumArray (flip const) '.' ((0,0),(wide-1, tall-1))
          [(xy, '#') | xy &lt;- roboPos wide tall t nss]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>倉庫番は日本発のゲームだから、世界でも "Sokoban" なんだよね。
雑誌に掲載されていた他機種用のBASICプログラム移植して遊んだ在りし日の記憶。</p>
<h1 id="入力-28"><a class="header" href="#入力-28">入力</a></h1>
<p>空行で切り、前半の地図は <code>UArray (Int,Int) Char</code> に、
（Haskellの配列の都合で、座標系はX,Yではなく縦、横の順になる）
後半のコマンドは一列に繋げて渡せばよいだろう。</p>
<p>GPS計算がしやすいように、座標の範囲は1始まりではなく0始まりにしておく。</p>
<p>自分は ST モナドの方が好きだが、今回はフィールドの様子を途中で表示したくなりそうなので、
IO モナドで本体を構成する。</p>
<pre><code class="language-haskell">import Data.Array.Unboxed

runner i f = do
  (ls1,_:ls2) &lt;- break null . lines &lt;$&gt; readFile i
  let h = length ls1
      w = length $ head ls1
      arr = listArray ((0,0),(pred h,pred w)) $ concat ls1
  res &lt;- f arr (concat ls2)
  print res

test0 = runner "samp0.txt" part1
test1 = runner "samp1.txt" part1
main1 = runner "input.txt" part1

part1 :: UArray (Int,Int) Char -&gt; String -&gt; IO Int
part1 arr cmds = ...
</code></pre>
<h1 id="パート1-34"><a class="header" href="#パート1-34">パート1</a></h1>
<p>コマンドの文字から、移動のベクトルを取り出す写像と、座標にそれを足し込む計算は退屈なコード。</p>
<pre><code class="language-haskell">type POS = (Int,Int)

add :: POS -&gt; POS -&gt; POS
add (a,b) (c,d) = (a+c, b+d)

dvec :: Char -&gt; POS
dvec '^' = (-1,0)
dvec 'v' = ( 1,0)
dvec '&gt;' = (0, 1)
dvec '&lt;' = (0,-1)
</code></pre>
<p>フィールドの様子はずっと維持する必要があるので、
実行速度を考えて <code>IOUArray (Int,Int) Char</code> で表すことにする。</p>
<p>先に、フィールドを初期設定したり、フィールドを確認のために画面出力したり、
返すべきスコアを計算するところを書いてしまおう。</p>
<pre><code class="language-haskell">import Control.Monad
import Data.Array.IO
import Data.List
import Data.List.Split

type Field = IOUArray POS Char

part1 :: UArray (Int,Int) Char -&gt; String -&gt; IO Int
part1 arr cmds =
  do
-- ロボの初期位置
    let pos0 = head [pos0 | (pos0, '@') &lt;- assocs arr]
-- フィールドを作る
    fld &lt;- thaw arr :: IO Field
-- 移動の計算
    foldM_ (doMove fld) pos0 cmds
-- フィールドを表示
    showField fld
-- 結果の取り出し
    getResult fld

-- フィールドの表示
showField :: Field -&gt; IO ()
showField fld = do
  (_,(_,w)) &lt;- getBounds fld
  cs &lt;- getElems fld
  putStrLn . intercalate "\n" . chunksOf (succ w) $ cs

-- 結果の取り出し
getResult :: Field -&gt; IO Int
getResult fld = do
  res &lt;- getAssocs fld
  return $ sum [i * 100 + j | ((i,j),'O') &lt;- res]

-- 可能なら移動を実行し、移動後のロボの位置を返す
doMove :: Field -&gt; POS -&gt; Char -&gt; IO POS
doMove fld p0 cmd = ...
</code></pre>
<p><code>doMove</code> でひとつの移動コマンドを実行する。
ロボットの現在位置 $p_0$ と次の移動のベクトルを使って、
ロボットの一歩先 $p_1$ から、0個以上の荷物の連続があって、最後に床で終わってるとき、
その床の座標を $p_2$ として、</p>
<ol>
<li>$p_2$ に荷物を書く</li>
<li>$p_1$ にロボットを書く</li>
<li>$p_0$ に床を書く</li>
</ol>
<p>とすれば、荷物が実は0個でも、問題無く全体が移動できる。
前方を調査している途中で壁に遭遇したときは失敗で、その移動は行わない。</p>
<pre><code class="language-haskell">doMove :: Field -&gt; POS -&gt; Char -&gt; IO POS
doMove fld p0 cmd =
  do
    res &lt;- findEnd p1
    case res of
      Nothing -&gt; return p0
      Just p2 -&gt; do
        writeArray fld p2 'O'
        writeArray fld p1 '@'
        writeArray fld p0 '.'
        return p1
  where
    vec = dvec cmd
    p1 = add p0 vec
    findEnd p = do -- O*. と並んでいる . の位置を探す
      x &lt;- readArray fld p
      case x of
        '.' -&gt; return $ Just p
        'O' -&gt; findEnd (add p vec)
        '#' -&gt; return Nothing
</code></pre>
<h1 id="パート2-106"><a class="header" href="#パート2-106">パート2</a></h1>
<p>やられた。<code>runner</code> の作る配列は役に立たない。
横に長いフィールドの文字配列を作るコードは作り直し。</p>
<pre><code class="language-haskell">runner2 i f = do
  (ls1,_:ls2) &lt;- break null . lines &lt;$&gt; readFile i
  let h = length ls1
      w = length $ head ls1
      arr = listArray ((0,0),(pred h, w + pred w)) $
            concatMap doubler $ concat ls1
  res &lt;- f arr (concat ls2)
  print res

doubler :: Char -&gt; String
doubler '@' = "@."
doubler 'O' = "[]"
doubler  c  = [c,c]

test2 = runner2 "samp1.txt" part2
main2 = runner2 "input.txt" part2

part2 :: UArray POS Char -&gt; String -&gt; IO Int
part2 = ...
</code></pre>
<p><code>part1</code> のコードのうち、フィールドを作る <code>thaw</code> フィールドを表示 <code>showField</code> はそのまま使える。
結果の取り出し <code>getResult</code> は、<code>O</code> でなく <code>[</code> を数えるマイナーな変更だけで使える。</p>
<pre><code class="language-haskell">-- 結果の取り出し
getResult :: Char -&gt; Field -&gt; IO Int
getResult tgt fld = do
  res &lt;- getAssocs fld
  return $ sum [i * 100 + j | ((i,j),c) &lt;- res, c == tgt]
</code></pre>
<p>パターンマッチでのふるい落としができなくなったのでガードを使う。
<code>part1</code> もこれで動くように直しておいて。</p>
<h2 id="左右移動"><a class="header" href="#左右移動">左右移動</a></h2>
<p>移動の計算が大きく変わる。</p>
<p>簡単そうな左右移動から。それでも、<code>O</code> の列の先頭と末尾だけ書き換えて誤魔化すことができないので、
先頭の <code>.</code> を探し、ロボまで全体を1文字ずつちゃんと移動させる必要がある。</p>
<p>移動のための <code>fld</code> への書き込みは、（mutable arrayなので）奥の方から先にしないと、上書きでおかしくなる。
という諸々を考えて、ループの仕事を「先頭の空白を探す」ではなく、移動まで実行させる。</p>
<ul>
<li>先頭の空白まで再帰呼び出しで奥へ進む。</li>
<li>壁に当たったらそれ以上何もせず <code>False</code> を返す。</li>
<li>空白を見つけたなら、<code>True</code> を返す。</li>
<li>再帰呼び出しから返ってきた値が <code>False</code> なら、自分も何もしない。</li>
<li><code>True</code> だったら、自分の位置の内容を次の位置に書き込み、自分の位置には <code>.</code> を書き込む</li>
</ul>
<p>を、ロボットの位置から始めるようにする。
最後の手順は、どうせもう一つ手前の移動で上書きされるので無駄に見えるが、
バカ正直にこうしておく。</p>
<pre><code class="language-haskell">-- 可能なら移動を実行し、移動後のロボの位置を返す
doMove2 :: Field -&gt; POS -&gt; Char -&gt; IO POS
doMove2 fld p0 cmd
  | elem cmd "&lt;&gt;" =  -- 右または左への移動
  do
    b &lt;- loop fld p0
    return $ if b then add p0 vec else p0
  where
    vec = dvec cmd
    loop fld pos = do
      x &lt;- readArray fld pos
      case x of
        '#' -&gt; return False  -- 壁に当たった。失敗。
        '.' -&gt; return True   -- 空き床を見つけた。成功。
        _ -&gt; do -- `[` か `]`
          let pos1 = add pos vec
          b &lt;- loop fld pos1 -- さらに前を調べる
          when b $ do        -- 成功のときは、自分を前に動かす
            readArray fld pos &gt;&gt;= writeArray fld pos1
            writeArray fld pos '.'
          return b
</code></pre>
<h2 id="上下移動"><a class="header" href="#上下移動">上下移動</a></h2>
<p>この問題のハイライト。</p>
<p>横移動では、ある列について前に移動しようとするのは一点だけだった。
縦移動では、押す力のかかっている全ての点が、一斉に次の行に移動しようとする。
それらのうち、誰か一人でも壁に阻まれるとき、移動全体が失敗する。</p>
<p>ということで、横移動の <code>loop</code> では <code>pos</code> の縦座標として押したい位置を一点だけ送っていたものを、
「前に進もうとしている荷物のある横座標の集合」を送る形に拡張すればできる。</p>
<pre><code class="language-haskell">import qualified Data.IntSet as IS

doMove2 fld p0@(i,j) cmd
  | elem cmd "^v" =  -- 上または下への移動
  do
    b &lt;- loop fld i (IS.singleton j)
    return $ if b then add p0 vec else p0
  where
    vec = dvec cmd
    loop fld i jS = do
      xjs &lt;- forM (IS.elems jS) (\j -&gt; do -- jの指す位置の文字を、位置を添えて全て読み出す
        c &lt;- readArray fld (i,j)
        return (c,j))
      let xs = map fst xjs
      case () of -- multiway if
        _ | elem '#' xs     -&gt; return False -- '#' があったらアウト
          | all ('.' ==) xs -&gt; return True -- 全部 '.' なら成功。
          | otherwise       -&gt; do
            let jS1 = IS.fromList $ concatMap udfunc xjs -- 今回動きそうな要素のj座標=次の圧力ポイントを構築
                i1 = i + fst vec
            b &lt;- loop fld i1 jS1 -- さらに前を調べる
            when b $ do          -- 成功のときは、横並び全員を前に動かす
              forM_ (IS.elems jS1) (\j -&gt; do
                readArray fld (i, j) &gt;&gt;= writeArray fld (i1, j)
                writeArray fld (i, j) '.'
                )
            return b

udfunc :: (Char, Int) -&gt; [Int]
udfunc ('@',j) = [j]
udfunc ('[',j) = [j, succ j]
udfunc (']',j) = [pred j, j]
udfunc ('.',_) = []
</code></pre>
<p>部品を組み立てたら完成。</p>
<pre><code class="language-haskell">part2 :: UArray POS Char -&gt; String -&gt; IO Int
part2 arr cmds =
  do
    let pos0 = head [pos0 | (pos0, '@') &lt;- assocs arr]
    fld &lt;- thaw arr :: IO Field
    foldM_ (doMove2 fld) pos0 cmds
    showField fld
    getResult '[' fld
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-29"><a class="header" href="#入力-29">入力</a></h1>
<p>マップを二次元配列にして渡す。</p>
<pre><code class="language-haskell">import Data.Array.Unboxed

runner i f = do
  ls &lt;- lines &lt;$&gt; readFile i
  let h = length ls
      w = length $ head ls
      arr = listArray ((1,1),(h,w)) $ concat ls
  print $ f arr

test0 = runner "samp1.txt" part1
test1 = runner "samp2.txt" part1
main1 = runner "input.txt" part1

part1 :: UArray (Int,Int) Char -&gt; Int
part1 arr = ...
</code></pre>
<h1 id="パート1-35"><a class="header" href="#パート1-35">パート1</a></h1>
<p>ダイクストラ法で距離を求めることで解ける。
1つのマス（タイル）ごとに、トナカイがどっちを向いているか、という情報も乗せて4つの頂点を割りあてる。</p>
<p>同じマスの、左右に回転した状態を表す頂点へ、距離1000の辺を張る。
自分の向きの隣接マスに一歩前進した（向きは変わらないまま）の状態を表す頂点へ、距離1の辺を張る。</p>
<p>マップで <code>#</code> な壁の中のマスからは辺を張らない。
床から壁へは辺を張ってしまうことになるが、出て行くことができない有向グラフなので結果には影響しない。</p>
<p>出発地点は <code>S</code> のあるマスの東向きとする。
ゴール地点 <code>E</code> のマスの、4方向全ての向きそれぞれに対応する頂点の距離を調べ、その最小値が答えである。</p>
<p>まず、手持ちの自作ダイクストラ法のAPIと実装を示す。</p>
<pre><code class="language-haskell">import Control.Monad
import Control.Monad.ST
import Data.Array.ST
import qualified Data.Heap as H

dijkstra :: (Int, Int)           -- 頂点番号の範囲
         -&gt; (Int -&gt; [(Int,Int)]) -- 隣接頂点とその辺の重み、グラフの情報
         -&gt; Int                  -- 開始点
         -&gt; ST s (STUArray s Int Int)
dijkstra bnds edges start =
  do
    dist &lt;- newArray bnds maxBound
    writeArray dist start 0
    loop &lt;- fixST $ \loop -&gt; return $ \queue -&gt;
      if H.null queue then return dist else do
        let Just (H.Entry cost u, queue1) = H.uncons queue
        du &lt;- readArray dist u
        if du &lt; cost then loop queue1 else do
          queue2 &lt;- foldM (\q (v, we) -&gt; do
            let duv = du + we
            dv &lt;- readArray dist v
            if dv &lt;= duv then return q else do
              writeArray dist v duv
              return $ H.insert (H.Entry duv v) q
            ) queue1 (edges u)
          loop queue2
    loop $ H.singleton (H.Entry 0 start)
</code></pre>
<h2 id="第１引数"><a class="header" href="#第１引数">第１引数</a></h2>
<p>頂点は整数で与える。下限と上限は自由に指定できる。
今回は2次元座標×方向の3次元の要素を持つ要素に頂点を割り当てる必要があるので、
<code>Data.Ix</code> を使って一次元に投影する。</p>
<pre><code class="language-haskell">    (ll,hw) = bounds fld   -- フィールドの座標範囲 ((1,1),(h,w)) を取り出す
    bnds = ((ll,0),(hw,3)) -- 4方向を表す整数 0 ～ 3 をもう一次元加えたものが頂点の要素
</code></pre>
<p>これで、<code>index bnds ((i,j),d)</code> とすれば、頂点を表現する整数が得られる。
その整数の下限と上限が <code>dijkstra</code> の第1引数になる。</p>
<pre><code class="language-haskell">    nodesbnds = (index bnds (ll,0), index bnds (hw,3))
</code></pre>
<p>向きの番号にも名前を割り当てておく。関連する関数も作っておく。</p>
<pre><code class="language-haskell">-- 4方向
[dN, dE, dW, dS] = [0 .. 3] :: [Int]

-- 一歩先の座標
walk :: (Int,Int) -&gt; Int -&gt; (Int,Int)
walk (i,j) d =
  case d of
    0 -&gt; (pred i, j)
    1 -&gt; (i, succ j)
    2 -&gt; (i, pred j)
    3 -&gt; (succ i, j)

-- 左右旋回した向きリスト
turn :: Int -&gt; [Int]
turn 0 = [1,2]
turn 1 = [0,3]
turn 2 = [0,3]
turn 3 = [1,2]
</code></pre>
<h2 id="第2引数"><a class="header" href="#第2引数">第2引数</a></h2>
<p>グラフの辺は、配列で与える代わりに、それを与える関数で指定するように一般化している。
ノード番号が引数に与えられるので、接続先のノード番号と辺の重みの対のリストを返す。</p>
<p>ここで、一次元に投影されたノード番号しか得られないので、元の座標と方向の要素に戻す逆写像の配列を作っておく。</p>
<pre><code class="language-haskell">    xedni = listArray nodesbnds $ range bnds :: Array Int ((Int, Int), Int) -- 番号からノードを復元する
</code></pre>
<p>これを補助関数として使うことで、辺を与える関数が定義できる。</p>
<pre><code class="language-haskell">    edge i
      | fld ! ij == '#' = [] -- 壁なら辺は出ない
      | otherwise = (index bnds (walk ij d, d), 1) : [(index bnds (ij,d1), 1000) | d1 &lt;- turn d] -- 前進と旋回
      where
        (ij, d) = xedni ! i
</code></pre>
<h2 id="第3引数"><a class="header" href="#第3引数">第3引数</a></h2>
<p><code>S</code> のある座標を取り出す。</p>
<pre><code class="language-haskell">    start  = head [ij | (ij,'S') &lt;- assocs fld]
</code></pre>
<p>この位置の東向きのノード番号は <code>index bnds (start, dE)</code> である。</p>
<h2 id="戻り値"><a class="header" href="#戻り値">戻り値</a></h2>
<p>結果は <code>ST s (STUArray Int Int)</code> で返されるので、<code>runSTUArray</code> で <code>UArray Int Int</code> に固定しておく。
この配列の、ゴールの位置の4方向の距離の最小値がパート1の答えである。</p>
<pre><code class="language-haskell">    dist :: UArray Int Int
    dist = runSTUArray $ dijkstra nodesbnds edge (index bnds (start, dE))
-- パート1答え
    goal  = head [ij | (ij, 'E') &lt;- assocs fld]
    part1ans = minimum [dist ! index bnds (goal, d) | d &lt;- [0 .. 3]]
</code></pre>
<h1 id="パート2-107"><a class="header" href="#パート2-107">パート2</a></h1>
<p>問題文が少しわかりにくいが、最小スコアを達成する最良の経路は一つだけでなく複数存在するので、
それらを全て見つけて、一度でも最良経路が通過するマスの個数を答えよ、といっている。</p>
<p>今手許にはスタートからの距離 <code>dist</code> と、もちろんそれぞれの辺の重み <code>edge</code> もあるので、
ゴールから始めて、「現在のノードの距離ー隣接ノードの距離＝その辺の重み」という関係を満たすノードは、
そこを通る最良経路のあるノードとわかる。
命令型言語ならこれをbfsなどで発見することになるだろう。</p>
<p>しかしHaskellなら、10日めにやったように、遅延評価配列を使って集めるDPが簡単に実現できる。</p>
<ul>
<li>そのノードが最短経路上にあるとき True を持つことになる配列を用意する。</li>
<li>最短距離になっているゴールのノードは、最短経路の一部である。</li>
<li>それ以外のノードは、自分の周囲のノードのうち、自分よりスタートから遠いノードだけについて、
スタートからの距離の差が辺の長さと一致し、かつそのノードが True を持っているようなノードが一つでもあるなら、
このノードもまた最短経路の一部である。</li>
</ul>
<p>こうしてノードに関して最短経路を選別した後、方向について無視することで、マスの個数を数えることができる。
パート1で求まる、スタートからの距離の表が必要なので、<code>part1</code>にそのまま<code>part2</code>の答えを求めるコードを追加しよう。</p>
<pre><code class="language-haskell">--part1 :: UArray (Int,Int) Char -&gt; Int
--part1 fld = part1ans
part12 :: UArray (Int,Int) Char -&gt; (Int,Int)
part12 fld = (part1ans, part2ans)
  where
    ...
-- パート2
-- 本当にゴールになっている、距離part1ansの頂点を突き止める
    realgoals = [i | d &lt;- [0 .. 3], let i = index bnds (goal, d), dist ! i == part1ans]
-- 遅延配列DPで、最適経路上のノードを洗い出す
    bestpathnodes = listArray nodesbnds $ map bestpathnodesfun $ range nodesbnds :: Array Int Bool
    bestpathnodesfun i
      | elem i realgoals = True
      | otherwise = or [bestpathnodes ! j | (j,w) &lt;- edge i, dist ! i + w == dist ! j]
-- パート2答え
    part2ans = length
      [ ()
      | ij &lt;- range (ll,hw), or [bestpathnodes ! index bnds (ij, d) | d &lt;- [0 .. 3]]]
</code></pre>
<h2 id="追記"><a class="header" href="#追記">追記</a></h2>
<p>10日めのspoilerで関数 <code>dp</code> を定義したので、これを使って書き直してみよう。</p>
<pre><code class="language-haskell">    bestpathnodes = dp dist gather neighbors
    gather i jds
      | elem i realgoals = True
      | otherwise        = any snd jds
    neighbors i = [j | let di = dist ! i, (j, w) &lt;- edge i, di + w == dist ! j]
</code></pre>
<p>できたが、<code>UArray</code> と <code>Array</code> の混在で型エラーになるのを直せなくて、全て <code>Array</code> にして誤魔化した。</p>
<h2 id="追記-1"><a class="header" href="#追記-1">追記</a></h2>
<p><code>dp</code> に配列を引数として渡すのをやめたら <code>UArray</code> 混在でも問題なくなった。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-30"><a class="header" href="#入力-30">入力</a></h1>
<p>例によって、数字文字以外を無視して整数列にし、
先頭3つをレジスタの初期値と解釈するようにして、全体をそのまま渡してしまおう。</p>
<pre><code class="language-haskell">import Data.List.Split
import Data.Char

runner i f = do
  xs &lt;- map read . wordsBy (not . isDigit) &lt;$&gt; readFile i
  print $ f xs

test1 = runner "samp1.txt" part1
main1 = runner "input.txt" part1

part1 :: [Int] -&gt; [Int]
part1 (rA:rB:rC:prog) = ...
</code></pre>
<h1 id="パート1-36"><a class="header" href="#パート1-36">パート1</a></h1>
<p>とにかくこのプロセッサのエミュレータを実装しないと始まらない。</p>
<p>ひとつの命令に関する処理の形を、
命令ポインタを含めたプロセッサの状態を変化させる関数だと考えると</p>
<pre><code class="language-haskell">doInstruction :: State -&gt; State
</code></pre>
<p><code>out</code> 命令の結果の行き先がなくなる。
なので、このような型の関数を命令コードに応じてディスパッチして、
戻ってきたらまた次の命令をディスパッチして、という流れにはしにくい。</p>
<p>ディスパッチする関数は個々の処理を起動して、
個々の処理は完了後に行進した状態を呼び出し元に戻す代わりに、
次の命令に進むためにディスパッチ関数を呼び出す、という末尾呼び出し構造にしよう。</p>
<p>Stateモナドとか使いたくなるが、それをすると出力を Writer モナドに捕まえられて、
lazyに途中結果を覗くみたいなやり方ができなくなるので我慢する。</p>
<p>プログラムは大した長さではないので、配列に入れずに <code>(!!)</code> でアクセスしてしまう。</p>
<pre><code class="language-haskell">data State = State {iP :: Int, regA :: Int, regB :: Int, regC :: Int}

runCPU :: [Int]  -- レジスタ初期値＋プログラム、入力データ
       -&gt; [Int]  -- out出力の系列
runCPU (rA0:rB0:rC0:prog) = exec state0
  where
    ub = pred $ length prog -- アドレス上限
    state0 = State {iP = 0, regA = rA0, regB = rB0, regC = rC0}

    exec :: State -&gt; [Int]
    exec st
      | pc &lt; 0    = error "negative iP"
      | pc == ub  = error "cannot load operand"
      | ub &lt; pc   = [] -- halt
      | otherwise = (instr !! (prog !! pc)) st
      where
        pc = iP st

    instr :: [State -&gt; [Int]]
    instr = [adv, bxl, bst, jnz, bxc, out, bdv, cdv]
</code></pre>
<h2 id="オペランドロード"><a class="header" href="#オペランドロード">オペランドロード</a></h2>
<p>オペランドの読み込みが2とおりある。
どちらも <code>State</code> を引数とする（そして暗黙に <code>prog</code> を読む）関数として定義しておく。</p>
<pre><code class="language-haskell">    literal st = prog !! succ (iP st)

    combo st =
      case literal st of
        4 -&gt; regA st
        5 -&gt; regB st
        6 -&gt; regC st
        7 -&gt; error "invalid combo operand"
        x -&gt; x
</code></pre>
<h2 id="個々の命令の実行"><a class="header" href="#個々の命令の実行">個々の命令の実行</a></h2>
<p>個々の命令は終了後、各自で <code>iP</code> を2増やし、<code>exec</code> を末尾呼び出しする。</p>
<h3 id="adv-bdv-cdv"><a class="header" href="#adv-bdv-cdv">adv, bdv, cdv</a></h3>
<p>これは割り算というより「Aレジスタの内容をコンボオペランドだけ右シフトし、Aレジスタに書き戻す」という動作をする。
後ろ二つも、格納先は違えど、被除数はA。</p>
<pre><code class="language-haskell">import Data.Bits

    adv st = exec $ st {iP = 2 + iP st, regA = shiftR (regA st) (combo st)}
    bdv st = exec $ st {iP = 2 + iP st, regB = shiftR (regA st) (combo st)}
    cdv st = exec $ st {iP = 2 + iP st, regC = shiftR (regA st) (combo st)}
</code></pre>
<h3 id="jnz"><a class="header" href="#jnz">jnz</a></h3>
<p>これのために、各命令が自分で <code>iP+2</code> をするはめになっている。</p>
<pre><code class="language-haskell">    jnz st
      | regA st == 0 = exec $ st {iP = 2 + iP st}
      | otherwise    = exec $ st {iP = literal st}
</code></pre>
<h3 id="out"><a class="header" href="#out">out</a></h3>
<p>出力はHaskellの普通のリスト関数のように行う。</p>
<pre><code class="language-haskell">    out st = 7 .&amp;. combo st : exec (st {iP = 2 + iP st})
</code></pre>
<h3 id="bxl-bst-bxc"><a class="header" href="#bxl-bst-bxc">bxl, bst, bxc</a></h3>
<p>書いてあるとおり。</p>
<pre><code class="language-haskell">    bxl st = exec $ st {iP = 2 + iP st, regB = xor (regB st) (literal st)}
    bst st = exec $ st {iP = 2 + iP st, regB = 7 .&amp;. combo st}
    bxc st = exec $ st {iP = 2 + iP st, regB = xor (regB st) (regC st)}
</code></pre>
<h2 id="完成-1"><a class="header" href="#完成-1">完成</a></h2>
<p><code>runCPU</code> がパート1そのものになってしまった。</p>
<pre><code class="language-haskell">part1 :: [Int] -&gt; [Int]
part1 = runCPU
</code></pre>
<h1 id="パート2-108"><a class="header" href="#パート2-108">パート2</a></h1>
<p>クワイン(Quine)かぁ。</p>
<p>適当にAレジスタの値を差し替えて <code>runCPU</code> を起動し、出てきた結果を元のプログラムと比較する、
というプログラムにおいて、正格言語だと <code>runCPU</code> の終了を待つことになるが、
Haskellは遅延評価するので、最初に違いが生じた時点で破棄できる。
なのでブン回せばヨシ！</p>
<p>ただし、パート1では、バグがあったときにわかるように各所に <code>error</code> を仕掛けたが、
レジスタAの初期値の問題で異常事態に陥ったとき、これがブン回しが途中でコケるのはかなわないので、
少し改造する。</p>
<p>分岐は <code>jnz</code> 命令で起きて、即値オペランドなので、プログラムに変なことが書いてない限り、
変なところに飛ぶ心配はない。なので <code>exec</code> の二つの <code>error</code> は、場合分けごと消して問題ない。</p>
<pre><code class="language-haskell">    exec :: State -&gt; [Int]
    exec st
--      | pc &lt; 0    = error "negative iP"
--      | pc == ub  = error "cannot load operand"
      | ub &lt; pc   = [] -- halt
      | otherwise = (instr !! (prog !! pc)) st
      where
        pc = iP st
</code></pre>
<p>コンボオペランドのアドレッシングモード7も、パート1で遭遇しなかったから発生することはなく、
そのまま放置で構わない。
パラノイアな人は、コンボオペランドを使う命令の実行前に、オペランドをのぞき見し、
それが7なときは 0～7 でない値を出力して完了するコードを仕込んでもいい。</p>
<p>ブン回す準備ができた。
状況を見守るため、時々実行状況を表示するように仕掛けよう。</p>
<pre><code class="language-haskell">import Debug.Trace

test2 = runner "samp2.txt" part2
main2 = runner "input.txt" part2

part2 :: [Int] -&gt; Int
part2 (_:xs) = head
  [ a
  | a &lt;- [0 ..], mod a 10000 /= 0 || traceShow a True
  , runCPU (a : xs) == drop 2 xs]
</code></pre>
<pre><code>ghci&gt; test2
0
10000
20000
30000
40000
50000
60000
70000
80000
90000
100000
110000
117440
</code></pre>
<p>ではこれで本番の方も、時間かかりそうなのでコンパイルして実行すれば何とか…</p>
<p>…なるわけない。<br />
これは辛い戦いになりそうだ。</p>
<h2 id="パート2のサンプルを読む"><a class="header" href="#パート2のサンプルを読む">パート2のサンプルを読む。</a></h2>
<pre><code>0 : 0,3 ; A ← A &gt;&gt; 3
1 : 5,4 ; out A
2 : 3,0 ; jnz 0
</code></pre>
<p>つまり、Aの下位3ビットを順に出力していき、最後に0を出力したらそこで完了する。
このプログラムに 0,3,5,4,3,0 という出力系列を出させるための A の初期値は
最初の3ビットシフトで使われずに捨てられる値も含めて</p>
<pre><code class="language-haskell">ghci&gt; foldr (\x acc -&gt; acc * 8 + x) 0 [0,0,3,5,4,3,0]
117440
</code></pre>
<p>と求められる。</p>
<h2 id="自分のパズル入力を分析する"><a class="header" href="#自分のパズル入力を分析する">自分のパズル入力を分析する</a></h2>
<p>詳細は省くが、ハンド逆アセンブルして読み解くと、</p>
<ul>
<li>Aレジスタの値が3ビットずつ消費されていき、最後に0になったら終わる、サンプルと同じ構造</li>
<li>毎回のループの中で、出力データを生成するためにB,Cレジスタは初期化されてから使われ、ループ間で引き継ぎはない</li>
</ul>
<p>ということがわかる。このプログラムがループを回りながら実行が進む様子を逆再生したところをイメージすると、</p>
<ul>
<li>最後の出力のとき、Aレジスタは下位3ビットより他は0になっているはずなので、それだけから最後の出力は決まる
このときのAの値を $A_0$ とする。これは8回試せば見つかる。</li>
<li>その一つ前の出力を計算した後、Aレジスタは $A_0$ になる。
その前は $0 \leq Y_0 \leq 7$ な何らかの値で $A_1 = A_0 * 8 + Y_0$ と表される6ビットの値であったはずで、
$Y_0$ がラスト前の値を決定する。これは $8 \times 8 = 64$ とおりを試す必要はなく、
$A_0$ が既知ならば8通り試すだけで見つかる。</li>
<li>その一つ前の出力を計算した後、…</li>
</ul>
<p>と、順に推理していけると気がつく。つまりこのプログラムの性質として、</p>
<p>「Aレジスタの初期値 $X$ が、実行によりある系列 $O$ を出力するならば、
$X \times 8 + Y$ $(0 \leq Y \leq 7)$ は、一つ値を出力して、その後 $O$ を出力する。」</p>
<p>が成り立っていると推理できる。</p>
<p>ということでこれを（手で実行するのでなく）プログラムにやらせよう。</p>
<h2 id="解析プログラム"><a class="header" href="#解析プログラム">解析プログラム</a></h2>
<p>プログラムの <code>tails</code> を短い方から順に調べる。
長さ 0 の正しい出力をするための A の仮想的な初期値 0 から始めて、
プログラムの末尾をもう一つ手前から出力するような A の初期値は、
前の初期値×8+(0～7) のいずれかである。</p>
<pre><code class="language-haskell">import Data.List

part2 :: [Int] -&gt; [Int]
part2 (_:xs) = ans
  where
    prog = drop 2 xs
    ans = foldr step [0] $ init $ tails prog
    step progtail cands = -- traceShowId を差し込むと様子を見られる
      [ a
      | c &lt;- cands, d &lt;- [0 .. 7], let a = c * 8 + d
      , runCPU (a:xs) == progtail]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-31"><a class="header" href="#入力-31">入力</a></h1>
<p>読み込みデータは整数のタプルのリストにする。
それとは別にグリッドの広さも与える必要がある。
さらにパート1では、データを先頭から12要素または1024要素に限定する必要もある。</p>
<pre><code class="language-haskell">runner i f = do
  xys &lt;- map parse . lines &lt;$&gt; readFile i
  print $ f xys

parse :: String -&gt; (Int, Int)
parse l = (read as, read bs)
  where
    (as, _:bs) = break (',' ==) l

test1 = runner "samp1.txt" $ part1 6 . take 12
main1 = runner "input.txt" $ part1 70 . take 1024

part1 :: Int -&gt; [(Int,Int)] -&gt; Int
part1 ub xys = ...
</code></pre>
<h1 id="パート1-37"><a class="header" href="#パート1-37">パート1</a></h1>
<p>落ちてきたバイトを二次元配列に書き込んでマップを作り、
これの <code>(0,0)</code> から出発して <code>(ub,ub)</code> に到達する距離を、
1マスずつ歩いて幅優先探索で歩いて調べる計算を書くだけで特に面白みはない。</p>
<p>なさすぎて面倒なので、辺の長さ1に固定してダイクストラ法を呼び出して終わりにする。
無向辺で「隣接マスが <code>#</code> のときは辺を張らない」とする代わりに、
有向辺で「現在のマスが '#' のときは辺を張らない」とする方が楽なので無精する。</p>
<pre><code class="language-haskell">import Data.Array
import Control.Monad
import Control.Monad.ST
import Data.Array.ST

part1 ub xys = dist
  where
    bnds = ((0,0),(ub,ub))
    fld = accumArray (&amp;&amp;) True bnds [(xy, False) | xy &lt;- xys]
    l = index bnds $ fst bnds
    u = index bnds $ snd bnds

    dist = runST $ do
      arr &lt;- dijkstra (l,u) edge (index bnds (0,0))
      readArray arr $ index bnds (ub,ub)

    i2xy = listArray (l,u) $ range bnds
    edge i
      | fld ! (x,y) = [(index bnds p, 1) | p &lt;- [(pred x,y),(succ x,y),(x,pred y),(x,succ y)], inRange bnds p]
      | otherwise   = []
      where
        (x,y) = i2xy ! i
</code></pre>
<p>ダイクストラ法は16日目に使ったものと同じなので略。</p>
<h1 id="パート2-109"><a class="header" href="#パート2-109">パート2</a></h1>
<p><code>input.txt</code> は3450行、1025行から始めて、1行ずつ追加してパート1をやりなおして、
ダメになった（距離が <code>maxBound :: Int</code> になった）ときの末尾行が答え、ではもちろんとても遅い。</p>
<p>1024行なら確実に通行でき、一度道が塞がれたら二度と復活することはないので、つまり二分探索を使えということ。</p>
<p>手持ちの、整数範囲を探索する二分探索のコードはこれ。</p>
<pre><code class="language-haskell">binarySearch :: (Int -&gt; Bool) -&gt; Int -&gt; Int -&gt; (Int, Int)
binarySearch prop unsat sat = loop unsat sat
  where
    loop a b
      | ende   = (a, b)
      | prop m = loop a m
      | True   = loop m b
      where
        ende = a == m || b == m
        m = div (a + b) 2
</code></pre>
<p><code>prop</code> は探したい整数を引数にとる述語で、<code>sat</code> はこれが確かに真になる値、<code>unsat</code> はこれが偽になる値。
その間で <code>prop</code> を偽にするぎりぎりの値 <code>a</code> と真にするぎりぎりの値 <code>b</code> （つまり両者の差は1）を求める。</p>
<p><code>sat</code> は12とか1024とか切り替えるのも面倒なので 0 で。
<code>unsat</code> は入力全体の長さにしておけばよいだろう。</p>
<p>述語 <code>prop k</code> は、長さ <code>k</code> に入力を切り飛ばして <code>part1</code> を実行したとき、
結果が <code>maxBound</code> になっていないこと、とする。</p>
<p>こうしたとき、リストの <code>b</code> 個目の要素が知りたいブロックである。</p>
<pre><code class="language-haskell">test2 = runner "samp1.txt" $ part2 6
main2 = runner "input.txt" $ part2 70

part2 ub xys = xys !! pred out
  where
    prop k = part1 ub (take k xys) &lt; maxBound
    (out, safe) = binarySearch prop (length xys) 0
</code></pre>
<h2 id="コンピュータの進化"><a class="header" href="#コンピュータの進化">コンピュータの進化</a></h2>
<p>昨日の17日目の問題だと探索範囲が広すぎて無茶だったけど、今日の3450とおりという桁数だと、
Ryzen Threadripper PRO 96コア192スレッドで手分けして探索したら、
パート1の計算時間の18倍程度で答えが出てしまう計算になる。</p>
<p>そんな時代に備えて、ヘイヘイHaskellを読み直す必要があるのかも。
ていうか、既にそういう解き方をしている人も居そうだな。</p>
<h2 id="追記-2"><a class="header" href="#追記-2">追記</a></h2>
<p>そもそも、コンパイルして実行すれば、パート1を順に実行する力業でも大して待たずに答えが出ていた。</p>
<pre><code class="language-haskell">import Data.Maybe

part2a ub xys = head $ dropWhile (isNothing . snd) list
  where
    prop k = part1 ub (take k xys) &lt; maxBound
    list = [(k, if prop k then Nothing else Just (xys !! pred k)) | k &lt;- [1 .. length xys]]
</code></pre>
<p>これにさらに、<code>Control.Parallel.Strategies</code> による並列計算を仕込んで試してみる。</p>
<pre><code class="language-haskell">import Control.Parallel.Strategies
import System.CPUTime

part2a ub xys = head $ dropWhile (isNothing . snd) list
  where
    prop k = part1 ub (take k xys) &lt; maxBound
    list = runEval $ parList rpar -- ココ
           [(k, if prop k then Nothing else Just (xys !! pred k)) | k &lt;- [1 .. length xys]]

main = do
  t0 &lt;- getCPUTime
  runner "input.txt" $ part2a 70
  t1 &lt;- getCPUTime
  print $ t1 - t0
</code></pre>
<p>コンパイルと実行におまじないが必要。</p>
<pre><code>&gt; ghc -O2 ver3 -threaded -rtsopts
&gt; ./ver3 +RTS -N1
(2906,Just (34,40))
2890625000000
&gt; ./ver3 +RTS -N4
(2906,Just (34,40))
546875000000
&gt; ./ver3 +RTS -N8
(2906,Just (34,40))
328125000000
</code></pre>
<p>コンパイル時に <code>-threaded</code> でマルチスレッドが使えるようになり、<code>-rtsopts</code> で <code>-N</code> オプションを渡せるようになる。
実行時に <code>+RTS</code> に続けて <code>-Nx</code> で与えた数だけコアを同時に使うようになる。
<code>-N1</code> はコア一つで実行する、いつもの状態。
このコンピュータは4コア8スレッドのi7なので、4と8を試してみた。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">コア指定</th><th style="text-align: right">実行時間(sec)</th></tr></thead><tbody>
<tr><td style="text-align: center">1</td><td style="text-align: right">2.89</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: right">0.55</td></tr>
<tr><td style="text-align: center">8</td><td style="text-align: right">0.33</td></tr>
</tbody></table>
</div>
<p>ある程度計算量があり、独立性が高い部分問題が並んでいる状態だと、こんなに簡単に並列性を享受できるんだ。
（ヘイヘイHaskellでも数独ソルバの例が出ていたけれど、似たようなシチュエーションだ。）</p>
<p>なお、実行ファイルを起動してから、ランタイムが色々準備して実行が開始されるまでに結構時間がかかるので、
exeを起動してから0.3秒で答えが出てくる訳ではないことに注意。
もっと大きな問題にならないと体感できる程の差にはならない。</p>
<!--
コンパイルなしでGHCiからもこれが使えたらもっと楽しいのになぁ。
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-32"><a class="header" href="#入力-32">入力</a></h1>
<p>1行め、タオルの列は個々に分解して <code>[String]</code> に、
3行め以降、デザインの列はそのままで <code>[String]</code> にしたらいい。</p>
<pre><code class="language-haskell">runner i f = do
  l:_:ds &lt;- lines &lt;$&gt; readFile i
  let ts = words $ filter (',' /=) l
  print $ f ts ds

test1 = runner "sample.txt" part1
main1 = runner "input.txt" part1

part1 :: [String] -&gt; [String] -&gt; Int
part1 ts ds = ...
</code></pre>
<p>最初、1行めの列を <code>words</code> だけで分解しようとして、コンマが残ってしばらく気づかなかったのは内緒。</p>
<h1 id="パート1-38"><a class="header" href="#パート1-38">パート1</a></h1>
<p>それぞれのデザインについて、可能な方法を一つでいいから見つけようとする述語を通ったものを数えればいい。</p>
<pre><code class="language-haskell">part1 ts ds = length $ filter (avail ts) ds

avail ts pat = loop pat
  where
    tls = [(t, length t) | t &lt;- ts]
    loop "" = True
    loop xs = or [loop $ drop l xs | (t,l) &lt;- tls, isPrefixOf t xs]
</code></pre>
<p>サンプルならこんなコードでも通るけど、本番はちょっとつらい。</p>
<p>上のコードの <code>loop</code> がやっている再帰計算を、<a href="https://qiita.com/gotoki_no_joe/items/713af82bfd0a94e8a335">アドベントカレンダー</a>の方にも書いた <code>memoize</code> でメモ化してみる。</p>
<pre><code class="language-haskell">    avail pat = memoize f pat
    f mf "" = ([], True)
    f mf xs = (bs, any mf bs)
      where
        bs = [b | (t,l) &lt;- tls, let (a,b) = splitAt l xs, a == t]
</code></pre>
<p>できた。</p>
<h1 id="パート2-110"><a class="header" href="#パート2-110">パート2</a></h1>
<p>可能か否かの <code>Bool</code> の代わりに、場合の数を <code>Int</code> で持つように変えるだけなのでは？</p>
<pre><code class="language-haskell">test2 = runner "sample.txt" part2
main2 = runner "input.txt" part2

part2 :: [String] -&gt; [String] -&gt; Int
part2 ts ds = sum $ map countWays ds
  where
    tls = [(t, length t) | t &lt;- ts]
    countWays pat = memoize f pat
    f mf "" = ([], 1)
    f mf xs = (bs, sum $ map mf bs)
      where
        bs = [b | (t,l) &lt;- tls, let (a,b) = splitAt l xs, a == t]
</code></pre>
<p>本当にこれだけで終わってしまった。</p>
<h1 id="配列dp"><a class="header" href="#配列dp">配列DP</a></h1>
<p>実際にはこの問題は、上のように文字列でしなくも、
「パターンの後ろ何文字が残った状態にできる」という小さな連続範囲の整数でのDPだけでできる。</p>
<pre><code class="language-haskell">-- array bnds nf は、添え字範囲bndsの集めるDPを行う
-- nf i は (js, fi) を返す
-- js は添え字 i の値を求めるためにDP値を集める先のリスト
-- fi は js の要素について集めてきたDP値の対のリストから、iの値を求める関数
-- 結果は、bns範囲の配列で、DPの答えが入っている
arrayDP :: Ix i =&gt; (i, i) -&gt; (i -&gt; ([i], [(i, b)] -&gt; b)) -&gt; Array i b
arrayDP bnds nf = dpArr
  where
    dpArr = listArray bnds [fi [(j, dpArr ! j) | j &lt;- js] | i &lt;- range bnds, let (js, fi) = nf i]

part12a :: [String] -&gt; [String] -&gt; (Int, Int)
part12a ts ds = (length $ filter avail ds, sum $ map countWays ds)
  where
    tls = [(t, length t) | t &lt;- ts]
-- part1
    avail pat = arrayDP (0, len) nf ! 0
      where
        len = length pat
-- デザインの先頭 k 文字を落としたものが作れる
        nf k
          | k == len = ([], const True)
          | otherwise = (ls, or . map snd)
          where
            ls = [k + l | (t,l) &lt;- tls, isPrefixOf t $ drop k pat]
-- part2
    countWays pat = arrayDP (0, len) nf ! 0
      where
        len = length pat
-- デザインの先頭 k 文字を落としたものを作る方法の場合の数
        nf k
          | k == len = ([], const 1)
          | otherwise = (ls, sum . map snd)
          where
            ls = [k + l | (t,l) &lt;- tls, isPrefixOf t $ drop k pat]
</code></pre>
<p>もちろんこっちのが速い。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-33"><a class="header" href="#入力-33">入力</a></h1>
<p>地図を二次元配列として渡す。</p>
<pre><code class="language-haskell">import Data.Array.Unboxed

runner i f = do
  ls &lt;- lines &lt;$&gt; readFile i
  let h = length ls
      w = length $ head ls
      fld = listArray ((1,1),(h,w)) $ concat ls :: UArray POS Char
  print $ f fld

test1 = runner "sample.txt" part1
main1 = runner "input.txt" part1

type POS = (Int,Int)

part1 fld = ...
</code></pre>
<h1 id="パート1-39"><a class="header" href="#パート1-39">パート1</a></h1>
<p>まずは迷路の基本的な分析をする。</p>
<pre><code class="language-haskell">part1 fld = ...
  where
    bnds@(_,(h,w)) = bounds fld
    bfld = amap ('#' /=) fld        -- 移動可能なマスか
-- Sの位置
    sPos = head [pos | (pos, 'S') &lt;- assocs fld]
</code></pre>
<p>4近傍の迷路を探索し、始点からの距離（到達できないときは <code>maxBound</code>）を埋めた配列を作る、距離を測る計算は幅優先探索で実装できるが、キューでなくピンポンを使うのが好き。
AoCではこれも多用している気がするので一度清書する。</p>
<pre><code class="language-haskell">-- 4近傍迷路の距離計測
-- bnds : マスの範囲
-- max : 範囲内の位置に関して、通過できるマスか判定
-- start : 出発点
-- 出力 : 出発点からの距離、到達不能は maxBound
mazeDistance :: ((Int,Int),(Int,Int)) -&gt; ((Int,Int) -&gt; Bool) -&gt; (Int,Int) -&gt; ST s (STUArray s (Int,Int) Int)
mazeDistance bnds maze start =
  do
    dist &lt;- newArray bnds maxBound
    writeArray dist start 0
    loop &lt;- fixST $ \loop -&gt; return $ \cnt ents new -&gt; do
      case ents of
        [] | null new  -&gt; return ()
           | otherwise -&gt; loop (succ cnt) new []
        ((x,y):rest) -&gt; do
          new1 &lt;- foldM (\new q -&gt; do
            e &lt;- readArray dist q
            if e &lt; maxBound then return new else do
              writeArray dist q cnt
              return (q : new)
            ) new [q | q &lt;- [(pred x, y), (succ x, y), (x, pred y), (x, succ y)], inRange bnds q, maze q]
          loop cnt rest new1
    loop 1 [start] []
    return dist
</code></pre>
<p>これを使って、スタートからの各マスの距離 <code>dist</code> を数える。</p>
<pre><code class="language-haskell">-- Sから各マスまでの距離
    dist = runSTUArray $ mazeDistance bnds (bfld !) sPos
-- チートしないときの距離（確認用）
    s2e = sDist ! ePos
    ePos = head [pos | (pos, 'E') &lt;- assocs fld]
</code></pre>
<p>動作確認として <code>s2e</code> を見てみよう。</p>
<pre><code>ghci&gt; test1
84
</code></pre>
<p>よさそうだ。</p>
<p>チートをするとは、</p>
<ul>
<li>全てのコース上のマス <code>p</code> について</li>
<li>そこからマンハッタン距離2のコース上のマス <code>q</code> について</li>
<li><code>p</code> から <code>q</code> へ普通に走ったときのラップタイムは <code>dist ! q - dist ! p</code></li>
<li>チートを使ったときのタイムは <code>2</code></li>
<li>この差が <code>gain</code></li>
</ul>
<p>そこで、<code>gain &gt; 0</code> の値ごとに個数を数えてみる。</p>
<pre><code class="language-haskell">    part1cnt = IM.fromListWith (+)
        [ (gain, 1)
        | (p@(x,y), True) &lt;- assocs bfld
        , q &lt;- [(x-2,y),(x-1,y-1),(x,y-2),(x+1,y-1),(x+2,y),(x+1,y+1),(x,y+2),(x-1,y+1)]
        , inRange bnds q, bfld ! q
        , let gain = dist ! q - dist ! p - 2
        , gain &gt; 0]
</code></pre>
<p>見てみる。</p>
<pre><code>ghci&gt; test1
fromList [(2,14),(4,14),(6,2),(8,4),(10,2),(12,3),(20,1),(36,1),(38,1),(40,1),(64,1)]
</code></pre>
<p>よさそう。<br />
<code>gain</code> ごとに集計する代わりに、100以上のものの個数を数えたらパート1は完成。</p>
<pre><code class="language-haskell">    ans1 = length
        [ ()
        | (p@(x,y), True) &lt;- assocs bfld
        , q &lt;- [(x-2,y),(x-1,y-1),(x,y-2),(x+1,y-1),(x+2,y),(x+1,y+1),(x,y+2),(x-1,y+1)]
        , inRange bnds q, bfld ! q
        , let gain = dist ! q - dist ! p - 2
        , gain &gt;= 100]
</code></pre>
<h1 id="パート2-111"><a class="header" href="#パート2-111">パート2</a></h1>
<p>パート1では手書きでマンハッタン距離2の位置を列挙したが、ここを、マンハッタン距離20以内の全てを列挙するものに差し替える。</p>
<p>ここのために <code>h</code>,<code>w</code> が必要だった。</p>
<pre><code class="language-haskell">-- (x,y)からマンハッタン距離d以内で範囲内の座標を生成
    diamond d (x,y) =
        [ (p,q)
        | p &lt;- [max 1 $ x - d .. min h $ x + d], let e = d - abs (x - p)
        , q &lt;- [max 1 $ y - e .. min w $ y + e] ]
</code></pre>
<p>集計して検算する。</p>
<pre><code class="language-haskell">    part2cnt = IM.fromListWith (+)
        [ (gain, 1)
        | (p, True) &lt;- assocs bfld
        , q &lt;- diamond 20 p, bfld ! q
        , let gain = dist ! q - dist ! p - mhd p q
        , gain &gt;= 50]
</code></pre>
<pre><code>ghci&gt; test1
fromList [(50,32),(52,31),(54,29),(56,39),(58,25),(60,23),(62,20),(64,19),(66,12),(68,14),(70,12),(72,22),(74,4),(76,3)]
</code></pre>
<p>よければ解答を計算する。</p>
<pre><code class="language-haskell">    ans2 = length
        [ ()
        | (p, True) &lt;- assocs bfld
        , q &lt;- diamond 20 p, bfld ! q
        , let gain = dist ! q - dist ! p - mhd p q
        , gain &gt;=100]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ざんげ"><a class="header" href="#ざんげ">ざんげ</a></h1>
<p>このまま未解決で放置するのもひっかかるので、MS copilot さんにヒントを聞いたら
<a href="https://todd.ginsberg.com/post/advent-of-code/2024/day21/">Todd Ginsbergさんのblog</a>を紹介されて、
読んだら解けたので、独力ではなく受け売りです。</p>
<h1 id="入力-34"><a class="header" href="#入力-34">入力</a></h1>
<p>めちゃ短い文字列なのでソースに埋め込んでしまってもいいくらいだし、なんにせよ文字列のリストにするだけ。</p>
<pre><code class="language-haskell">runner i f = do
  ls &lt;- lines &lt;$&gt; readFile i
  print $ f ls

test1 = runner "sample.txt" part1
main1 = runner "input.txt" part1

part1 ls = ...
</code></pre>
<p>ここに戻ってくるのはかなり後になる。</p>
<h1 id="ボトムアップで"><a class="header" href="#ボトムアップで">ボトムアップで</a></h1>
<p>受け売り元にならい、ボトムアップに構築していくが、どうしてそういう設計になるのか、という面については、
全体の方針からトップダウンに決まることで、そこが繋がるまでモヤモヤする話の流れであることを覚悟してほしい。</p>
<p>まず、テンキーパッドと方向キーパッドを、どの座標位置にどんなボタンがあるのかという写像で表現する。</p>
<pre><code class="language-haskell">import qualified Data.Map as M
import Data.List.Split

type Pad = M.Map (Int,Int) Char

numericPad, directionalPad :: Pad
numericPad = makeKeypad "789456123*0A"
directionalPad = makeKeypad "*^A&lt;v&gt;"

makeKeypad :: String -&gt; Pad
makeKeypad str = M.fromList
  [ ((i,j),c)
  | (i, cs) &lt;- zip [0 ..] $ chunksOf 3 str
  , (j, c ) &lt;- zip [0 ..] cs, c /= '*' ]
</code></pre>
<p>キーパッドを操作するロボを操作する操作系列を求めるとき、
押したいボタンXがどれかだけではなく、現在アームが指しているボタンがどれなのか、が結果に影響する。</p>
<p>そこで、キーパッドの任意の位置から任意の位置へ、ボタンの上だけを辿って到達するための最短の操作系列を、
出発の文字から目的の文字の対に対して割り当てる。最短の操作系列は複数あるので全て持っておく。</p>
<p>まずユーティリティ関数の <code>shortests</code> は、リストのリストから、最短のものを<strong>全て</strong>抽出する。
全て欲しいので <code>minimumBy</code> ではできない。
ただし、候補がなく空リストのときは空リストを返す。</p>
<pre><code class="language-haskell">shortests [] = []
shortests xs = [x | (l,x) &lt;- zip ls xs, l == lmin]
  where
    ls = map length xs
    lmin = minimum ls
</code></pre>
<p><code>closer s e</code> は、
座標 s から座標 e までの無駄のない経路で、e の一歩手前 n と、
n から e に移動するためにカーソルキーで押すボタン文字との対を、
縦移動と横移動の両方について求める。</p>
<pre><code class="language-haskell">closer :: (Int,Int) -&gt; (Int,Int) -&gt; [((Int,Int),Char)]
closer (i,j) (p,q) =
  [((pred p, q), 'v') | i &lt; p] ++ [((succ p, q), '^') | p &lt; i] ++
  [((p, pred q), '&gt;') | j &lt; q] ++ [((p, succ q), '&lt;') | q &lt; j]
</code></pre>
<p>作りたいものは、二つのキーパッドについて、その始点文字から終点文字の全ての対について、
最短操作系列を持つようなマップ。</p>
<pre><code class="language-haskell">type Paths = M.Map (Char,Char) [String]

numericPaths, directionalPaths :: Paths
numericPaths     = allPaths numericPad
directionalPaths = allPaths directionalPad

allPaths :: Pad -&gt; Paths
allPaths pad = ...
  where
    ....
</code></pre>
<p>一旦、<code>Pad</code> のキー、すなわち座標 <code>(Int,Int)</code> の形の始点から終点に対する最短系列のマップ <code>m</code> を作る。
リスト操作の都合上、順序も反転した形で蓄積する。
遅延<code>Map</code>によるDPで、Kotlin版のようなBFSの手続きを書くことなく達成。</p>
<pre><code class="language-haskell">    m = M.fromDistinctAscList
      [((s,e), findLowestCostPaths s e) -- 最短操作系列を（逆順で）求める
      | s &lt;- M.keys pad                 -- sとeのキーの座標に関して全ての組み合わせで
      , e &lt;- M.keys pad ]
    findLowestCostPaths s e             -- 出発点s終点e
      | s == e = [""]                   -- s = e なら操作はε
      | otherwise = shortests           -- 最短のもの全て
        [ d : p                         -- nからeへの1操作を追加したもの
        | (n,d) &lt;- closer s e           -- eよりsに一歩近い隣nの
        , M.member n pad                -- ただしnは実在するもの限定で
        , p &lt;- m M.! (s,n)]             -- sからnへの最短系列に
</code></pre>
<p><code>m</code>ができたら、座標からその位置のボタン文字は<code>pad</code>から取り出せる。
操作系列も全て<code>reverse</code>し、末尾に<code>A</code>を追加して完成。</p>
<pre><code class="language-haskell">allPaths pad =
    M.mapKeys (\(ij, pq) -&gt; (pad M.! ij, pad M.! pq)) $
    M.map (map (reverse . ('A' :))) m
</code></pre>
<p>確認しておこう。</p>
<pre><code>ghci&gt; numericPaths
fromList [(('0','0'),["A"]),(('0','1'),["^&lt;A"]),(('0','2'),["^A"]),(('0','3'),["&gt;^A","^&gt;A"]),...
</code></pre>
<h1 id="パート1-40"><a class="header" href="#パート1-40">パート1</a></h1>
<p>ドアの前のロボにコードを入力させるには、アームの初期位置は <code>A</code> なので、
例えば <code>029A</code> なら <code>('A','0'), ('0','2'),('2','9'),('9','A')</code> の
<code>numericPaths</code> のそれぞれいずれかを連結したものを与えればよい。</p>
<p>これを操作するロボにそのようなコードを最適に入力させるには、
上で作れるような全ての系列について同様に系列を求め、その最短を選ぶことになる。</p>
<p>これを操作するロボに…以下同文で、これを実際に作ってみよう。</p>
<p>ここで多分、一つの文字の入力の末尾に必ず<code>A</code>を押すことで位置をリセットすることが効いていて、
上のロボの系列の全ての組み合わせを下のロボで試す必要はなく、
次のボタンを押すまでの系列ごとに試すだけで済むようになっているのだろう。
（プレイヤー側は「だろう」で済むが、出題側は証明または検証しないといけないので大変だ…）</p>
<pre><code class="language-haskell">import Data.List
import Data.Function

makePath :: String -&gt; String
makePath code = findCode3 code
  where
    findCode findCodePrev path code = concat
      [ shortest (map findCodePrev p)
      | ab &lt;- zip ('A':code) code
      , let p = path M.! ab ]
    findCodeHead code = code -- 自分は必要なコードをそのまま打ち込む
    findCode1 = findCode findCodeHead directionalPaths
    findCode2 = findCode findCode1    directionalPaths
    findCode3 = findCode findCode2    numericPaths

shortest xs = minimumBy (compare `on` length) xs
</code></pre>
<p>（<code>p</code> を作るところ、<code>ab</code> を経由せずに <code>p &lt;- zipWith (uncurry (path M.!)) ...</code> にしろと
コードアシストは言うけれど、<code>uncurry</code> 使ってまですることではないのでは？という。）</p>
<p>下請けロボの動作は単なる関数呼び出しの合成でなく、中で何度も使うための関数引数として渡す必要がある。
結果も大丈夫そうなので、答えを算出する。</p>
<pre><code class="language-haskell">part1 ls = sum [length (makePath l) * read (init l) | l &lt;- ls]
</code></pre>
<h1 id="パート2-112"><a class="header" href="#パート2-112">パート2</a></h1>
<p>パート1をそのまま拡大するのでは計算機の能力からあふれるだろう。
まず、<code>findCode</code> は、下請けへの要求としては操作系列を渡す必要があるが、
戻り値として完成した操作系列を戻す必要はない。最終的に必要なのは長さだけなので。</p>
<p>また、<code>findCode</code> の実例を手で作って入れ子を手で組み立てる代わりに、
ロボの段数を引数にして、各自で入れ子を作らせる。
段数0は上の <code>findCodeHead</code> に対応する。
最上段だけが <code>numericPaths</code> を使い、他は全員 <code>directionalPaths</code> を使う。
なので <code>path</code> は引数から外すことができる。</p>
<pre><code class="language-haskell">calcPathLen :: Int -&gt; String -&gt; Int
calcPathLen sysDepth code = findCodeLen sysDepth code
  where
    findCodeLen 0     code = length code -- 自分
    findCodeLen depth code = sum
      [ minimum (map (findCodeLen (pred depth)) p)
      | ab &lt;- zip ('A':code) code
      , let p = path M.! ab ]
      where
        path | depth == sysDepth = numericPaths
             | otherwise         = directionalPaths

part1a d ls = sum [calcPathLen d l * read (init l) | l &lt;- ls]
</code></pre>
<p>試してみる。</p>
<pre><code>ghci&gt; runner "sample.txt" (part1a 3)
126384
ghci&gt; [(d, calcPathLen d "029A") | d &lt;- [3 .. 26]]
[(3,68),(4,164),(5,404),(6,998),(7,2482),(8,6166),(9,15340),(10,38154),(11,Interrupted.
</code></pre>
<p>26段は無理。</p>
<h2 id="メモ化"><a class="header" href="#メモ化">メモ化</a></h2>
<p><code>findCodeLen</code> は、それぞれの層で、あるキーからあるキーへの移動と<code>A</code>を押す、の短い列について計算するだけなので、
最終的な系列が長大になっても、それぞれの層が扱う内容はそれほど複雑化していないはず。
つまり、実は同じ引数に対する計算を繰り返していて、メモ化で効率化できる。</p>
<p>引数が二つあるので <code>uncurry</code> して、<a href="https://qiita.com/gotoki_no_joe/items/713af82bfd0a94e8a335#%E9%85%8D%E5%88%97%E3%82%92%E5%BC%B5%E3%82%8C%E3%81%AA%E3%81%84%E7%A9%BA%E9%96%93%E3%81%A7%E3%82%82%E9%9B%86%E3%82%81%E3%82%8Bdp">集めるDPについて</a> で作ったこれ：</p>
<pre><code class="language-haskell">memoize :: Ord t =&gt; ((t -&gt; s) -&gt; t -&gt; ([t], s)) -&gt; t -&gt; s
memoize fya x = m M.! x
  where
    m = loop M.empty (S.singleton x)
    loop old new
      | S.null new = old
      | otherwise  = loop old1 new1
      where
        (kvs, jss) = unzip [((k,v),js) | k &lt;- S.elems new, let (js, v) = fya (m M.!) k]
        old1 = M.union old $ M.fromList kvs
        new1 = S.fromList $ concatMap (filter (flip M.notMember old1)) jss
</code></pre>
<p>でメモ化する。</p>
<pre><code class="language-haskell">calcPathLenM :: Int -&gt; String -&gt; Int
calcPathLenM sysDepth code = memoize findCodeLen (sysDepth, code)
  where
    findCodeLen _     (0    , code) = ([], length code)
    findCodeLen recur (depth, code) = (concat recargss, result)
      where
        ps = map (path M.!) $ zip ('A':code) code
        recargss = [[(pred depth, e) | e &lt;- p] | p &lt;- ps]
        result = sum [minimum (map recur recargs) | recargs &lt;- recargss]
        path | depth == sysDepth = numericPaths
             | otherwise         = directionalPaths

part1b d ls = sum [calcPathLenM d l * read (init l) | l &lt;- ls]
</code></pre>
<p>5つのコードについて計算するそれぞれについてメモ化がやり直しになるのかどうかが気に掛かるが…</p>
<pre><code>ghci&gt; runner "sample.txt" (part1b 3)
126384
ghci&gt; [(d, calcPathLenM d "029A") | d &lt;- [3 .. 26]]
[(3,68),(4,164),(5,404),(6,998),(7,2482),(8,6166),(9,15340),(10,38154),(11,94910),(12,236104),(13,587312),(14,1461046),(15,3634472),(16,9041286),(17,22491236),(18,55949852),(19,139182252),(20,346233228),(21,861298954),(22,2142588658),(23,5329959430),(24,13258941912),(25,32983284966),(26,82050061710)]
</code></pre>
<p>実行は一瞬でいけちゃった。</p>
<pre><code class="language-haskell">main2 = runner "input.txt" (part1b 26)
</code></pre>
<p>できた…！</p>
<h2 id="禁断の技"><a class="header" href="#禁断の技">禁断の技</a></h2>
<p>上の <code>memoize</code> は行儀はよいが、やはり、可能性のある引数を計算の本体とは別に構築する所が手間で、
そこで計算の二度手間を無くそうとした <code>calcPathLenM</code> の <code>findCodeLen</code> は
オリジナルと同じ計算をしているようには直観的には見えなくなってしまっている。</p>
<p>書き換え可能な変数を命令型プログラミングのように使って、本当のメモ化をする
<a href="https://qiita.com/gotoki_no_joe/items/713af82bfd0a94e8a335#%E8%BF%BD%E8%A8%98unsafeperformio">禁断の技</a>を使った版も試しておこう。</p>
<pre><code class="language-haskell">import Data.IORef
import qualified Data.Map as M
import System.IO.Unsafe

memoizeU :: Ord d =&gt; ((d -&gt; a) -&gt; (d -&gt; a)) -&gt; (d -&gt; a)
memoizeU mf = f
  where
    memo = unsafePerformIO $ newIORef M.empty
    f x = unsafePerformIO $ do
      m &lt;- readIORef memo
      case M.lookup x m of
        Just a -&gt; return a
        Nothing -&gt; do
          let a = mf f x
          modifyIORef' memo (M.insert x a)
          return a
</code></pre>
<p>これを使った <code>calcPathLenU</code> の実装は、元の <code>calcPathLen</code> とほとんど変わらない。
引数が <code>uncurry</code> されたせいで、中間変数 <code>e</code> が入ったくらい。</p>
<pre><code class="language-haskell">calcPathLenU :: Int -&gt; String -&gt; Int
calcPathLenU sysDepth code = memoizeU findCodeLen (sysDepth, code)
  where
    findCodeLen _     (0    , code) = length code
    findCodeLen recur (depth, code) = sum
      [ minimum [recur (pred depth, e) | e &lt;- p]
      | ab &lt;- zip ('A':code) code
      , let p = path M.! ab ]
      where
        path | depth == sysDepth = numericPaths
             | otherwise         = directionalPaths

part1c d ls = sum [calcPathLenU d l * read (init l) | l &lt;- ls]

main2U = runner "input.txt" (part1c 26)
</code></pre>
<p>以上。
最初はこのメモ化は禁断の技でしかできないと思っていたけれど、immutable な方でも十分だったのが驚き。
（問題の方の性質かもしれないけど。）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-35"><a class="header" href="#入力-35">入力</a></h1>
<p>整数の列が入るだけ。</p>
<pre><code class="language-haskell">runner i f = do
  ns &lt;- map read . lines &lt;$&gt; readFile i
  print $ f ns

test1 = runner "sample.txt" part1
main1 = runner "input.txt" part1

part1 :: [Int] -&gt; Int
part1 ns = ...
</code></pre>
<h1 id="パート1-41"><a class="header" href="#パート1-41">パート1</a></h1>
<ul>
<li>64を掛けるとは、左に6ビットシフトすること。</li>
<li>32で切り捨て除算するとは、右に5ビットシフトすること。</li>
<li>2048を掛けるとは、左に11ビットシフトすること。</li>
<li>「混ぜる」のビット単位XORをする必要がある</li>
<li>Windows標準の電卓をプログラマー電卓に切り替え、16777216を打ち込んでみると、2進数で <code>1_0000_0000_0000_0000_0000_0000</code> であることがわかる。「剪定」はこれで割った余りとはつまり、下位24ビットだけを取り出す、16777215とのビット単位ANDと同じとわかる。</li>
</ul>
<p>ということで、<code>Data.Bits</code> を使って擬似乱数生成の1ステップを定義する。</p>
<pre><code class="language-haskell">import Data.Bits

secretStep :: Int -&gt; Int
secretStep x = w
  where
    y = prune $ mix x $ shiftL x 6
    z = prune $ mix y $ shiftR y 5
    w = prune $ mix z $ shiftL z 11
    mix = xor
    prune x = 16777215 .&amp;. x
</code></pre>
<p>動作確認</p>
<pre><code>ghci&gt; take 11 $ iterate secretStep 123
[123,15887950,16495136,527345,704524,1553684,12683156,11100544,12249484,7753432,5908254]
</code></pre>
<p>あとは、それぞれの初期値に対して2000回回した結果を足し合わせたら終わり。</p>
<pre><code class="language-haskell">part1 :: [Int] -&gt; Int
part1 ns = sum [iterate secretStep n !! 2000 | n &lt;- ns]
</code></pre>
<h1 id="パート2-113"><a class="header" href="#パート2-113">パート2</a></h1>
<p>「代理の猿が次のバイヤーに進む」とか言われると、時刻とかからみそうだが、
実際には全てのバイヤーについて常に監視して、条件に合ったものがトリガーされる、
バイヤーの人数分だけ猿がいるような、シェイクスピアの猿みたいな設定。</p>
<p>価格が 0～9 の範囲をとるということは、ひとつの変動は -9～+9 の範囲をとる。
その4つの並びを考えるとき、例えば +9, +9 という並びはありえないが、
それを気にして、出現しうる変動4連を厳密に数え上げるのも無駄そうなので、
<code>((-9,-9,-9,-9),(9,9,9,9))</code> という配列の範囲で変動4連を網羅する。</p>
<p>一人一人のバイヤーについて、</p>
<ul>
<li>2001要素の乱数列を作る。</li>
<li>下1桁で価格の列にする</li>
<li>変動の列を作る</li>
<li>連続する4変動とそのときの価格の組み合わせで、変動が最初に出現したものの価格を表に登録する</li>
</ul>
<p>とすることで、初出の全ての4変動のパターンを指定したときのそのバイヤーの売値を調べ上げることができる。</p>
<pre><code class="language-haskell">type ARR = UArray (Int,Int,Int,Int) Int

bnds :: ((Int, Int, Int, Int), (Int, Int, Int, Int))
bnds = ((-9,-9,-9,-9),(9,9,9,9))

countBuyer :: Int -&gt; ARR
countBuyer seed = arr
  where
    ps = map (flip mod 10) $ take 2001 $ iterate secretStep seed
    ds = zipWith (-) (tail ps) ps
    d4s = zip4 ds (drop 1 ds) (drop 2 ds) (drop 3 ds)
    arr = accumArray set (-1) bnds $ zip d4s (drop 4 ps)

    set (-1) x = x
    set x    _ = x
</code></pre>
<p>-1を未定義値とみなし、<code>accumArray</code>の更新では-1が入っていたときのみ値を上書きすることで、
その変動パターンに対する最初の価格を記録しているところがポイント。</p>
<p>次に、全バイヤーのこの配列を要素ごとに足し合わせる。-1は無視する点に注意。</p>
<pre><code class="language-haskell">mergeArrays :: [ARR] -&gt; ARR
mergeArrays arrs = listArray bnds $ map (sum . map (max 0)) $ transpose $ map elems arrs
</code></pre>
<p>この配列の要素の最大値が求める値で、そのために猿に指示する列はそのような値の入っている添え字。
後者は必要ないが、せっかくなので。</p>
<pre><code class="language-haskell">part2 ns = (ans, seq4s)
  where
    arr = mergeArrays $ map countBuyer ns
    ans = maximum $ elems arr
    seq4s = [i | (i,e) &lt;- assocs arr, e == ans]

main2 = runner "input.txt" part2
</code></pre>
<p>動作確認</p>
<pre><code>ghci&gt; part2 [1,2,3,2024]
(23,[(-2,1,-1,3)])
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-36"><a class="header" href="#入力-36">入力</a></h1>
<p>コンピュータの名前の文字列のペア、でなく長さ2のリストで一行を表現して、そのリストにする。
タプルよりむしろ扱いが楽かもしれない。</p>
<p><code>input.txt</code> も覗いて、2文字-2文字固定と割りきってしまってもいいかも。
一応、任意の文字列としておく。</p>
<pre><code class="language-haskell">runner i f = do
  pqs &lt;- map parse . lines &lt;$&gt; readFile i
  print $ f pqs

parse l = [as, bs]
  where
    (as,_:bs) = break ('-' ==) l

test1 = runner "sample.txt" part1
main1 = runner "input.txt" part1

part1 pqs = ...
</code></pre>
<h1 id="パート1-42"><a class="header" href="#パート1-42">パート1</a></h1>
<p>コンピュータを頂点、接続を辺とする無向グラフを考える。
頂点をキーにしたマップに、接続している頂点の集合を付けてグラフの隣接行列的な情報を集約する。
接続は無向なためこの行列は対角線について対称になるが、
キーよりも大きい相手についてだけ登録する、上三角行列に相当する形にしておく。</p>
<pre><code class="language-haskell">import qualified Data.Map as M
import qualified Data.Set as S

part1 pqs = ...
  where
    m = fmap S.fromList $ M.fromListWith (++) $ [(minimum pq,[maximum pq]) | pq &lt;- pqs]
</code></pre>
<p>このマップ <code>m</code> があれば、相互に接続された3頂点は、</p>
<ul>
<li>いずれかの頂点 <code>p</code> を一つ選び、（<code>m</code> から得られる）その隣接頂点集合を <code>qS</code> としたとき、</li>
<li><code>qS</code> のいずれかの要素 <code>q</code> を一つ選び、その隣接頂点集合を<code>rS</code> としたとき、</li>
<li><code>qS</code> と <code>rS</code> の共通部分集合の要素 <code>r</code> について</li>
<li><code>(p,q,r)</code> は相互に接続されている</li>
</ul>
<p>として全てが重複なく取り出せる。
これらのいずれかの1文字めが <code>t</code> であることを確認し、その個数を数える。</p>
<pre><code class="language-haskell">
part1 pqs = length
  [ (p,q,r)
  | (p,qS) &lt;- M.assocs m
  , q &lt;- S.elems qS
  , M.member q m -- q, r は m にキーとして現れない可能性がある
  , r &lt;- S.elems $ S.intersection qS $ m M.! q
  , elem 't' $ map head [p,q,r]
  ]
  where
    m = fmap S.fromList $ M.fromListWith (++) $ [(minimum pq,[maximum pq]) | pq &lt;- pqs]
</code></pre>
<p><code>length</code> を外せば、問題文の例と一致するか確認できる。</p>
<h1 id="パート2-114"><a class="header" href="#パート2-114">パート2</a></h1>
<p>部分グラフで、完全グラフになっているようなものの最大のものを発見せよと。
こういうのは「最大クリーク」とい、NP困難なのだそうな。</p>
<p>とりあえず、グラフの情報はパート1と同様な形に、ただし、その後の計算を高速化するために、
まず頂点に1始まりで背番号を振り、整数で扱うことにする。
また、その後の都合で、接続関係は頂点番号がより小さいものについて集めておくことにする。</p>
<pre><code class="language-haskell">import qualified Data.IntSet as IS

import Data.Array.IArray

part2 pqs = ...
  where
    pS = S.fromList $ "" : concat pqs
    n = pred $ S.size pS
    g :: Array Int IS.IntSet
    g = amap IS.fromList $ accumArray (flip (:)) [] (1, n)
        [maxmin ij | pq &lt;- pqs, let ij = map (flip S.findIndex pS) pq]

    maxmin (a:b:_)
      | a &gt;= b    = (a,b)
      | otherwise = (b,a)
</code></pre>
<p>深さ優先探索で全ての完全グラフであるような部分集合を列挙することを考える。</p>
<p>ある段階まで調べ終わった状態は、選択した頂点集合と、それら全てと接続している頂点の集合の対で表現される。
初期値はそれぞれ空集合と全体集合の対である。
さらに、頂点番号を降順に調べていくとして、次はどこを調べるか、も持たせておく。</p>
<ul>
<li>今から調べる頂点番号 <code>k</code></li>
<li>選択している頂点集合 <code>mem</code></li>
<li><code>mem</code> の全てと接続している頂点の集合 <code>con</code></li>
</ul>
<p>に対して、<code>k</code> を採用した状態と不採用にした状態の二つを探索する必要がある。</p>
<p><code>k</code> を採用した状態</p>
<ul>
<li><code>mem</code> に <code>k</code> を追加</li>
<li><code>con</code> は <code>k</code> の辺と共通部分に絞る <code>con1</code> とする</li>
<li>次の <code>k</code> は <code>con1</code> の最大の要素　これを探す計算を補助するために、頂点番号0を番兵として配置する</li>
</ul>
<p><code>k</code> を採用しなかった状態</p>
<ul>
<li><code>mem</code> <code>con</code> は変化なし</li>
<li>次に調べる頂点は、<code>con</code> の <code>k</code> 未満の最大値</li>
</ul>
<p>再帰で <code>k=0</code> まで降りたとき、再帰呼び出しを止め、結果を一つ返す。
二つの分岐に枝分かれした両方の結果の大きい方を選んで返せば答えになる。</p>
<pre><code class="language-haskell">part2 pqs = post ans1
  where
    post = intercalate "," . map (flip S.elemAt pS) . IS.elems

    g = amap (IS.fromList . (0 :)) $ accumArray (flip (:)) [] (1, n) -- 番兵入り
        [maxmin ij | pq &lt;- pqs, let ij = map (flip S.findIndex pS) pq]

    ans1 = snd $ dfs n (0, IS.empty) (IS.fromDistinctAscList [0 .. n])
      where
        dfs :: Int -- 今から調べる頂点番号
            -&gt; (Int, IS.IntSet) -- 今調査している状態、サイズと頂点集合
            -&gt; IS.IntSet        -- と、次に選べる、全結合になっている頂点集合
            -&gt; (Int, IS.IntSet) -- 答え、サイズと頂点集合
        dfs 0 ent _ = ent                       -- 底まで降りたら答えを返す
        dfs k ent@(sz, mem) con = max res1 res2 -- 分岐して戻ってきた値の大きい方
          where
            sz1  = succ sz
            mem1 = IS.insert k mem
            con1 = IS.intersection con $ g ! k
            res1 = dfs (IS.findMax con1) (sz1, mem1) con1     -- kを入れて再帰
            res2 = dfs (fromJust $ IS.lookupLT k con) ent con -- kを入れずに再帰
</code></pre>
<p>これでもう十分な結果が得られたが、もっと枝刈りをすることを考えよう。
これまでに見つかっている（作りかけのものも含めて）最大の結果を追加の引数で持ち回すことにする。</p>
<p>上の <code>dfs</code> の定義にそれを単純に盛り込むと、概略として</p>
<pre><code class="language-haskell">dfs 0 = max arg best
dfs k arg best = max (dfs k' arg1 best) (dfs k' arg2 best)
</code></pre>
<p>このような感じになる。
このようなやり方で再帰を二手に分けると、片方の分岐の最新の結果をもう片方の分岐が参照できない。
そこで構造を少し変えてやる。</p>
<pre><code class="language-haskell">dfs 0 = max arg best
dfs k arg best = dfs k' arg1 $ dfs k' arg2 best
</code></pre>
<p>これで、最新の結果 <code>best</code> が、<code>dfs</code> の適用の連鎖を駆け上がる形で最新情報を送り込める。</p>
<p>ここで、<code>best</code> の値は <code>k=0</code> を待たずに、再帰の途中でも可能なら更新をかけるものとする。</p>
<p>さて、そのような現時点での最適解があると、今調べている事例が手遅れ、という判定ができる。
つまり、今 <code>k</code> を加えるとき、1～k全てのk頂点を追加できた最善の場合でも、
最適解を更新できないとわかったら、この事例をそれ以上計算する意味はない。なので放棄する。</p>
<p>以上の改善を盛り込む。</p>
<pre><code class="language-haskell">    ans2 = snd $ dfs n (0, IS.empty) (IS.fromDistinctAscList [0 .. n]) (0, IS.empty)
      where
        dfs :: Int -- 今から調べる頂点番号
            -&gt; (Int, IS.IntSet) -- 今調査している状態、サイズと頂点集合
            -&gt; IS.IntSet        -- と、次に選べる、全結合になっている頂点集合
            -&gt; (Int, IS.IntSet) -- 現時点での最適解
            -&gt; (Int, IS.IntSet) -- 答え、サイズと頂点集合
        dfs 0 _ent _ best = best               -- bestは常時更新するので、_entがベスト解ならbestも同じ内容
        dfs k ent@(sz, mem) con best@(bestsz,_)
          | k + sz &lt; bestsz = best                       -- 挽回不能な差がついている
          | otherwise =
            dfs (fromJust $ IS.lookupLT k con) ent con $ -- kを入れずに再帰
            dfs (IS.findMax con1) ent1 con1 $            -- kを入れて再帰
            if sz == bestsz then ent1 else best          -- sz==bestszならsucc sz&gt;bestszなので更新する
          where
            mem1 = IS.insert k mem
            con1 = IS.intersection con $ g ! k
            ent1 = (succ sz, mem1)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-37"><a class="header" href="#入力-37">入力</a></h1>
<p><code>input.txt</code> まで覗いて信号名は3文字であることを確認し、その知識を使うと、
前半は前3文字と、末尾の1文字(0または1)が<code>1</code>かどうかの<code>Bool</code>値のペアにできる。</p>
<pre><code class="language-haskell">parse1 :: String -&gt; (String, Bool)
parse1 l = (take 3 l, last l == '1')
</code></pre>
<p>後半は、<code>words</code>で切り分けて矢印以外をタプルに詰めておけばとりあえずはよいかと。</p>
<pre><code class="language-haskell">parse2 :: String -&gt; (String, String, String, String)
parse2 l = (a,b,c,d)
  where
    a:b:c:_:d:_ = words l
</code></pre>
<p>そんな要素のリストふたつを渡す。</p>
<pre><code class="language-haskell">runner i f = do
  (ls1, _:ls2) &lt;- break null . lines &lt;$&gt; readFile i
  let p1 = map parse1 ls1
  let p2 = map parse2 ls2
  print $ f p1 p2

test1 = runner "samp1.txt" part1
test2 = runner "samp2.txt" part1
main1 = runner "input.txt" part1

part1 p1 p2 = ...
</code></pre>
<h1 id="パート1-43"><a class="header" href="#パート1-43">パート1</a></h1>
<p>過去のAoCでは、似たような話で、その上ループで信号が流れ続ける難問（というか解けていない）があったが、
これは信号の状態は一度確定したらそのままの静的なシステムなのでごく簡単。</p>
<p>信号名からその状態を取り出せる <code>Map String Bool</code> を作り、</p>
<ul>
<li>入力信号はその値を普通に設定</li>
<li>ゲート出力は、そのマップを参照して入力を取り出し、結果出力を設定</li>
</ul>
<p>という循環参照を遅延評価で解決させるいつものやつで、計算はあっという間にできてしまう。</p>
<pre><code class="language-haskell">import qualified Data.Map as M

part1 p1 p2 = ...
  where
    m = M.fromList $ p1 ++ [(d, op b (m M.! a) (m M.! c)) | (a,b,c,d) &lt;- p2]
    op "OR" = (||)
    op "AND" = (&amp;&amp;)
    op "XOR" = (/=)
</code></pre>
<p>Haskell使えない人が見たら「ズルイ！」と叫びそうな解答プログラムだ。</p>
<p>後は、このマップからあるだけ <code>z</code> な信号を取り出して、二進数を読み取るだけ。</p>
<pre><code class="language-haskell">part1 p1 p2 =
    sum $                                                     -- 足し合わせる
    zipWith (\i b -&gt; if b then i else 0) (iterate (2 *) 1) $ -- Trueのとき2^kを
    map (m M.!) $ takeWhile (flip M.member m)         -- マップにある間だけ取り出し、マップを読み、
    ['z' : tail (show i) | i &lt;- [100 ..]]             -- 信号名を無限に生成
</code></pre>
<!--
## 先行評価だと？

Haskellどっぷりなせいで、こういうことができない言語だとどうやって計算するのかピンとこなくなってきた。

- マップ `gate` :ゲートは接続先の出力信号で一意に区別できる。ゲートの演算と入力信号名を書いておく。
- マップ `obs` :信号名をキーに、その信号を入力で取り込んでいるゲートの一覧を持つマップも作っておく。
- マップ `sig` :信号の状態を記録する。最初は空。
- パズル入力前半を使って、入力信号の内容を `sig` に割り当てていく。
  - `obs`を使って、その信号を見ているゲートを順にチェックする。
  - 入力が両方揃ったのなら、その出力も次に `sig` に割り当てるキューに入れる（その場で再帰計算してもいけるのかも）
- 全ての入力信号を割り当て、ゲート出力の波及が全て止まったら、全ての信号の状態が確定している

という感じか。
再帰呼び出しのスタックが許せば、メモ化再帰のスタイルでも計算できるか。
-->
<h1 id="パート2-115"><a class="header" href="#パート2-115">パート2</a></h1>
<p>なんだかとっても厄介そうな話になってきた。
<code>input.txt</code>の行で数えてゲート、つまり入れ替え候補は 313-91 = 222個
総当たりで試すとすると場合の数は ${}_{222} C_8 = 128,795,283,347,445$ 通り。</p>
<p>もう少し特徴を調べてみると、入力信号は 45ビットのxとy、出力信号zは46ビット。
総当たりの総当たりは気が遠くなりすぎる。</p>
<p>ところで、意地悪な回路になっているのだろうか。</p>
<p>二進数1桁ぶんの、最も単純な加算器は、XとYの2ビットを、和Sと上の桁へのくり上がりCoutに変換する。
これは</p>
<pre><code>X xor Y = S
X and Y = Cout
</code></pre>
<p>と作れる。これをハーフアダーという。
加算がこれで済むのは1の位の桁だけで、それより上は、下の桁からのくり上がりを含めた3ビットを、SとCに変換する回路になる。
これは、ハーフアダー2つとORゲート1つで作れる。</p>
<pre><code>X xor Y = T -- halfadder 1
X and Y = U

T xor Cin = S -- halfadder 2
T and Cin = V

U or  V = Cout
</code></pre>
<p>T,U,Vは内部信号。
これをフルアダーという。
ただし、X,Y,Cinのどれを先に足すかは自由なので、回路の構造はバリエーションが存在しうる。</p>
<p>さて、入力が45桁のとき、ハーフアダー1つ、フルアダー44個が必要。
使うゲートの個数は $2 + 5 \times 44 = 222$ ぴったり一致。つまりこの回路構成に対して、一切の無駄がない。
ということで、この構造から外れている箇所を分析すればよい。
エディタで開いてにらめっこでは能が無いので、必要な情報を取り出して補助するプログラムを作っていこう。</p>
<h2 id="道具1"><a class="header" href="#道具1">道具1</a></h2>
<p>最も基本的な道具として、信号名2つを指定して、その二つを直接使っているゲートを全て挙げる関数を作る。
信号名は辞書順にしたマップに情報を入れておいて検索すればよいだろう。</p>
<p>応用として、それを使って <code>x00</code>, <code>y00</code> からどのように接続がされているかを調べてみる。</p>
<pre><code class="language-haskell">main2 = runner "input.txt" part2

part2 _ p2 = graph "x00" "y00"
  where
    g = M.fromListWith (++) [((min a c, max a c), [(b, d)]) | (a,b,c,d) &lt;- p2]
    graph a b = M.findWithDefault [] (min a b, max a b) g
</code></pre>
<pre><code>ghci&gt; main2
[("AND","hfm"),("XOR","z00")]
</code></pre>
<p>ちゃんとハーフアダーになっていて、和は <code>z00</code> にちゃんとつながっている。
ということは2の位へのくり上がりは <code>hfm</code> なのだろう。</p>
<h2 id="道具2"><a class="header" href="#道具2">道具2</a></h2>
<p>以降のフルアダーの接続が正しいかどうかを追跡する関数を作る。
調査したいビット位置、下の位からのくり上がり信号の名前、を引数としてとり、
正しく接続がされているときは次の桁へのくり上がり信号の名前を、
何か異常があるときは <code>Nothing</code> を返すようにする。</p>
<p>先にハーフアダーをかける信号2つの組み合わせ3とおり全てを試すようにする必要があることに注意。</p>
<pre><code class="language-haskell">import Control.Applicative
import Control.Monad

    check k cin = sub x y cin &lt;|&gt; sub y cin x &lt;|&gt; sub cin x y
      where
        x = 'x' : tail (show $ k + 100)
        y = 'y' : tail x
        z = 'z' : tail x
        sub a b c = do
          let gab = graph a b
          t &lt;- lookup "XOR" gab
          u &lt;- lookup "AND" gab
          let gtc = graph t c
          zc &lt;- lookup "XOR" gtc
          guard $ zc == z
          v &lt;- lookup "AND" gtc
          lookup "OR" $ graph u v
</code></pre>
<p>Maybeモナドでいい感じに書けた。</p>
<h2 id="道具3主戦力"><a class="header" href="#道具3主戦力">道具3:主戦力</a></h2>
<p>これを2の位から順に調べて、異常を検知したところで停止し、状況を報告するプログラムにする。</p>
<pre><code class="language-haskell">part2 _ p2 = checkloop 1 c00
  where
    Just c00 = lookup "AND" $ graph "x00" "y00"

    checkloop k cin =
      case check k cin of
        Just cout -&gt; checkloop (succ k) cout
        Nothing   -&gt; (k, cin, graph x y, graph y cin, graph cin x)
      where
        x = 'x' : drop 1 (show $ k + 100)
        y = 'y' : drop 1 x
</code></pre>
<p>動かす。</p>
<pre><code>ghci&gt; main2
(7,"btq",[("AND","jss"),("XOR","krv")],[],[])
</code></pre>
<h2 id="手作業"><a class="header" href="#手作業">手作業</a></h2>
<p><code>x07</code>, <code>y07</code>, <code>z07</code>, <code>btq</code>, <code>jss</code>, <code>krv</code> がどうなっているのか調べる。
これはもう <code>input.txt</code> をエディタで見るか <code>grep</code> する方が早い。
その結果を本来の接続と見比べると、 <code>nqk</code> と <code>z07</code> を入れ替えれば直るとわかる。</p>
<p>なのでそこを直す。
ただし、<code>input.txt</code> を編集してではなく、読み込んだデータの上だけ。</p>
<pre><code class="language-haskell">--  g = M.fromListWith (++) [((min a c, max a c), [(b,      d)]) | (a,b,c,d) &lt;- p2]
    g = M.fromListWith (++) [((min a c, max a c), [(b, repl d)]) | (a,b,c,d) &lt;- p2]

    repl "nqk" = "z07"
    repl "z07" = "nqk"
    repl sig = sig
</code></pre>
<p>一箇所直したので、調査を再起動し、次の誤りを見つける。4回これをやると、</p>
<pre><code>ghci&gt; main2
(45,"z45",[],[],[])
</code></pre>
<p>となって、MSBを越えたオーバーフローのキャリーフラグまで接続に問題ないことが確認できた。</p>
<h2 id="完成-2"><a class="header" href="#完成-2">完成</a></h2>
<p>4箇所で入れ替えた8つの信号名をソートして連結すれば、入力欄に入れる文字列が完成する。</p>
<pre><code class="language-haskell">import Data.List

part2ans = intercalate "," $ sort
  [ "nqk", "z07"
  , ...
</code></pre>
<p>ということで、パート2はプログラミングよりも手で分析する時間の方が長かったし、
コンピュータアーキテクチャ（のごく基本的な部分だけど）の知識も必要な、
コンピュータサイエンスの広い知見を問われる、興味深い問題だったと思います。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入力-38"><a class="header" href="#入力-38">入力</a></h1>
<p>空行ごとに区切る。
あとは本体に任せよう。</p>
<pre><code class="language-haskell">runner i f = do
  ents &lt;- wordsBy null . lines &lt;$&gt; readFile i
  print $ f ents
</code></pre>
<h1 id="分析"><a class="header" href="#分析">分析</a></h1>
<p>図面の個数、図面の幅は一定のようだが行数は一定なのか、
図面に重複はないのか、問題文だけでは怪しいので確認する。</p>
<pre><code class="language-haskell">import Data.List

check ents = (length ents, all (head ls ==) ls, nub ents == ents)
  where
    ls = map length ents
</code></pre>
<pre><code>ghci&gt; runner "sample.txt" check
(5,True,True)
ghci&gt; runner "input.txt" check
(500,True,True)
</code></pre>
<p>意地悪はないようだ。</p>
<h1 id="構築"><a class="header" href="#構築">構築</a></h1>
<p>要求されている <strong>fit</strong> とは、錠と鍵の形がぴったり一致することでは<strong>なく</strong>、
重なりが出てしまわない、という事のようだ。</p>
<p>なので、錠のそれぞれの列にある <code>#</code> の数を取り出しておき、
鍵のそれぞれの列の値と足し合わせて全て7を越えないような組み合わせの個数を求めればよい。</p>
<pre><code class="language-haskell">part1 ents = length
  [ ()
  | e &lt;- ents, head (head e) == '.'
  , let is = process e
  , js &lt;- locks
  , all (7 &gt;=) $ zipWith (+) is js
  ]
  where
    locks = [process e | e &lt;- ents, head (head e) == '#']
    process = map (length . filter ('#' ==)) . transpose

test1 = runner "sample.txt" part1
main1 = runner "input.txt" part1
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
