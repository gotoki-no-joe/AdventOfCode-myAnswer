<!DOCTYPE HTML>
<html lang="ja" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Advent of Code</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> はじめに</a></li><li class="chapter-item "><a href="2015/index.html"><strong aria-hidden="true">2.</strong> 2015</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2015/day1.html"><strong aria-hidden="true">2.1.</strong> Day  1</a></li><li class="chapter-item "><a href="2015/day2.html"><strong aria-hidden="true">2.2.</strong> Day  2</a></li><li class="chapter-item "><a href="2015/day3.html"><strong aria-hidden="true">2.3.</strong> Day  3</a></li><li class="chapter-item "><a href="2015/day4.html"><strong aria-hidden="true">2.4.</strong> Day  4</a></li><li class="chapter-item "><a href="2015/day5.html"><strong aria-hidden="true">2.5.</strong> Day  5</a></li><li class="chapter-item "><a href="2015/day6.html"><strong aria-hidden="true">2.6.</strong> Day  6</a></li><li class="chapter-item "><a href="2015/day7.html"><strong aria-hidden="true">2.7.</strong> Day  7</a></li><li class="chapter-item "><a href="2015/day8.html"><strong aria-hidden="true">2.8.</strong> Day  8</a></li><li class="chapter-item "><a href="2015/day9.html"><strong aria-hidden="true">2.9.</strong> Day  9</a></li><li class="chapter-item "><a href="2015/day10.html"><strong aria-hidden="true">2.10.</strong> Day 10</a></li><li class="chapter-item "><a href="2015/day11.html"><strong aria-hidden="true">2.11.</strong> Day 11</a></li><li class="chapter-item "><a href="2015/day12.html"><strong aria-hidden="true">2.12.</strong> Day 12</a></li><li class="chapter-item "><a href="2015/day13.html"><strong aria-hidden="true">2.13.</strong> Day 13</a></li><li class="chapter-item "><a href="2015/day14.html"><strong aria-hidden="true">2.14.</strong> Day 14</a></li><li class="chapter-item "><a href="2015/day15.html"><strong aria-hidden="true">2.15.</strong> Day 15</a></li><li class="chapter-item "><a href="2015/day16.html"><strong aria-hidden="true">2.16.</strong> Day 16</a></li><li class="chapter-item "><a href="2015/day17.html"><strong aria-hidden="true">2.17.</strong> Day 17</a></li><li class="chapter-item "><a href="2015/day18.html"><strong aria-hidden="true">2.18.</strong> Day 18</a></li><li class="chapter-item "><a href="2015/day19.html"><strong aria-hidden="true">2.19.</strong> Day 19</a></li><li class="chapter-item "><a href="2015/day20.html"><strong aria-hidden="true">2.20.</strong> Day 20</a></li><li class="chapter-item "><a href="2015/day21.html"><strong aria-hidden="true">2.21.</strong> Day 21</a></li><li class="chapter-item "><a href="2015/day22.html"><strong aria-hidden="true">2.22.</strong> Day 22(未)</a></li><li class="chapter-item "><a href="2015/day23.html"><strong aria-hidden="true">2.23.</strong> Day 23</a></li><li class="chapter-item "><a href="2015/day24.html"><strong aria-hidden="true">2.24.</strong> Day 24</a></li><li class="chapter-item "><a href="2015/day25.html"><strong aria-hidden="true">2.25.</strong> Day 25</a></li></ol></li><li class="chapter-item "><a href="2016/index.html"><strong aria-hidden="true">3.</strong> 2016</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2016/day1.html"><strong aria-hidden="true">3.1.</strong> Day  1</a></li><li class="chapter-item "><a href="2016/day2.html"><strong aria-hidden="true">3.2.</strong> Day  2</a></li><li class="chapter-item "><a href="2016/day3.html"><strong aria-hidden="true">3.3.</strong> Day  3</a></li><li class="chapter-item "><a href="2016/day4.html"><strong aria-hidden="true">3.4.</strong> Day  4</a></li></ol></li><li class="chapter-item "><div><strong aria-hidden="true">4.</strong> 2017</div></li><li class="chapter-item "><div><strong aria-hidden="true">5.</strong> 2018</div></li><li class="chapter-item "><div><strong aria-hidden="true">6.</strong> 2019</div></li><li class="chapter-item "><div><strong aria-hidden="true">7.</strong> 2020</div></li><li class="chapter-item "><div><strong aria-hidden="true">8.</strong> 2021</div></li><li class="chapter-item "><a href="2022/index.html"><strong aria-hidden="true">9.</strong> 2022</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2022/day1.html"><strong aria-hidden="true">9.1.</strong> Day  1</a></li><li class="chapter-item "><a href="2022/day2.html"><strong aria-hidden="true">9.2.</strong> Day  2</a></li><li class="chapter-item "><a href="2022/day3.html"><strong aria-hidden="true">9.3.</strong> Day  3</a></li><li class="chapter-item "><a href="2022/day4.html"><strong aria-hidden="true">9.4.</strong> Day  4</a></li><li class="chapter-item "><a href="2022/day5.html"><strong aria-hidden="true">9.5.</strong> Day  5</a></li><li class="chapter-item "><a href="2022/day6.html"><strong aria-hidden="true">9.6.</strong> Day  6</a></li><li class="chapter-item "><a href="2022/day7.html"><strong aria-hidden="true">9.7.</strong> Day  7</a></li><li class="chapter-item "><a href="2022/day8.html"><strong aria-hidden="true">9.8.</strong> Day  8</a></li><li class="chapter-item "><a href="2022/day9.html"><strong aria-hidden="true">9.9.</strong> Day  9</a></li><li class="chapter-item "><a href="2022/day10.html"><strong aria-hidden="true">9.10.</strong> Day 10</a></li><li class="chapter-item "><a href="2022/day11.html"><strong aria-hidden="true">9.11.</strong> Day 11</a></li><li class="chapter-item "><a href="2022/day12.html"><strong aria-hidden="true">9.12.</strong> Day 12</a></li><li class="chapter-item "><a href="2022/day13.html"><strong aria-hidden="true">9.13.</strong> Day 13</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Advent of Code</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="advent-of-code"><a class="header" href="#advent-of-code">Advent of Code</a></h1>
<p><a href="https://adventofcode.com/">Advent of Code</a>の問題を翻訳しています。</p>
<h2 id="訳語とかについて"><a class="header" href="#訳語とかについて">訳語とかについて</a></h2>
<p>サンタの周りで色々と騒ぎを引き起こす、物語の主要な登場人物は、
原文では elf, elves となっています。
これを「エルフ」と訳してしまうと、現代日本では、耳の長い長命な亜人のことになってしまうので、
「小人」としました。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2015年"><a class="header" href="#2015年">2015年</a></h1>
<p>サンタはホワイトクリスマスを望んでいましたが、
彼のお天気制御装置の「雪」機能はスターが動力源なのに、
彼はスターを使い切ってしまったところです！
クリスマスを救うには、12月25日までに50個のスターを集める必要があります。</p>
<p>サンタがパズルを解くのを助けることでスターを集めよう。
このアドベントカレンダーでは、毎日2つのパズルが利用可能になります。
2番目のパズルは、1番目を完了するとロックが解除されます。
各パズルで1つずつ星が貰えます。がんばろう！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1日目lispではない"><a class="header" href="#1日目lispではない">1日目：Lispではない</a></h1>
<p>今日はあなたの準備運動のための簡単なパズルです。</p>
<p>サンタは大きなマンションでプレゼントを配ろうとしていますが、
彼は正しいフロアを見つけることができません。
彼が得た指示は何だかややこしいものです。
彼は地上階(0階)から開始し、一度に1文字ずつ指示に従います。</p>
<p>開き括弧 <code>(</code> は1階上がるべきであることを意味し、
閉じ括弧 <code>)</code> はフロアを1つ降りることを意味します。</p>
<p>マンションの建物は非常に高く、地下室も非常に深いです。
彼は決して最上階や最下層に到達することはありません。</p>
<h2 id="例"><a class="header" href="#例">例</a></h2>
<ul>
<li><code>(())</code> と <code>()()</code> はどちらも0階で終わります。</li>
<li><code>(((</code> と <code>(()(()(</code> はどちらも3階で終わります。</li>
<li><code>))(((((</code> もまた3階になります。</li>
<li><code>())</code> と <code>))(</code> はどちらも \(-1\) 階（地下1階）になります。</li>
<li><code>)))</code> と <code>)())())</code> はどちらも \(-3\) 階になります。</li>
</ul>
<p>さて、指示書に従ったサンタが最後にたどり着くのは<strong>何階</strong>でしょうか？</p>
<details><summary>解説</summary><div>
階数を 0 から始めて、開きカッコで増やし、閉じ括弧で減らせばよい。
<pre><code class="language-haskell">part1 :: String  -- 入力
      -&gt; Int     -- 答え
part1 = foldl step 0

step n '(' = succ n
step n ')' = pred n
</code></pre>
</div></details>
<h1 id="パート2"><a class="header" href="#パート2">パート2</a></h1>
<p>今度は、同じ指示書を受け取ったとして、
彼を地下1階（\(-1\)階）に到達させる最初の文字の位置を見つけてください。
指示書の最初の文字の位置は1、
2番目の文字は位置2、以下同文とします。</p>
<h2 id="例-1"><a class="header" href="#例-1">例</a></h2>
<ul>
<li><code>)</code> 彼は位置1の文字で地下1階に入る。</li>
<li><code>()())</code> 彼は位置5の文字で地下1階に入る。</li>
</ul>
<p>サンタが最初に地下1階に入る原因となる<strong>文字の位置</strong>は？</p>
<details><summary>解説</summary><div>
<p>パート1と同様に現在位置を追跡し、最初に \(-1\) になったところで止めて、
そこまでの位置の個数が答えである。</p>
<pre><code class="language-haskell">part2 :: String -&gt; Int
part2 = length . takeWhile (-1 &lt;) . scanl step 0
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2日目数学は使わないと私は言われた"><a class="header" href="#2日目数学は使わないと私は言われた">2日目：数学は使わない、と私は言われた</a></h1>
<p>小人は包装紙を使い切りそうになっているので、もっと注文する必要があります。
彼らは各プレゼントの寸法（長さ \(l\) 、幅 \(w\) 、高さ \(h\) ）のリストを持っていて、
必要なだけを正確に注文したいです。</p>
<p>幸いなことに、すべてのプレゼントは箱（正確な直方体）です。
これは、それぞれの贈り物に必要な包装紙の計算を少し簡単にします。
箱の表面積 \(2 \times l \times w + 2 \times w \times h + 2 \times h \times l\)
を求めてください。
小人はまた、それぞれのプレゼントに少し、
具体的には最も小さい面の面積だけ紙を余分に必要とします。</p>
<h2 id="例-2"><a class="header" href="#例-2">例</a></h2>
<ul>
<li>寸法 \(2 \times 3 \times 4\) のプレゼントは、
\(2 \times 6 + 2 \times 12 + 2 \times 8 = 52\) 平方フィートに、
余裕を6加えた58平方フィートの包装紙が必要です。</li>
<li>寸法 \(1 \times 1 \times 10\) のプレゼントは
\(2 \times  1 + 2 \times 10 + 2 \times 10 = 42\) 平方フィートに
余裕を1加えた43平方フィートの包装紙が必要です。</li>
</ul>
<p>小人のリストに載っている数字はすべてフィートです。
注文するべき<strong>包装紙の総面積</strong>は何平方フィートですか？</p>
<details><summary>解説</summary><div>
<p>要求どおりに計算するだけ。</p>
<pre><code class="language-haskell">part1 :: [(Int,Int,Int)]  -- l,w,h
      -&gt; Int              -- 答え
part1 = sum . map fun1

fun1 (l,w,h) = minimum as + 2 * sum as
  where
    as = [l * w, w * h, h * l]
</code></pre>
</div></details>
<h1 id="パート2-1"><a class="header" href="#パート2-1">パート2</a></h1>
<p>小人はリボンも使い切りそうです。
リボンはすべて同じ幅であるため、
注文するときに気にすることは必要な長さだけで、
やはり正確に注文したいと考えています。</p>
<p>プレゼントを縛るために必要なリボンは、
その側面の周長のうち最短のもの、
言い換えるといずれかの面の周長の最小値です。
それぞれのプレゼントには、リボンの蝶結びも必要です。
完璧な蝶結びに必要なリボンの長さは、
プレゼントの容積の立方フィートと同じです。
彼らがどのように蝶結びを作るのか尋ねないでください。
彼らは決して教えてくれません。</p>
<h2 id="例-3"><a class="header" href="#例-3">例</a></h2>
<ul>
<li>寸法 \(2 \times 3 \times 4\) のプレゼントは、縛るために \(2+2+3+3 = 10\) フィートのリボンが、
蝶結びのために \(2 \times 3 \times 4 = 24\) フィートのリボンが必要で、
合わせて34フィート必要です。</li>
<li>寸法 \(1 \times 1 \times 10\) のプレゼントは、縛るために \(1+1+1+1 = 4\) フィートのリボンが、
蝶結びのために \(1 \times 1 \times 10 = 10\) フィートのリボンが必要で、
合わせて14フィート必要です。</li>
</ul>
<p>彼らが注文するべき<strong>リボンの総長</strong>はどれだけですか？</p>
<details><summary>解説</summary><div>
<p>やはり要求どおりに計算するだけ。</p>
<pre><code class="language-haskell">part2 :: [(Int,Int,Int)]  -- l,w,h
      -&gt; Int              -- 答え
part2 = sum . map fun2

fun2 (l,w,h) = 2 * minimum rs + l * w * h
  where
    rs = [l + w, w + h, h + l]
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3日目真空中の完全球形住宅"><a class="header" href="#3日目真空中の完全球形住宅">3日目：真空中の完全球形住宅</a></h1>
<p>サンタは無限の2次元グリッド住宅街にプレゼントを届けています。</p>
<p>彼は出発地にある家にプレゼントを配達することから始めます。
北極にいる小人が無線で彼に連絡し、次にどこへ行くべきかを彼に伝えます。
移動は常にちょうど1軒隣の
北（<code>^</code>）、南（<code>v</code>）、東（<code>&gt;</code>）、西（<code>&lt;</code>）の家です。
それぞれの移動の後、彼は彼の新しい位置の家に次のプレゼントを届けます。</p>
<p>しかし、北極にいる小人は卵酒を少し飲み過ぎてしまったために指示が少しずれて、
その結果サンタがいくつかの家を複数回訪れてしまいました。
<strong>少なくとも1つ</strong>プレゼントを受けとる家は何軒ありますか？</p>
<p>例えば：</p>
<ul>
<li><code>&gt;</code> は2軒にプレゼントを届けます。
出発地に1つ、東に1つ。</li>
<li><code>^&gt;v&lt;</code> は四角く並んだ4軒にプレゼントを届けます。
彼の出発かつ終了地点の家には2度訪れます。</li>
<li><code>^v^v^v^v^v</code> は2軒の家だけにいる
非常に幸運な子どもたちにたくさんのプレゼントを届けます。</li>
</ul>
<details><summary>解説</summary><div>
<p>座標がどちらに広がるのか事前に予測できないので、配列で扱うのは難しい。
座標の集合で扱うと制約なく扱いやすい。</p>
<pre><code class="language-haskell">import qualified Data.Set as S

part1 :: String  -- 指示
      -&gt; Int     -- 答え
part1 = S.size . S.fromList . scanl step (0,0)

step (x,y) '^' = (pred x, y)
step (x,y) 'v' = (succ x, y)
step (x,y) '&lt;' = (x, pred y)
step (x,y) '&gt;' = (x, succ y)
</code></pre>
</div></details>
<h1 id="パート2-2"><a class="header" href="#パート2-2">パート2</a></h1>
<p>翌年、処理を高速化するために、
サンタは自分自身のロボット版である<strong>メカサンタ</strong>を作成しました。
彼と一緒にプレゼントを届けるためのものです。</p>
<p>サンタとメカサンタは同じ場所から出発し
（同じ出発地点の家に2つのプレゼントを配達する）、
卵酒を飲み過ぎたせいで去年と同じ行動計画を読み上げる小人の指示に基づいて<strong>交互に</strong>移動します。</p>
<p>今年は、何軒の家が<strong>少なくとも1つ</strong>のプレゼントを受け取りますか？</p>
<p>例えば：</p>
<ul>
<li><code>^v</code> は3軒にプレゼントを届けます。
サンタは北に行き、その後メカサンタが南に行くからです。</li>
<li><code>^&gt;v&lt;</code> は今回3軒にプレゼントを配達し、
サンタとメカサンタは彼らが始めた地点に戻ってきます。</li>
<li><code>^v^v^v^v^v</code> は今回11軒の家にプレゼントを届けます。
サンタは一方向に、メカサンタはそれと反対向きに向かって行きます。</li>
</ul>
<details><summary>解説</summary><div>
<p>入力を、サンタ用とメカサンタ用に分離した後はパート1と同じやり方で座標を得て、
合わせてから数えればよい。</p>
<pre><code class="language-haskell">part2 :: String  -- 指示
      -&gt; Int     -- 答え
part2 cs = S.size . S.fromList $ go cs1 ++ go cs2
  where
    cbs = zip cs $ cycle [True, False]
    cs1 = [c | (c, True ) &lt;- cbs]
    cs2 = [c | (c, False) &lt;- cbs]
    go = scanl step (0,0)
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4日目理想的な長靴下の詰め合わせ"><a class="header" href="#4日目理想的な長靴下の詰め合わせ">4日目：理想的な長靴下の詰め合わせ</a></h1>
<p>（原題は stocking stuffer で頭韻を踏んでいる）</p>
<p>サンタは
AdventCoins（<strong>bitcoins</strong>と非常によく似た何か）を<strong>マイニング</strong>する手助けを求めています。
経済的に先進的な全ての子供たちへのプレゼントにするのです。</p>
<p>それには、<strong>MD5</strong>ハッシュが<strong>16進数</strong>で少なくとも<strong>5つのゼロ</strong>で始まるようなものを見つける必要があります。
MD5ハッシュへの入力は何かの秘密鍵（パズル入力）に10進数の数字を続けたものです。
AdventCoinsをマイニングするために、
そのようなハッシュを生成するような最小の正の数（先行する零は付けずに1,2,3,…で）を見つける必要があります。</p>
<p>例えば：</p>
<ul>
<li>あなたの秘密鍵が<code>abcdef</code>のとき、その答は<code>609043</code>です。
というのは<code>abcdef609043</code>のMD5のハッシュは5つの零で始まり（<code>000001dbbfa...</code>）、またそうなる最小の数だからです。</li>
<li>あなたの秘密鍵が<code>pqrstuv</code>のとき、連結して5つの零で始まるMD5ハッシュを作る最小の数は<code>1048970</code>です。
つまり、<code>pqrstuv1048970</code>のMD5ハッシュは<code>000006136ef...</code>となります。</li>
</ul>
<p>あなたのパズル入力は<code>iwrupvqb</code>です。</p>
<details><summary>解説</summary><div>
<p>これを解くためだけにMD5ハッシュの計算を実装するのはつらいので、ライブラリの力を借りる。
<a href="https://ja.wikipedia.org/wiki/MD5">Wikipedia</a>を見ると、512ビット=64バイトが処理の単位なので、
この問題の入力はまるまる収まるだろう。</p>
<ul>
<li><a href="https://hackage.haskell.org/package/cryptohash-md5">cryptohash-md5</a></li>
<li><a href="https://hackage.haskell.org/package/pureMD5">pureMD5</a></li>
</ul>
<p>あたりを使えばよいだろう。</p>
<pre><code class="language-haskell">import qualified Data.ByteString.Char8 as BS
import qualified Crypto.Hash.MD5 as MD5

part1 :: String  -- 秘密鍵
      -&gt; Int     -- 答え
part1 sk = head
  [ i
  | i &lt;- [1..]
  , let digest = MD5.hash $ BS.pack $ sk ++ show i
  , fromEnum (BS.index digest 0) ==  0
  , fromEnum (BS.index digest 1) ==  0
  , fromEnum (BS.index digest 2) &lt;  16
  ]
</code></pre>
</div></details>
<h1 id="パート2-3"><a class="header" href="#パート2-3">パート2</a></h1>
<p>今度は6つの0で始まるようなものを見つけてください。</p>
<details><summary>解説</summary><div>
<p>パート1と変わらない。</p>
<pre><code class="language-haskell">part2 :: String  -- 秘密鍵
      -&gt; Int     -- 答え
part2 sk = head
  [ i
  | i &lt;- [1..]
  , let digest = MD5.hash $ BS.pack $ sk ++ show i
  , fromEnum (BS.index digest 0) == 0
  , fromEnum (BS.index digest 1) == 0
  , fromEnum (BS.index digest 2) == 0
  ]
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5日目彼はこれ用の小人研修生を持っていないのですか"><a class="header" href="#5日目彼はこれ用の小人研修生を持っていないのですか">5日目：彼はこれ用の小人研修生を持っていないのですか？</a></h1>
<p>(intern-elvesが何の駄洒落なのかわからない)</p>
<p>サンタは、テキストファイルの文字列がそれぞれ、
「いい」か「いやらしい」のどちらなのかを突き止める手助けを必要としています。</p>
<p><strong>いい文字列</strong>とは、以下の性質のすべてを有するものです。</p>
<ul>
<li>少なくとも3つの母音（<code>aeiou</code>のみ）が含まれている。
例えば<code>aei</code>, <code>xazegov</code>, <code>aeiouaeiouaeiou</code></li>
<li>少なくとも1つ、2回続けて現れる文字を含む。
例えば<code>xx</code>, <code>abcdde</code> (dd), <code>aabbccdd</code> (aa, bb, cc, dd)</li>
<li><code>ab</code>, <code>cd</code>, <code>pq</code>, <code>xy</code>を<strong>含まない</strong>。
それらが他の要件のいずれかの一部であっても例外ではない。</li>
</ul>
<p>いい文字列でない文字列は、いやらしい文字列です。</p>
<p>例えば：</p>
<ul>
<li><code>ugknbfddgicrmopn</code> はいい文字列です。
少なくとも3つの母音 (u...i...o...)と
続き文字 (...dd...)を含み、
許可されていない部分文字列を持っていません。</li>
<li><code>aaa</code> はいい文字列です。
少なくとも3つの母音と2つの文字を持つためです。
異なる規則で使用されている文字が重なっていてもかまいません。</li>
<li><code>jchzalrnumimnmhp</code> は続き文字がないのでいやらしい文字列です。</li>
<li><code>haegwjzuvuyypxyu</code> は文字列<code>xy</code>を含んでいるのでいやらしい文字列です。</li>
<li><code>dvszwmarrgswjxmb</code> は1つの母音しか含まれていないので、いやらしい文字列です。</li>
</ul>
<p>いい文字列はいくつありますか？</p>
<details><summary>解説</summary><div>
<p>いい文字列を判定する述語を作る。</p>
<p>「母音を3つ」は、<code>aaa</code> の例でもわかるように、同じ文字が3つでもよいので、数えればよい。</p>
<pre><code class="language-haskell">isVowel x = elem x &quot;aeiou&quot;

cond1 xs = 3 &lt; length (filter isVowel xs)
</code></pre>
<p>あと2つの条件のために、連続する2文字の全ての組を作っておく。</p>
<pre><code class="language-haskell">xys = zip xs (tail xs)
</code></pre>
<p>「続き文字を含む」とは、<code>xys</code> の中に、左右が等しいものがあるということになる。</p>
<pre><code class="language-haskell">cond2 xys = any (uncurry (==)) xys
</code></pre>
<p>特定の対を含まないとは、そのいずれも <code>xys</code> の中に現れないことである。</p>
<pre><code class="language-haskell">cond3 xys = all (\bad -&gt; notElem bad xys) [('a','b'),('c','d'),('p','q'),('x','y')]
</code></pre>
<p>入力から、これらすべてを満たす語の数を数える。</p>
<pre><code class="language-haskell">part1 :: [String]  -- 入力
      -&gt; Int       -- 答え
part1 = length . filter cond123

cond123 xs = cond1 xs &amp;&amp; cond2 xys &amp;&amp; cond3 xys
  where
    xys = zip xs (tail xs)
</code></pre>
</div></details>
<h1 id="パート2-4"><a class="header" href="#パート2-4">パート2</a></h1>
<p>サンタは自分のやり方の間違いに気がついて、
文字列が「いい」か「いやらしい」かを判断するより良いモデルに切り替えました。
古い規則はすべて明らかにばかげているので適用されません。</p>
<p>さて、いい文字列は、以下のすべての性質を持つものです。</p>
<ul>
<li>何らかの2つの文字の対が重ならずに二回またはそれ以上に現れます。
例えば<code>xyxy</code> (<code>xy</code>)や<code>aabcdefgaa</code> (<code>aa</code>)はこれにあてはまりますが、
<code>aaa</code>は<code>aa</code>が2度現れますが重なっているので違います。</li>
<li>間にちょうど1文字を挟んで同じ文字が繰り返すような並びが1回またはそれ以上に現れます。
例えば<code>xyx</code>, <code>abcdefeghi</code> (<code>efe</code>) のようなものです。
また<code>aaa</code>も該当します。</li>
</ul>
<p>例えば：</p>
<ul>
<li><code>qjhvhtzxzqqjkmpb</code>はいい文字列です。
2回出現する対<code>qj</code>と、1文字置いて繰り返される文字<code>zxz</code>があるためです。</li>
<li><code>xxyxx</code>はいい文字列です。
二重に現れる対と間に1文字置いて繰り返される文字があります。
両規則で使用されている文字が重なっていても構いません。</li>
<li><code>uurcxstgmygtbstg</code>
これには対(<code>tg</code>)はありますが、一文字置いた繰り返しがありませんので、いやらしい文字列です。</li>
<li><code>ieodomkazucvgmuy</code>
1文字置いた繰り返し文字がありますが(<code>odo</code>)、2回現れる対はありませんので、いやらしい文字列です。</li>
</ul>
<p>これらの新しい規則の下で、いい文字列はいくつありますか？</p>
<details><summary>解説</summary><div>
<p>前者の条件は、パート1の <code>xys</code> で考えると、直後の対は重なりがあるので、それを除いた以降に等しいものがあればよい。
全ての対について調べ、そのようなものが一つあればよい。</p>
<pre><code class="language-haskell">cond4 xs = any sub $ tails xys
  where
    xys = zip xs (tail xs)
    sub (xy : _ : xys) = elem xy xys
    sub _ = False
</code></pre>
<p>後者の条件は、<code>xys</code> と同様に対になる文字について判定すればよい。</p>
<pre><code class="language-haskell">cond5 xs = or $ zipWith (==) xs (drop 2 xs)
</code></pre>
<p>最後にまとめる。</p>
<pre><code class="language-haskell">part2 :: [String]  -- 入力
      -&gt; Int       -- 答え
part2 = length . filter cond5 . filter cond4
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6日目火災の危険性あり"><a class="header" href="#6日目火災の危険性あり">6日目：火災の危険性あり</a></h1>
<p>あなたのご近所さんがホリデーハウスデコレーションコンテストであなたを
毎年敗北させ続けるので、
\(1,000 \times 1,000\) グリッドに 100万本のライトを配備することに決めました。</p>
<p>さらに、あなたは今年、特にいい子でいたので、
理想的な照明を表示する構成の手順書をサンタからメールで受け取りました。</p>
<p>グリッド内のライトは、各方向に0から999の番号が付けられます。
四隅のライトはそれぞれ座標<code>0,0</code>、<code>0,999</code>、<code>999,999</code>、<code>999,0</code>となります。
各指示は
<code>turn on</code>（点灯）、<code>turn off</code>（消灯）、<code>toggle</code>（反転）
のいずれかです。
指示には、座標の対によりその操作を行う範囲（境界を含む）が含まれます。
各座標対は、長方形の対向する角を表します。
よって例えば <code>0,0 through 2,2</code> という座標対は、\(3 \times 3\) の正方形の9つのライトを指します。
すべてのライトはオフで始まります。</p>
<p>今年あなたのご近所さんに打ち勝つためには、
サンタから送られた手順書に従って、
あなたのライトを設定しさえすればよいのです。</p>
<p>例えば：</p>
<ul>
<li><code>turn on 0,0 through 999,999</code> はすべてのライトをオンにします。
（元からオンのものはオンのままです）。</li>
<li><code>toggle 0,0 through 999,0</code> 第1行の1000個のライトを反転します。
オンになっていたものをオフにし、オフになっていたものをオンにします。</li>
<li><code>turn off 499,499 through 500,500</code> 中央の4つのライトをオフにします。
（元からオフのものはオフのままです。）</li>
</ul>
<p>一通り指示書に従った後、<strong>点灯しているライトはいくつですか？</strong></p>
<details><summary>解説</summary><div>
<p>このように、妙に冗長な入力データを読み取る必要があるのもAoCの特徴。
指示の種類を表す列挙型と、範囲を表す座標の対を組にした指示の型を定義する。</p>
<pre><code class="language-haskell">data Cmd = LOff | LOn | LTgl
type Instr = (Cmd, ((Int,Int),(Int,Int)))
</code></pre>
<p>コンマで区切られた数字列を、二つの整数の対として読み込む補助関数を定義しておく。</p>
<pre><code class="language-haskell">csv :: String -&gt; (Int, Int)
csv xs = (read as, read bs)
  where
    (as, _:bs) = span (',' /=) xs
</code></pre>
<p>一行を読み込むには、まず <code>words</code> で分割し、2語めが何かで見分けると話が早い。
<code>toggle</code>だけ、左上座標がどこにあるかが違う。右下座標は常に末尾にある。</p>
<pre><code class="language-haskell">parse :: String -&gt; (Cmd, ((Int, Int), (Int, Int)))
parse xs =
  case w2 of
    &quot;on&quot;  -&gt; (LOn , (csv w3, xy9))
    &quot;off&quot; -&gt; (LOff, (csv w3, xy9))
    _     -&gt; (LTgl, (csv w2, xy9))
  where
    (_:w2:w3:ws) = words xs
    xy9 = csv (last ws)
</code></pre>
<p>入力データを読み込んで指示のリストに変換したら、\(1000 \times 1000\) の配列を作り、
指示通りにライトを操作して、最終結果を取り出せばよい。
ここで、<code>Data.Ix.range</code> を使うと、範囲の要素を列挙することが容易にできる。
その結果を <code>accumArray</code> で累積すれば結果が得られる。</p>
<pre><code class="language-haskell">import Data.Ix
import Data.Array

part1 :: [String] -&gt; Int
part1 ls = length $ filter id $ elems arr
  where
    arr = accumArray control1 False ((0,0),(999,999))
          [(xy, cmd) | l &lt;- ls, let (cmd, bnds) = parse l, xy &lt;- range bnds]

control1 :: Bool -&gt; Cmd -&gt; Bool
control1 _ LOn  = True
control1 _ LOff = False
control1 b LTgl = not b
</code></pre>
</div></details>
<h1 id="パート2-5"><a class="header" href="#パート2-5">パート2</a></h1>
<p>勝利パターンを実装し終わったとき、サンタからのメッセージを
古代ノルディック小人語から翻訳するときに間違えていたことに気付きました。</p>
<p>あなたが購入したライトグリッドには、実際には個々の明るさコントロールがありました。
各ライトは0以上の明るさを持ちます。ライトはすべて明るさ0で始まります。</p>
<p><code>turn on</code>というフレーズは実際には
あなたがそれらのライトの明るさを1増やすべきであることを意味します。</p>
<p><code>turn off</code>というフレーズは実際には
あなたがライトの明るさを1下げる必要があることを意味します。
その最小値は零です。</p>
<p><code>toggle</code>のフレーズは実際には
あなたがそれらのライトの明るさを2増やすべきであることを意味します。</p>
<p>サンタの指示に従った後に、すべてのライトの明るさを合わせた
<strong>明るさの合計値</strong>はいくつでしょう？</p>
<p>例えば：</p>
<ul>
<li><code>turn on 0,0 through 0,0</code>は合計値を1増加させます。</li>
<li><code>toggle 0,0 through 999,999</code>は合計値を2000000増加させます。</li>
</ul>
<details><summary>解説</summary><div>
<p>パート1では2値だったライトの状態を整数にし、指示に対する操作を定義通りに差し替えるだけ。</p>
<pre><code class="language-haskell">part2 :: [String] -&gt; Int
part2 ls = sum $ elems arr
  where
    arr = accumArray control2 0 ((0,0),(999,999))
          [(xy, cmd) | l &lt;- ls, let (cmd, bnds) = parse l, xy &lt;- range bnds]

control2 :: Int -&gt; Cmd -&gt; Int
control2 n LOn  = succ n
control2 n LOff = max 0 (pred n)
control2 n LTgl = n + 2
</code></pre>
<p>ちなみに、「二次元累積和」という手法を使うと、この問題の答えをずっと効率的に求めることができる。</p>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7日目組み立てが少々必要"><a class="header" href="#7日目組み立てが少々必要">7日目：組み立てが少々必要</a></h1>
<p>今年、サンタはボビー・テーブルス少年に
配線ワイヤとビット<strong>論理ゲート</strong>のセットを届けました！
残念ながら、Bobbyは推奨の年齢層より少し小さいので、
彼は回路を組み立てるのに助けが必要です。</p>
<p>各ワイヤは識別子（小文字アルファベット）を持ち、
16ビットの信号（0～65535の数）を伝えることができます。
各ワイヤには、ゲートまたは別のワイヤから信号が伝えられるか、定数値が与えられます。
各ワイヤは1つの信号源からのみ信号を得ることができますが、複数の接続先に信号を供給することができます。
ゲートは、その入力のすべてが信号を持つまで信号を供給しません。</p>
<p>付属の取扱説明書には、どのようにパーツを接続するかが書かれています。
<code>x AND y -&gt; z</code>は
ワイヤ<code>x</code>とワイヤ<code>y</code>を<code>AND</code>ゲートに接続し、
その出力をワイヤ<code>z</code>に接続することを意味します。</p>
<p>例えば：</p>
<ul>
<li><code>123 -&gt; x</code> は信号<code>123</code>がワイヤ<code>x</code>に供給されることを意味します。</li>
<li><code>x AND y -&gt; z</code> はワイヤ<code>x</code>とワイヤ<code>y</code>との<strong>ビット単位の論理積</strong>が
ワイヤ<code>z</code>に供給されることを意味します。</li>
<li><code>p LSHIFT 2 -&gt; q</code> はワイヤ<code>p</code>からの値が2だけ<strong>左シフト</strong>され、
そのワイヤ<code>q</code>に提供されることを意味します。</li>
<li><code>NOT e -&gt; f</code> はワイヤ<code>e</code>からの値の<strong>ビット単位の反転</strong>が
ワイヤ<code>f</code>に供給されることを意味します。</li>
</ul>
<p>他の使用可能なゲートには、<code>OR</code>（<strong>ビット単位OR</strong>）および<code>RSHIFT</code>（<strong>右シフト</strong>）があります。
何らかの理由で代わりに回路を<strong>エミュレート</strong>したい場合、
ほとんどすべてのプログラミング言語（C, JavaScript, Pythonなど）はこれらのゲートの演算子を提供しています。</p>
<p>例えば、ここには簡単な回路があります：</p>
<pre><code>123 -&gt; x
456 -&gt; y
x AND y -&gt; d
x OR y -&gt; e
x LSHIFT 2 -&gt; f
y RSHIFT 2 -&gt; g
NOT x -&gt; h
NOT y -&gt; i
</code></pre>
<p>それが実行された後、ワイヤ上の信号は次のようになります。</p>
<pre><code>d: 72
e: 507
f: 492
g: 114
h: 65412
i: 65079
x: 123
y: 456
</code></pre>
<p>ボビー少年のキットの説明書
（あなたのパズル入力として提供されている）
では、最終的にどのような信号が<strong>ワイヤ<code>a</code>に</strong>流れますか？</p>
<details><summary>解説</summary><div>
<p>状況を整理すると、
アルファベット文字列で名前の付けられたワイヤ（信号線）があり、入力で与えられる回路結線で内容が定められる。
ループになっていたり、ひとつの信号に複数の入力が与えられたりはしていない。
結線は、他のワイヤの内容を読み取り、論理演算を施すもの。
正則な計算でこのような相互参照を解決するのは面倒な話だが、遅延評価を使うと非常に簡潔に解ける。
（ループや矛盾がないという保証がある場合に限る。）</p>
<p>すなわち、ワイヤ名を添え字として、その値を計算してコンテナに格納するが、
値を計算するために他のワイヤを読み取るとき、コンテナに値を問い合わせる。</p>
<p>ひとつの配線が3項組 <code>([String], [Word16] -&gt; Word16, String)</code> で表されているとする。
第1要素は、参照しているワイヤ名、または定数の文字列のリスト。
第2要素は、参照した信号の内容を計算して、結果を返す演算を表す関数。
第3要素は、結果を供給する先のワイヤ名。
この情報のリストから、それぞれのワイヤに流れる信号を持つマップが次のように作れる。</p>
<pre><code class="language-haskell">import qualified Data.Map as M

type Instr = ([String], [Word16] -&gt; Word16, String)

part1Body :: [Instr] -&gt; M.Map String Word16
part1Body is = m
  where
    m = M.fromList [(tgt, f $ map g ws) | (ws, f, tgt &lt;- is)]
    g w
      | all isDigit w = read w
      | otherwise     = m M.! w
</code></pre>
<p>つまり、入力列から配線指示読み取ることができれば、<code>part1Body</code> の返すマップから答えは得られる。</p>
<pre><code class="language-haskell">part1 :: [String] -&gt; Word16
part1 ls = (part1Body $ map parse ls) M.! &quot;a&quot;
</code></pre>
<p>演算の名前がどこにあるのかは、語数からわかる。</p>
<pre><code class="language-haskell">import Data.Bits

parse :: String -&gt; Instr
parse xs =
  case length ws of
    3 -&gt; ([ws !! 0], \[x] -&gt; x, tgt)                  -- 123 -&gt; x
    4 -&gt; ([ws !! 1], \[x] -&gt; complement x, tgt)       -- NOT x -&gt; h
    5 -&gt; ([ws !! 0, ws !! 2], getFun $ ws !! 1, tgt)  -- x AND y -&gt; d
  where
    ws = words xs
    tgt = last ws

getFun &quot;AND&quot; = \[x,y] -&gt; x .&amp;. y
getFun &quot;OR&quot;  = \[x,y] -&gt; x .|. y
getFun &quot;LSHIFT&quot; = \[x,y] -&gt; shiftL x $ fromIntegral y
getFun &quot;RSHIFT&quot; = \[x,y] -&gt; shiftR x $ fromIntegral y
</code></pre>
</div></details>
<h1 id="パート2-6"><a class="header" href="#パート2-6">パート2</a></h1>
<p>今度は、ワイヤ<code>a</code>上にある信号を取り出し、
その信号をワイヤ<code>b</code>へ上書きし、
他のワイヤ（ワイヤ<code>a</code>を含む）をリセットします。
最終的にどのような新しい信号がワイヤ<code>a</code>に流れますか？</p>
<details><summary>解説</summary><div>
<p>パート1の結果は手元にあるので、<code>part1Body</code> の中の <code>g</code> に細工をするのが手っ取り早い。</p>
<pre><code class="language-haskell">part2 :: [String] -&gt; Word16
part2 ls = m M.! &quot;a&quot;
  where
    m = M.fromList [(tgt, f $ map g ws) | (ws, f, tgt) &lt;- map parse ls]
    g &quot;b&quot; = undefined -- パート1の結果をここに入れる
    g w
      | all isDigit w = read w
      | otherwise     = m M.! w
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="8日目マッチ棒"><a class="header" href="#8日目マッチ棒">8日目：マッチ棒</a></h1>
<p>今年はソリの容積が制限されているので、サンタはリストをデジタルコピーにして持ち込む予定です。
彼は、リストを保存したときどのくらいのメモリ容量を使うかを知る必要があります。</p>
<p>多くのプログラミング言語では、
文字列内の特殊文字をエスケープする方法を提供することが一般的です。
例えばC, JavaScript, Perl, Python, またPHPさえ特殊文字を非常に似た方法で扱います。</p>
<p>ただし、<strong>文字列リテラルのコード表現</strong>の文字数と
<strong>メモリ中の文字列自体の文字数</strong>の違いを理解することが重要です。</p>
<p>例えば：</p>
<ul>
<li><code>&quot;&quot;</code> はコード表現では2文字（2つのダブルクオート）ですが、文字列は文字を零個持ちます。</li>
<li><code>&quot;abc&quot;</code> はコード表現では5文字ですが、文字列データ内は3文字です。</li>
<li><code>&quot;aaa\&quot;aaa&quot;</code> はコード表現では10文字ですが、
文字列自体は6個の文字<code>a</code>と
エスケープされたダブルクオートを1文字持ち、
合わせて文字列データ内は7文字です。</li>
<li><code>&quot;\x27&quot;</code> はコード表現では6文字ですが、
文字列自体は16進表記を使用してエスケープしたアポストロフィ<code>'</code>1文字だけからなります。</li>
</ul>
<p>サンタのリストは、ダブルクオートで囲まれた文字列リテラルを各行に1つずつ含む大きなファイルです。
使用されるエスケープシーケンスは
<code>\\</code>（単一のバックスラッシュを表す）、
<code>\&quot;</code>（単独のダブルクオートを表す）、
<code>\x</code> に16進文字を2つ続けたもの（そのASCIIコードを持つ1文字を表す）
だけです。</p>
<p>ファイル内の空白を無視して、
ファイル全体で
<strong>文字列リテラルのコード表現での文字数</strong>から、
<strong>文字列データのメモリ中の文字数</strong>
を引いた値はいくらですか？</p>
<p>たとえば、上の4つの文字列を指定すると、
コード表現の文字列の総文字数 \(2 + 5 + 10 + 6 = 23\) から
文字列データのメモリ中の総文字数 \(0 + 3 + 7 + 1 = 11\) を引くと
\(23 - 11 = 12\) となります。</p>
<details><summary>解説</summary><div>
<p>行に対して、見た目の長さは <code>length</code> で数えられる。
表現される文字列を作るには、両端のダブルクオートを取り除いた後、
エスケープシーケンスを忠実に解釈すればできる。
（<code>\x</code>の後に16進数でない文字が来るような場合は考えない。）</p>
<pre><code class="language-haskell">import Data.Char

decode :: String -&gt; String
decode = loop . init . tail
  where
    loop ('\':'x':a:b:xs) = chr (digitToInt a * 16 + digitToInt b) : loop xs
    loop ('\':'\':xs) = '\' : loop xs
    loop ('\':'&quot;':xs) = '&quot;' : loop xs
    loop (x:xs) = x : loop xs
    loop [] = []

part1 :: [String] -&gt; Int
part1 ls = sum [length l - length (decode l) | l &lt;- ls]
</code></pre>
<p>生成後の文字列の長さだけ、直接計測することもできる。</p>
<pre><code class="language-haskell">decodeLen :: String -&gt; Int
decodeLen = loop (-2)
  where
    loop n ('\':'x':_:_:xs) = loop (succ n) xs
    loop n ('\':'\':xs) = loop (succ n) xs
    loop n ('\':'&quot;':xs) = loop (succ n) xs
    loop n (x:xs) = loop (succ n) xs
    loop n [] = n

part1 :: [String] -&gt; Int
part1 ls = sum [length l - decodeLen l | l &lt;- ls]
</code></pre>
</div></details>
<h1 id="パート2-7"><a class="header" href="#パート2-7">パート2</a></h1>
<p>では今度は逆をしましょう。
コード表現の文字列の文字数を求めることに加えて、
<strong>個々のコード表現を新しい文字列としてエンコード</strong>し、
新しいエンコードされた表現の文字数（ダブルクオートを含めて）を求めてください。</p>
<p>例えば：</p>
<ul>
<li><code>&quot;&quot;</code> は <code>&quot;\&quot;\&quot;&quot;</code> とエンコードされ、2文字から6文字に増加します。</li>
<li><code>&quot;abc&quot;</code> は <code>&quot;\&quot;abc\&quot;&quot;</code> とエンコードされ、5文字から9文字に増加します。</li>
<li><code>&quot;aaa\&quot;aaa&quot;</code> は <code>&quot;\&quot;aaa\\\&quot;aaa\&quot;&quot;</code> とエンコードされ、10文字から16文字に増加します。</li>
<li><code>&quot;\x27&quot;</code> は <code>&quot;\&quot;\\x27\&quot;&quot;</code> とエンコードされ、6文字から11文字に増加します。</li>
</ul>
<p>あなたの仕事は、<strong>新しくエンコードされた文字列を表すためち必要な文字の総数</strong>から、
<strong>それぞれの元の文字列リテラルのコード表現での文字数</strong>を引いたものを見つけることです。
たとえば、上記の文字列の場合、
コード化された長さ (\(6 + 9 + 16 + 11 = 42\)) から
元のコード表現の文字の長さ (このパズルの前半と同じ23) を差し引いた結果は
\(42 - 23 = 19\) です。</p>
<details><summary>解説</summary><div>
<p>生成する必要はなかった。</p>
<pre><code class="language-haskell">encodeLen :: String -&gt; Int
encodeLen = sum . map f
  where
    f '#' = 2
    f '\' = 2
    f  _  = 1

part2 :: [String] -&gt; Int
part2 ls = sum $ [encodeLen l - length l | l &lt;- ls]
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="9日目一晩で"><a class="header" href="#9日目一晩で">9日目：一晩で</a></h1>
<p>毎年、サンタは、一晩ですべてのプレゼントを配達します。</p>
<p>しかし、今年は新たに訪れる場所がいくつか増えました。
彼の小人は彼に場所のすべての対の間の距離を与えました。
彼は自分が望む任意の2つの（異なる）場所から出発して終了することができますが、
各場所をちょうど1回ずつ訪問する必要があります。
これを達成するための彼の移動する<strong>最短距離</strong>は何ですか？</p>
<p>たとえば、次の距離が与えられたとします。</p>
<pre><code>London to Dublin = 464
London to Belfast = 518
Dublin to Belfast = 141
</code></pre>
<p>したがって、可能なルートは次のとおりです。</p>
<pre><code>Dublin -&gt; London -&gt; Belfast = 982
London -&gt; Dublin -&gt; Belfast = 605
London -&gt; Belfast -&gt; Dublin = 659
Dublin -&gt; Belfast -&gt; London = 659
Belfast -&gt; Dublin -&gt; London = 605
Belfast -&gt; London -&gt; Dublin = 982
</code></pre>
<p>これらの中で最短のものはLondon -&gt; Dublin -&gt; Belfast = 605で、
この例に対する答は605です。</p>
<p>最短ルートの距離はどれくらいですか？</p>
<details><summary>解説</summary><div>
<p>都市間を飛び回る距離なので、どちら向きにも移動できる無向グラフと見なせる。
都市の数も大した事ないので、都市のリストの順列を生成し、その距離を求める。</p>
<p>まず読み取りを行う。</p>
<pre><code class="language-haskell">parse :: String -&gt; (String,String,Int)
parse xs = (ws !! 0, ws !! 2, read $ ws !! 4)
  where
    ws = words xs
</code></pre>
<p>読み取った距離は、都市名を昇順にしたペアをキーに、距離を値とするマップに入れておく。
また、順不同で都市名ペアから距離を取り出す補助関数も定義しておく。</p>
<pre><code class="language-haskell">import qualified Data.Map as M

-- ccds は parse の結果のリストとする
distMap :: M.Map (String,String) Int
distMap = M.fromList [(minMax c1 c2, d) | (c1,c2,d) &lt;- ccds]

distOf :: String -&gt; String -&gt; Int
distOf c1 c2 = distMap M.! minMax c1 c2

minMax :: Ord a =&gt; a -&gt; a -&gt; (a, a)
minMax a b = if a &lt;= b then (a,b) else (b,a)
</code></pre>
<p>順列は <code>Data.List.permutations</code> で生成できるし、自分で作っても大した手間ではない。</p>
<pre><code class="language-haskell">perms [] = [ [] ]
perms xs = [x:ys | x &lt;- xs, ys &lt;- perms $ delete x xs]
</code></pre>
<p>順列を作りだす元として、都市名のリストが必要。
重複を <code>nub</code> で除去する。</p>
<pre><code class="language-haskell">import Data.List

cities = nub [c | (c1,c2,_) &lt;- ccds, c &lt;- [c1,c2]]
</code></pre>
<p><code>perms cities</code> のそれぞれの結果の総距離を求める。</p>
<pre><code class="language-haskell">fullDist :: [String] -&gt; Int
fullDist cs = sum $ zipWith distOf cs (tail cs)
</code></pre>
<p>以上の流れを対話環境で実行してもいいし、IOアクションにまとめてもよい。</p>
<pre><code class="language-haskell">import qualified Data.Map as M
import Data.List

main1 = do
  co &lt;- readFile &quot;input.txt&quot;
  print $ part1 $ lines co

part1 ls = (minimum dps, maximum dps)
  where
    ccds = map parse ls
    distMap = M.fromList [(minMax c1 c2, d) | (c1,c2,d) &lt;- ccds]
    cities = nub [c | (c1,c2,_) &lt;- ccds, c &lt;- [c1,c2]]
    dps = [(fullDist cs, cs) | cs &lt;- permutations cities]
</code></pre>
</div></details>
<h1 id="パート2-8"><a class="header" href="#パート2-8">パート2</a></h1>
<p>翌年、見せびらかすために、逆にサンタは<strong>最長距離</strong>の経路を取ることにしました。</p>
<p>前回同様、
彼は自分が望む任意の2つの（異なる）場所から出発して終了することができますが、
各場所をちょうど1回ずつ訪問する必要があります。</p>
<p>例えば、上記の距離を考えると、
最長の経路は例えば Dublin -&gt; London -&gt; Belfastの982です。</p>
<p>最長ルートの距離はどれくらいですか？</p>
<details><summary>解説</summary><div>
<p>パート1でついうっかり最長の経路の距離まで求めてしまったら、
パート2ですることがなくなってしまった。</p>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10日目小人は見る小人は話す"><a class="header" href="#10日目小人は見る小人は話す">10日目：小人は見る、小人は話す</a></h1>
<p>今日、小人たちは
<a href="https://ja.wikipedia.org/wiki/%E8%AA%AD%E3%81%BF%E4%B8%8A%E3%81%92%E6%95%B0%E5%88%97">読み上げ数列</a>（
<a href="https://en.wikipedia.org/wiki/Look-and-say_sequence">look-and-say</a>）
というゲームをしています。
彼らは順番に前の列を朗読し、その読みを次の列として使用して列を作ります。
たとえば、<code>211</code>は「1つの2、2つの1」と読み、<code>1221</code>という列になります。</p>
<p>前回の値を次のステップの入力として使用して、look-and-sayの列は反復して生成されます。
各ステップについて、前回の値を取って、
<code>111</code>のようなそれぞれの同じ数字の並びを個数に続けてその数字そのもので置き換えます。</p>
<p>例えば：</p>
<ul>
<li><code>1</code>は<code>11</code>となります。（1つの数字の<code>1</code>）</li>
<li><code>11</code>は<code>21</code>に（2つの数字の1）</li>
<li><code>21</code>は<code>1211</code>に（1つの数字の2、1つの数字の1）</li>
<li><code>1211</code>は<code>111221</code>に（1つの1、1つの2、2つの1）</li>
<li><code>111221</code>は<code>312211</code>に（3つの1、2つの2、1つの1）</li>
</ul>
<p>パズル入力の数字から始めて、このプロセスを40回適用します。
<strong>結果の長さ</strong>はどれだけですか？</p>
<details><summary>解説</summary><div>
<p>入力は文字列として受け取り、1桁の数のリストで扱うことにする。</p>
<pre><code class="language-haskell">import Data.Char

part1 cs = ...
  where
    ds = map digitToInt cs
</code></pre>
<p><code>Data.List.group</code> で等しいものどうしに分割し、その長さを数える。
長さは10以上になりうるので、数リストに直接戻せないことに注意。</p>
<pre><code class="language-haskell">step :: [Int] -&gt; [Int]
step ds =
  [ e
  | ds1 &lt;- group ds
  , e &lt;- (map digitToInt $ show $ length ds1) ++ [head ds1]
  ]
</code></pre>
<p>40回繰り返した結果の長さを求める。</p>
<pre><code class="language-haskell">part1 cs = length ds40
  where
    ds0 = map digitToInt cs
    ds40 = iterate step ds0 !! 40
</code></pre>
</div></details>
<h1 id="パート2-9"><a class="header" href="#パート2-9">パート2</a></h1>
<p>すばらしい！わかった？
あなたは<a href="https://www.youtube.com/watch?v=ea7lJkEhytA">John Conwayのこの列に関する講演</a>
も楽しめるでしょう。
（<strong>Conwayのライフゲーム</strong>のConwayです。）</p>
<p>さて、もう一度あなたのパズル入力の数字で始めて、
このプロセスを<strong>50回</strong>適用してください。
<strong>新しい結果の長さ</strong>はどのくらいですか？</p>
<details><summary>解説</summary><div>
<p>Wikipediaの解説を見ると、
「1, 2, 3以外の数字は、シード番号にそのような数字または
同じ数字の3つを超えるランが含まれていない限り、シーケンスに現れない。」
とある。そんなことがあるのか。
それはともかく、特に計算量を節約する何かがあるわけでもなさそうなので、
ただ計算機をブン回す。</p>
<pre><code class="language-haskell">part2 cs = length ds50
  where
    ds0 = map digitToInt cs
    ds50 = iterate step ds0 !! 50
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11日目企業方針"><a class="header" href="#11日目企業方針">11日目：企業方針</a></h1>
<p>サンタの以前のパスワードは期限切れです。
新しいパスワードを選択するのに手助けが必要です。</p>
<p>古いパスワードが期限切れになった後に
新しいパスワードを覚えるのを助けるために、
サンタは前のパスワードに基づいてパスワードを設定する方法を考案しました。
企業の方針では、
セキュリティ上の理由からパスワードは全て小文字で
ちょうど8文字にする必要があるため、
古いパスワード文字列を有効になるまで
繰り返し<strong>インクリメント</strong>して新しいパスワードを探します。</p>
<p>インクリメントはちょうど数字で数えるようなものです。
<code>xx</code>, <code>xy</code>, <code>xz</code>, <code>ya</code>, <code>yb</code>, などと続きます。
一番右の文字を1つ次にしてください。
それが<code>z</code>であった場合は<code>a</code>に巻き戻り、
巻き戻りしなくなるまで左の次の文字について繰り返します。</p>
<p>サンタにとって残念なことに、新しいセキュリティ担当の小人が最近着任しました。
彼はいくつかの追加パスワード要求を課しています。</p>
<ul>
<li>パスワードは少なくとも3文字の連続したインクリメントした並びを一つ含む必要がある。
それは<code>abc</code>, <code>bcd</code>, <code>cde</code> から <code>xyz</code> までのようなものである。
文字をスキップすることはできない。<code>abd</code>はこれに含まれない。</li>
<li>パスワードには文字<code>i</code>, <code>o</code>, <code>l</code> を含めることはできない。
これらの文字は他の文字と間違える可能性があり、
したがって混乱する可能性があるためである。</li>
<li>パスワードは<code>aa</code>, <code>bb</code>, <code>zz</code>のような文字の対を、重なりなく別個に少なくとも2つ含む必要がある。</li>
</ul>
<p>例えば：</p>
<ul>
<li><code>hijklmmn</code> 第1の要件を満たしています。（インクリメント列<code>hij</code>が含まれています。）
しかし第2の要件に失敗しています。（<code>i</code>および<code>l</code>が含まれています。）</li>
<li><code>abbceffg</code> 第3の要件を満たしています。（<code>bb</code>と<code>ff</code>を繰り返しています。）
しかし第1の要件を満たしていません。</li>
<li><code>abbcegjk</code> 第3の要件に失敗します。なぜなら、二重文字がひとつ(<code>bb</code>)しかないからです。</li>
<li><code>abcdefgh</code>のパスワードは<code>abcdffaa</code>です。</li>
<li><code>ghijklmn</code>のパスワードは<code>ghjaabcc</code>です。
これは<code>i</code>が許されないために<code>ghi...</code>で始まるすべてのパスワードを結局スキップするためです。</li>
</ul>
<p>サンタの現在のパスワード（あなたのパズル入力）が与えられたとき、
彼の<strong>次のパスワード</strong>は何ですかか？</p>
<p>あなたのパズル入力は<code>hxbxwxba</code>です。</p>
<details><summary>解説</summary><div>
<p>繰り上がりありで列をインクリメントするには、逆順になっているとHaskell的には都合がよい。</p>
<pre><code class="language-haskell">incr ('z':cs) = 'a' : incr cs  -- 繰り上がり
incr ( c :cs) = succ c : cs
  | elem c &quot;iol&quot; = succ (succ c) : cs -- 禁止文字は飛ばす
  | otherwise    = succ       c  : cs
incr &quot;&quot; = &quot;&quot;
</code></pre>
<p>インクリメント列は、後ろからはデクリメント列に見える。</p>
<pre><code class="language-haskell">cond1 (c1:c2:c3:_) | succ c3 == c2 &amp;&amp; succ c2 == c1 = True
cond1 (_:cs) = cond1 cs
cond1 [] = False
</code></pre>
<p>禁止文字はインクリメントでは出現しないが、
初期文字の全ての禁止文字がインクリメントで消えるまで捨て続けるのも無駄になる。
禁止文字が全て消えた最初の文字列とは、元の順序で最も前にある禁止文字を次の文字にし、
それ以降を全て <code>a</code> にしたものである。これを構築することで条件2の判定に代える。</p>
<pre><code class="language-haskell">clearCond2 &quot;&quot; = &quot;&quot;
clearCond2 (c:cs)
  | elem c &quot;iol&quot; = succ c : map (const 'a') cs
  | otherwise    = c : clearCond2 cs
</code></pre>
<p>最後の例が <code>ghjaabaa</code> とならず <code>ghjaabcc</code> であることから、条件3の「別個」が厳しい意味であるとわかる？
そうでなくて、&quot;abc&quot;という続きが必要だ、という条件の方らしい。厳しくないのなら <code>nub</code> を消せばよい。</p>
<pre><code class="language-haskell">cond3 cs =
  case nub [c | (c,d) &lt;- zip cs $ tail cs, c == d] of
    (_:_:_) -&gt; True
    _       -&gt; False
</code></pre>
<p>全体をまとめる。</p>
<pre><code class="language-haskell">part1 :: String -&gt; String
part1 = reverse . until cond13 incr . reverse . clearCond2

cond13 xs = cond1 xs &amp;&amp; cond3 xs
</code></pre>
</div></details>
<h1 id="パート2-10"><a class="header" href="#パート2-10">パート2</a></h1>
<p>サンタのパスワードが再び期限切れになりました。次は何ですか？</p>
<details><summary>解説</summary><div>
<p>パート1の結果を <code>part1</code> にかけるだけで、コードの追加はない。</p>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12日目jsabacusframeworkio"><a class="header" href="#12日目jsabacusframeworkio">12日目：JSAbacusFramework.io</a></h1>
<p>サンタの会計担当小人は、最近の注文後の帳簿のバランスを取るのに手助けか必要です。
残念なことに、彼らの会計ソフトウェアは異様な記録形式を使用しています。
そんなところにあなたが来ました。</p>
<p>彼らはJSON文書を持っています。
それは様々なものを含んでいます。
配列(<code>[1,2,3]</code>)、オブジェクト(<code>{&quot;a&quot;:1, &quot;b&quot;:2}</code>)、数値、文字列です。
あなたの最初の仕事は、
文書全体からすべての数値を見つけてそれらを足し合わせることです。</p>
<p>例えば：</p>
<ul>
<li><code>[1,2,3]</code>と<code>{&quot;a&quot;:2,&quot;b&quot;:4}</code>は両方とも合計6です。</li>
<li><code>[[[3]]]</code>と<code>{&quot;a&quot;:{&quot;b&quot;:4},&quot;c&quot;:-1}</code>は両方とも合計3です。</li>
<li><code>{&quot;a&quot;:[-1,1]}</code>と<code>[-1,{&quot;a&quot;:1}]</code>は両方とも合計0です。</li>
<li><code>[]</code>と<code>{}</code>は両方とも合計0です。</li>
</ul>
<p>文字列に数字が含まれることはありません。</p>
<p>文書内の<strong>すべての数値</strong>の合計はいくつですか？</p>
<details><summary>解説</summary><div>
<p>JSONライブラリを使ってもいいが、この程度の構文は自分で読み込んでしまおう。
まず、JSONデータとは、数字列、ダブルクオートで囲まれた文字列、角括弧とコンマによる配列、
波括弧と文字列とコロンとコンマによるオブジェクトである。</p>
<pre><code class="language-haskell">import Text.Parsec
import Text.Parsec.Char

data JSON = JSONNum Int | JSONStr String | JSONList [JSON] | JSONObj [(String, JSON)] deriving Eq

numP :: Parsec String u JSON
numP = do
  s &lt;- option id (negate &lt;$ char '-')
  JSONNum . s . read &lt;$&gt; many1 digit

strP :: Parsec String u JSON
strP = JSONStr &lt;$&gt; between (char '&quot;') (char '&quot;') (many1 letter)

lstP :: Parsec String u JSON
lstP = JSONList &lt;$&gt; between (char '[') (char ']') (sepBy jsonP (char ','))

objP :: Parsec String u JSON
objP = JSONObj &lt;$&gt; between (char '{') (char '}') (sepBy colonedP (char ','))
  where
    colonedP = do
      k &lt;- between (char '&quot;') (char '&quot;') (many1 letter)
      char ':'
      v &lt;- jsonP
      return (k,v)

jsonP :: Parsec String u JSON
jsonP = choice [try numP, try strP, try lstP, objP]

allP :: Parsec String u JSON
allP = do
  j &lt;- jsonP
  eof
  return j
</code></pre>
<p><code>JSON</code>型の値が読み込めたら、走査して数値をすべて列挙し、それを足し合わせる。</p>
<pre><code class="language-haskell">traverse1 :: JSON -&gt; [Int]
traverse1 j = iter j []
  where
    iter (JSONNum n) rest = n : rest
    iter (JSONList js) rest = foldr iter rest js
    iter (JSONObj kvs) rest = foldr (iter . snd) rest kvs
    iter _ rest = rest

part1 = do
  co &lt;- readFile &quot;input.txt&quot;
  let Right j = runParser allP () &quot;&quot; co
  print $ sum $ traverse1 j
</code></pre>
</div></details>
<h1 id="パート2-11"><a class="header" href="#パート2-11">パート2</a></h1>
<p>あちゃー…会計担当小人は、彼らは赤字をすべて二重に数えたことに気付いた。</p>
<p>値<code>&quot;red&quot;</code>を持つ任意のプロパティを持つオブジェクト（およびそのすべての子）を無視します。
これはオブジェクト(<code>{...}</code>)だけで行い、配列(<code>[...]</code>)では行いません。</p>
<ul>
<li><code>[1,2,3]</code>はやはり合計6です。</li>
<li><code>[1,{&quot;c&quot;:&quot;red&quot;,&quot;b&quot;:2},3]</code>は中間のオブジェクトが無視されるため、今は合計4です。</li>
<li><code>{&quot;d&quot;:&quot;red&quot;,&quot;e&quot;:[1,2,3,4],&quot;f&quot;:5}</code>は構造体全体が無視されるため、今は合計0です。</li>
<li><code>[1,&quot;red&quot;,5]</code>は合計6です。配列中の<code>&quot;red&quot;</code>には何の効果もありません。</li>
</ul>
<details><summary>解説</summary><div>
<p>走査の際に、オブジェクトに遭遇した場合、値に <code>&quot;red&quot;</code> があれば0で戻るロジックを追加する。</p>
<pre><code class="language-haskell">traverse2 :: JSON -&gt; [Int]
traverse2 j = iter j []
  where
    iter (JSONNum n) rest = n : rest
    iter (JSONList js) rest = foldr iter rest js
    iter (JSONObj kvs) rest
      | elem (JSONStr &quot;red&quot;) vs = rest
      | otherwise               = foldr iter rest vs
      where
        vs = map snd kvs
    iter _ rest = rest
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13日目食卓の騎士"><a class="header" href="#13日目食卓の騎士">13日目：食卓の騎士</a></h1>
<p>この数年間、あなたの家族との休暇の饗宴はあまりうまくいっていませんでした。
皆が仲良しという訳にはいかないのです！
今年はそんな状況を変えようとあなたは決心しました。
<strong>最適な座席の配置</strong>を見つけ、それらの気まずい会話をすべてなくすつもりです。</p>
<p>あなたはまず招待したすべての人のリストと、
彼らが隣に誰が座っているときにその幸福度が増減する量を
すべての組み合わせについて書くことから始めました。
全員が快適にちょうど収まる大きさの円形テーブルがあなたの家にあり、
それぞれの人が2人の隣人を持つことになります。</p>
<p>たとえば、予定されている出席者が4人だけで、次のように幸福度を算出したとします。</p>
<pre><code>Alice would gain 54 happiness units by sitting next to Bob.
Alice would lose 79 happiness units by sitting next to Carol.
Alice would lose 2 happiness units by sitting next to David.
Bob would gain 83 happiness units by sitting next to Alice.
Bob would lose 7 happiness units by sitting next to Carol.
Bob would lose 63 happiness units by sitting next to David.
Carol would lose 62 happiness units by sitting next to Alice.
Carol would gain 60 happiness units by sitting next to Bob.
Carol would gain 55 happiness units by sitting next to David.
David would gain 46 happiness units by sitting next to Alice.
David would lose 7 happiness units by sitting next to Bob.
David would gain 41 happiness units by sitting next to Carol.
</code></pre>
<p>あなたがAliceをDavidの隣に着席させると、Aliceは幸せを2単位を失います。
（Davidがとてもおしゃべりなせいです。）
一方Davidは幸せを46単位得るでしょう。
（Aliceはとても良い聞き手だからです。）
合計で+44です。</p>
<p>テーブルを周って続けて、BobをAliceの隣に座らせるかもしれません。
（Bobは83得て、Aliceは54得る。）
最後にCarolを席に着かせて、隣はBob（Carolは60得て、Bobは7失う）とDavid（Carolは55得て、Davidは41得る）。
配置は次のようになります。</p>
<pre><code>     +41 +46
+55   David    -2
Carol       Alice
+60    Bob    +54
     -7  +83
</code></pre>
<p>この仮定のシナリオで、他のすべての座席配置を試すと、
これが最も最適であり、全体の幸せ度が330となることがわかります。</p>
<p>実際のゲストのリストに対する最適な座席配置における
<strong>幸せ度の合計</strong>はいくつですか？</p>
<details><summary>解説</summary><div>
<p>まずこのフォーマットの読み込みから始める必要がある。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">位置</th><th>内容</th></tr></thead><tbody>
<tr><td style="text-align: right">0</td><td>主語</td></tr>
<tr><td style="text-align: right">2</td><td>gain/lose</td></tr>
<tr><td style="text-align: right">3</td><td>幸せ度</td></tr>
<tr><td style="text-align: right">10</td><td>隣人</td></tr>
</tbody></table>
</div>
<p>この結果を保存するデータ構造を選ぶのに、本体でどう使うかを考える。
人の名前の順列を作り、隣同士のペアで幸せ度を集計する。
つまり、人の名前の（主語, 隣人）という対をキーとすればよいだろう。</p>
<pre><code class="language-haskell">parse :: String -&gt; ((String,String), Int)
parse xs = ((w0, init w10), (if w2 == &quot;gain&quot; then id else negate) (read w3))
  where
    [w0,_,w2,w3,_,_,_,_,_,_,w10] = words xs
</code></pre>
<p>ペアの左を集めて <code>nub</code> することで参加者一覧を得て、順列を作り、幸福度の合計を求める。
先頭の一人は固定して構わない。</p>
<pre><code class="language-haskell">import Data.List
import qualified Data.Map as M

main1 = do
  co &lt;- readFile &quot;input.txt&quot;
  print $ part1 $ lines co

part1 ls = maximum $ map score $ permutations ps
  where
    pqxs = map parse ls
    (p1:ps) = nub $ map (fst . fst) pqxs
    pqxm = M.fromList pqxs
    score ps = sum
      [pqxm M.! (p,q) + pqxm M.! (q,p) | (p,q) &lt;- zip (p1 : ps) (ps ++ [p1])]
</code></pre>
</div></details>
<h1 id="パート2-12"><a class="header" href="#パート2-12">パート2</a></h1>
<p>大騒ぎの中で、あなたは自分を座らせるのを忘れていたことに気づきます。</p>
<!-- そういやそうだ。ワロス。-->
<p>この点で、あなたは全体に対してかなり無関心であり、
隣に座っている人によってあなたの幸福度は実際のところ上がったり下がったりしません。
あなたは他の人についても、
誰もがあなたが隣に座っていることについて
同様に無関心である(ambivalent ?)と仮定します。</p>
<p>よって、自分自身をリストに追加して、
あなたに関係するすべての幸福関係にスコア0を与えてください。</p>
<!-- やり方バラしてるやん -->
<p>実際にあなた自身を含む最適な座席配置に対する<strong>幸せ度の合計</strong>はいくつですか？</p>
<details><summary>解説</summary><div>
<p>書いてあるとおりに求める。</p>
<pre><code class="language-haskell">main2 = do
  co &lt;- readFile &quot;input.txt&quot;
  print $ part2 $ lines co

part2 ls = maximum $ map score $ permutations ps
  where
    pqxs = map parse ls
    ps = nub $ map (fst . fst) pqxs
    pqxm = M.fromList $ pqxs ++ [(pq, 0) | p &lt;- ps, pq &lt;- [(&quot;me&quot;,p), (p,&quot;me&quot;)]]
    score ps = sum
      [pqxm M.! (p,q) + pqxm M.! (q,p) | (p,q) &lt;- zip (&quot;me&quot; : ps) (ps ++ [&quot;me&quot;])]
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14日目トナカイオリンピック"><a class="header" href="#14日目トナカイオリンピック">14日目：トナカイオリンピック</a></h1>
<p>今年はトナカイオリンピックです！
トナカイは高速で飛ぶことができますが、
エネルギーを回復するために時々休まなければなりません。
サンタは、彼のトナカイのどれが最速かを知りたいので、
彼はレースをさせます。(have one race?)</p>
<p>トナカイは<strong>飛行状態</strong>（常に最高速度）
または<strong>休息</strong>（全く動かない）のいずれかで、
すべての時間でいずれかの状態にあります。</p>
<p>たとえば、次のようなトナカイがあるとします。</p>
<ul>
<li>Cometは<strong>14km/sで10秒間</strong>飛行できますが、その後<strong>127秒間</strong>休む必要があります。</li>
<li>Dancerは<strong>16km/sで11秒間</strong>飛行できますが、その後は<strong>162秒間</strong>休む必要があります。</li>
</ul>
<p>1秒後、Cometは14km、Dancerは16km進みました。
10秒後、Cometは140km、Dancerは160km進みました。
11秒目に、Cometは休息を開始し（140kmに留まる）、Dancerは飛び続けて176kmまで進みます。
12秒目には、両方のトナカイが休息しています。
Comentがさらに10秒間飛ぼうとするまでの138秒目まで、
彼らは休み続けます。
174秒目に、Dancerは次の11秒間の飛行を開始します。</p>
<p>この例では、1000秒後に両方のトナカイが休息しており、
Cometが<strong>1120km</strong>で先行しています。
（この時点ではかわいそうなDancerは<strong>1056km</strong>しか進めていません。）
したがって、この状況ではComentが勝ちます（レースが1000秒で終了した場合）。</p>
<p>（あなたのパズル入力として）各トナカイの説明が与えられています。
ちょうど2503秒後に、<strong>優勝したトナカイはどれだけの距離を移動しましたか？</strong></p>
<details><summary>解説</summary><div>
<p>また読み込みから。</p>
<pre><code class="language-haskell">parse :: String -&gt; (Int,Int,Int)
parse xs = (read $ ws !! 3, read $ ws !! 6, read $ ws !! 13)
  where
    ws = words xs
</code></pre>
<p>(速度 \(s\)、飛行時間 \(t\)、休憩時間 \(u\)) というトナカイが \(D\) 秒飛ぶとき、
全体のサイクルを回せる回数 \(q\) と、最後のサイクルをさらにする秒数 \(r\) は
\((q,r) = \textrm{divMod}(D, t+u)\) である。
このとき飛行した時間の総計は \(q \, t + \min(t, r)\)となる。</p>
<pre><code class="language-haskell">main1 = do
  co &lt;- readFile &quot;input.txt&quot;
  print $ part1 2503 $ lines co

part1 time ls = maximum
  [ s * (q * t + min t r) | (s,t,u) &lt;- map parse ls, let (q,r) = divMod time (t + u)]
</code></pre>
</div></details>
<h1 id="パート2-13"><a class="header" href="#パート2-13">パート2</a></h1>
<p>トナカイが爆発的に動くのを見て、
サンタは自分が古い評価体系に満足していないと判断します。</p>
<p>代わりに、各秒の終わりに、
彼は現在首位であるトナカイに1点を与えます。
（同点一位のトナカイが複数いる場合は、全員がれぞれ1点を得ます。）
彼はもちろん、伝統的な2503秒の制限時間を守りました。
そうしないのは完全にばかげているからです。</p>
<p>上の例のトナカイを考えると、
最初の1秒後、Dancerが先行して1点を獲得します。
彼はComentの2回目の爆発までの数秒の間は先行しつづけます。
140秒後、Cometが先頭に立ち、最初の得点を獲得します。
もちろん、Dancerはそれまでの139秒間は先行していたので、
140秒めまでに139点を貯めています。</p>
<p>1000秒後、Dancerは<strong>689</strong>点を貯めていましたが、
以前の勝者であるかわいそうなCometは312点しか持っていません。
したがって、新しい評価体系ではDancerが勝利します（レースが1000秒で終了した場合）。</p>
<p>今回も（あなたのパズル入力の中の）各トナカイの説明が与えられたとき、
ちょうど2503秒後に、<strong>優勝したトナカイはどれだけの点を獲得しましたか？</strong></p>
<details><summary>解説</summary><div>
<p>それぞれのトナカイについて、次の1秒で進む距離（または0）のリストを作り、
これを累積することで各時刻の位置を作り、一位を選んで点数を付与する、を繰り返す。</p>
<pre><code class="language-haskell">import Data.List

main2 = do
  co &lt;- readFile &quot;input.txt&quot;
  print $ part2 2503 $ lines co

part2 time ls =
  maximum $ foldl1 (zipWith (+)) $
  map score2max $ take time $ transpose $
  [ scanl1 (+) $ cycle $ replicate t s ++ replicate u 0
  | (s,t,u) &lt;- map parse ls ]

score2max xs = [if m == x then 1 else 0 | x &lt;- xs]
  where
    m = maximum xs
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第15日飢えた人々のための科学"><a class="header" href="#第15日飢えた人々のための科学">第15日：飢えた人々のための科学</a></h1>
<p>今日あなたは牛乳浸しクッキーのレシピを完成させる作業を開始しました。
あなたがしなければならないことは、原材料の適切なバランスを見つけることだけです。</p>
<p>あなたのレシピは小さじちょうど100杯の原材料の余地が残っています。
<strong>レシピを完成させるために使用できる残りの原材料</strong>のリスト（パズルの入力）と
小さじ1杯ごとの特性値のリストを作成します。</p>
<ul>
<li><code>capacity</code> （容量：クッキーが牛乳を吸収するのをどれくらい助けるか）</li>
<li><code>durability</code> （耐久：牛乳でいっぱいになったときにクッキーをどのくらい崩れなく保つか）</li>
<li><code>flavor</code> （風味：クッキーをどれだけ美味しくするか）</li>
<li><code>texture</code> （口当たり：クッキーの感触をどれだけよくするか）</li>
<li><code>calories</code> （栄養価：クッキーに追加されるカロリーの量）</li>
</ul>
<p>あなたは原材料を小さじ1杯単位でのみ量り取ることができ、
また今後も結果を再現できるように正確でなければなりません。
クッキーの<strong>総合点</strong>は、
特性値をそれぞれ合算して（負の合計は0となる）、
カロリー以外のすべてを掛け合わせることで得られます。</p>
<p>たとえば、次の2つの原材料があるとします。</p>
<pre><code>Butterscotch: capacity -1, durability -2, flavor 6, texture 3, calories 8
Cinnamon: capacity 2, durability 3, flavor -2, texture -1, calories 3
</code></pre>
<p>すると、バタースコッチを小さじ44杯とシナモンを小さじ56杯使う
（各原材料の量は合計して100になる必要があります）
ことを選択すると、
以下の特性値を有するクッキーが得られます。</p>
<ul>
<li>容量 \(44 \times (-1) + 56 \times 2 = 68\)</li>
<li>耐久 \(44 \times (-2) + 56 \times 3 = 80\)</li>
<li>風味 \(44 \times 6 + 56 \times (-2) = 152\)</li>
<li>口当たり \(44 \times 3 + 56 \times (-1) = 76\)</li>
</ul>
<p>これらを掛け合わせると（\(68 \times 80 \times 152 \times 76\), ここではカロリーは無視します）、
総合点<code>62842880</code>が得られます。
これはこれらの原材料が与えられたときに可能な最高得点です。
いずれかの特性値が負の合計を生成した場合は、
それは零になるので、掛け合わせることで総合点が零になります。</p>
<p>あなたの台所にある原材料その特性値が与えられたとき、
作ることができる最高得点のクッキーの<strong>総合点</strong>はいくらですか？</p>
<details><summary>解説</summary><div>
<p>場合の数が相当になるがともかく、全ての配分を作り出す。
あとk種類の材料で合計wを作る。</p>
<pre><code class="language-haskell">recipe 1 w = [[w]]
recipe k 0 = [replicate k 0]
recipe k w = [ x : ys | x &lt;- [0..w], ys &lt;- recipe (pred k) (w - x)]
</code></pre>
<p>配列DPにすると、重複した呼び出しを節約できる。</p>
<pre><code class="language-haskell">import Data.Array
import Data.Ix

-- numは材料の種類の数
mkRecipe num = recipeA ! (num, 100)
  where
    bnds = ((1,0), (num,100))
    recipeA = array bnds [(kw,recipeF kw) | kw &lt;- range bnds]
    recipeF (1,w) = [[w]]
    recipeF (k,0) = [replicate k 0]
    recipeF (k,w) = [x : ys | x &lt;- [0..w], ys &lt;- recipeA ! (pred k, w - x)]
</code></pre>
<p>材料ごとに、その特性値がリストのリスト(<code>list</code>)で与えられているとして、
<code>recipes</code>の各要素について使用量を掛けて足し合わせ、0で足切りした合計を（カロリーを除いて）求め、
その最大値を見つければよい。</p>
<pre><code class="language-haskell">part1 list recipes =
  maximum
    [ product $ map (max 0) $ init $ foldl1' (zipWith (+)) $ zipWith (\r ps -&gt; map (r *) ps) re list
    | re &lt;- recipes ]
</code></pre>
<p>このようにリストを読み込む。</p>
<pre><code class="language-haskell">parse :: String -&gt; [Int]
parse xs = map read (map init [cap,dur,fvr,tex] ++ [cal])
  where
    [_,_,cap,_,dur,_,fvr,_,tex,_,cal] = words xs

main1 = do
  co &lt;- readFile &quot;input.txt&quot;
  let list = map parse $ lines co
  let recipes = mkRecipe $ length list
  print $ part1 list recipes
</code></pre>
</div></details>
<h1 id="パート2-14"><a class="header" href="#パート2-14">パート2</a></h1>
<p>あなたのクッキーレシピは大人気になりました！</p>
<p>クッキーひとつがちょうど500カロリーを持つ
別のレシピを作ることができるかどうかを尋ねられました。
（そうすると彼らは食事の代わりとしてそれを使用することができます。）
残りのあなたの受賞歴のあるプロセスは同じにしてください。
（小さじ100杯、同じ材料、同じ採点システム）</p>
<p>例えば、上の材料を考えれば、
代わりに小さじ40杯のバタースコッチと小さじ60杯のシナモンを選択した場合、
（やはり合計で100杯になる必要があります）
合計カロリーは \($40 \times 8 + 60 \times 3 = 500$になります。
ただし総合点はたった57600000に下がります。
これはこの試行中の状況でできる最高値です。</p>
<p>あなたの台所にある原材料とその特性値が与えられたとき、</p>
<p>を考えると、あなたがの
500カロリーで作ることができる
最高得点のクッキーの<strong>総合点</strong>はいくらですか？</p>
<details><summary>解説</summary><div>
<p>スコアを求める内包表記を改造して、カロリー500のもの限定にする。</p>
<pre><code class="language-haskell">part2 list recipes =
  maximum
    [ product $ map (max 0) $ init vals
    | re &lt;- recipes
    , let vals = foldl1' (zipWith (+)) $ zipWith (map . (*)) re list
    , last vals == 500
    ]
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="16日目スーおばさん"><a class="header" href="#16日目スーおばさん">16日目：スーおばさん</a></h1>
<p>あなたのスーおばさんはあなたに素晴らしい贈り物をくれました。
そこであなたは彼女に感謝の手紙を送りたいのです。
しかし、ちょっとした問題があります。
彼女は「スーおばさんより」と記名していました。</p>
<p>あなたには「スー」という名前のおばが500人います。</p>
<p>だから、間違った人に手紙を送るのを避けるために、
あなたはどのスーおばさん
（あなたは自分の正気を保つために便宜上1から500の番号を付けています）
があなたに贈り物をしたのかを知る必要があります。
あなたは贈り物を開けます。なんと運のいいことでしょう。
古きよきスーおばさんはあなたにマイファースト犯罪現場分析機をくれました！
まさにあなたが欲しいもの、あるいは必要なもの、です。</p>
<p>マイファースト犯罪現場分析機
（My First Crime Scene Analysis Machine, 略してMFCSAM）は、
与えられたサンプル中のいくつかの特定の化合物、
およびそれらの化合物の種類がいくつあるかを検出することができます。
説明書によると、MFCSAMが検出できるものは以下のとおりです。</p>
<ul>
<li><code>children</code>（子供） 人間のDNA年齢分析ができます。</li>
<li><code>cats</code>（猫） 個々の品種は区別できません。</li>
<li>いくつかの一見ランダムな犬の品種：
<code>samoyeds</code>（サモエド）, <code>pomeranians</code>（ポメラニアン）,
<code>akitas</code>（秋田犬）, <code>vizslas</code>（ショートヘアード・ハンガリアン・ビズラ）</li>
<li><code>goldfish</code>（金魚）それ以外の魚は検出できません。</li>
<li><code>trees</code> （木）1つのグループにまとめられています。</li>
<li><code>cars</code>（車）おそらく排気ガスかガソリンか何かによって。</li>
<li><code>perfumes</code>（香水）あなたのスーおばさんの多くはいくつかを付けているので、これは便利です。</li>
</ul>
<p>実際には、あなたのスーおばさんの多くはこれらの多くを持っています。
あなたは贈り物の包装をMFCSAMに入れました。
それはあなたに数回不思議にビープ音を鳴らしてから
紙テープ(ticker tape)にメッセージをプリントアウトします。</p>
<pre><code>children: 3
cats: 7
samoyeds: 2
pomeranians: 3
akitas: 0
vizslas: 0
goldfish: 5
trees: 3
cars: 2
perfumes: 1
</code></pre>
<p>あなたはそれぞれのスーおばさんについて、思い出せたもののリストを作ります。
あなたのリストには欠けているものは、
あなたが単に数を覚えていなかいということで、
ゼロだという意味ではありません。</p>
<p>あなたに贈り物をしたスーおばさんの<strong>番号</strong>はいくつですか？</p>
<details><summary>解説</summary><div>
<p>物の名前と、整数が対になっている。
思い出したメモの内容で、MFCSAMの情報と矛盾がないものを選択する。
おばさんの情報は <code>Data.Map.Map String Int</code> の形式で扱う。</p>
<pre><code class="language-haskell">import qualified Data.Map as M
import Data.Maybe

mfcsam =
  [(&quot;children:&quot;,3),(&quot;cats:&quot;,7),(&quot;samoyeds:&quot;,2),(&quot;pomeranians:&quot;,3),(&quot;akitas:&quot;,0)
  ,(&quot;vizslas:&quot;,0),(&quot;goldfish:&quot;,5),(&quot;trees:&quot;,3),(&quot;cars:&quot;,2),(&quot;perfumes:&quot;,1)]

part1 aunts = [id | (id, aunt) &lt;- zip [1..] aunts, all (check aunt) mfcsam]

check aunt (k,v) = maybe True (v ==) $ M.lookup k aunt

parse xs = M.fromList $ loop ws
  where
    ws = drop 2 $ words xs
    loop [k,v] = [(k, read v)] -- 最後だけコンマがないため
    loop (k:v:ws) = (k, read $ init v) : loop ws

main1 = do
  co &lt;- readFile &quot;input.txt&quot;
  let aunts = map parse $ lines co
  print $ part1 aunts
</code></pre>
</div></details>
<h1 id="パート2-15"><a class="header" href="#パート2-15">パート2</a></h1>
<p>あなたがお礼状を送ろうとしたそのとき、
MFCSAMの説明書の中の何かがあなたの目を引きます。</p>
<p>どうやら、それは旧式のテム＝レイサーキット
（原文では<a href="https://www.youtube.com/watch?v=RXJKdh1KZ0w">retroencabulator</a>, <a href="https://en.wikipedia.org/wiki/Turboencabulator">Wikipedia</a>）
を使っているため、機械からの出力は正確な値ではありません。
それらのいくつかは範囲を示しています。</p>
<p>特に、<code>cats</code>と<code>trees</code>の読み取り値は、
それ<strong>より多く</strong>のものがあることを示しています
（猫のフケと木の花粉の予測できない核崩壊のため）、
一方<code>pomeranians</code>と<code>goldfish</code>の読み取り値は、
それ<strong>より少ない</strong>ことを示しています
（磁気抵抗のモード相互作用による） 。
(modial?)</p>
<p>本物のスーおばさんの<strong>番号</strong>は何でしょう？</p>
<details><summary>解説</summary><div>
<p>比較関数を妥当なものに交換しつつ検査する形に変更する。</p>
<pre><code class="language-haskell">part2 =
  [ id
  | (id, aunt) &lt;- zip [1..] aunts
  , all (check   aunt) mfcsamEQ
  , all (checkLT aunt) mfcsamLT
  , all (checkGT aunt) mfcsamGT]

checkLT aunt (k,v) = maybe True (v &gt;) $ M.lookup k aunt
checkGT aunt (k,v) = maybe True (v &lt;) $ M.lookup k aunt

mfcsamEQ = [(&quot;children:&quot;,3),(&quot;samoyeds:&quot;,2),(&quot;akitas:&quot;,0)
           ,(&quot;vizslas:&quot;,0),(&quot;cars:&quot;,2),(&quot;perfumes:&quot;,1)]
mfcsamLT = [(&quot;pomeranians:&quot;,3),(&quot;goldfish:&quot;,5)]
mfcsamGT = [(&quot;cats:&quot;,7),(&quot;trees:&quot;,3)]

main2 = readFile &quot;input.txt&quot; &gt;&gt;= print . part2 . map parse . lines
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="17日目多くていけないものはない"><a class="header" href="#17日目多くていけないものはない">17日目：多くていけないものはない</a></h1>
<p>小人はまたもや卵酒を買いすぎました、今度は150リットル。
それをすべてあなたの冷蔵庫に収めるには、小さな容器に移す必要があります。
あなたは利用可能な容器の容量のリストを書きます。</p>
<p>たとえば、あなたが20, 15, 10, 5, 5リットルの容器を持っているとします。
25リットルを保管する必要がある場合は、4つの方法があります。</p>
<ul>
<li>15と10</li>
<li>20と5（ひとつめの5）</li>
<li>20と5（ふたつめの5）</li>
<li>15, 5, 5</li>
</ul>
<p>使う容器はいっぱいにして使うという条件で、
150リットルの卵酒をちょうど収める
<strong>容器の異なる組み合わせ</strong>
はいくつありますか？</p>
<details><summary>解説</summary><div>
<p>入力の容器の個数は20個あるので、その総当たりの組み合わせは \(2^20 = 1,048,576\) と少々多い。
（力任せにやれないこともないが。）</p>
<p>容器を順に追加して、xxリットルを量る方法の通り数を数えるDPを行う。
最初は「0リットルを量る方法は1とおり」から、
\(x\) リットルの容器を追加したとき、既知の方法に \(+x\) した方法が足しこまれる。</p>
<pre><code class="language-haskell">import qualified Data.IntMap as IM

part1 xs = IM.findWithDefault 0 150 im
  where
    im = foldl step (IM.singleton 0 1) xs
    step im x = IM.unionWith (+) im $ IM.mapKeysMonotonic (x +) im

main1 = readFile &quot;input.txt&quot; &gt;&gt;= print . part1 . map read . lines
</code></pre>
</div></details>
<h1 id="パート2-16"><a class="header" href="#パート2-16">パート2</a></h1>
<p>台所のあるだけの容器で遊んでいる間に、卵酒の別の配達が到着しました！
出荷部門と受入部門は、できるだけ多くの容器を使えるようにしておくことを求めています。</p>
<p>150リットルの卵酒をぴったり入れられる容器の最小数を見つけてください。
その数の容器をいっぱいにしてちょうど150リットルを保持できる<strong>方法はいくつありますか？</strong></p>
<p>上記の例では、容器の最小数は2です。
その数の容器をを使用する方法は3とおりあり、
よって答は3となります。</p>
<details><summary>解説</summary><div>
<p>マップで記録することがらを、単なる場合の数でなく、
使う容器の個数ごとの場合の数のリストに変更する。</p>
<pre><code class="language-haskell">part2 xs = (length as, b) -- 答えは snd、fstは使う容器の個数
  where
    im = foldl step (IM.singleton 0 [1]) xs
    step im x = IM.unionWith (zipWith1 (+)) im $ IM.mapKeysMonotonic (x +) $ IM.map (0 :) im
    (as,b:_) = span (0 ==) $ IM.findWithDefault [] 150 im

zipWith1 :: (a-&gt;a-&gt;a) -&gt; [a] -&gt; [a] -&gt; [a]
zipWith1 _ xs [] = xs
zipWith1 _ [] ys = ys
zipWith1 f (x:xs) (y:ys) = f x y : zipWith1 f xs ys

main2 = readFile &quot;input.txt&quot; &gt;&gt;= print . part2 . map read . lines
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="18日目あなたの庭のgifアニメ"><a class="header" href="#18日目あなたの庭のgifアニメ">18日目：あなたの庭のGIFアニメ</a></h1>
<p>100万灯ライト事件の後、防火条例がより厳しくなりました。
今では許されるのは1万本までのライトです。
あなたはそれを \(100 \times 100\) の碁盤状に並べました。</p>
<p>あなたを失望させることは絶対にありません、
サンタは今回も理想的な照明の構成の手順をメールであなたに送りました。
それほど少ない数のライトでは、彼の言うには、
<strong>アニメーション</strong>の力を借りる必要があるとのことです。</p>
<p>同封した初期状態（あなたのパズル入力）にライトを構成して始めます。
<code>#</code>は点灯、<code>.</code>は消灯を表します。</p>
<p>そして、ステップであなたのグリッドをアニメーションさせてください。
各ステップでは現在の構成に基づいて次の構成を決定します。
それぞれのライトの次の状態（点灯または消灯）は
その現在の状態とそれに隣接（斜めも含む）する8個のライトの
現在の状態に依存しています。
グリッドの縁にあるライトは隣人が8より少ないですが、欠けている部分は常に消灯として数えます。</p>
<p>例えば、下の単純化した6x6のグリッドで、
<code>A</code>と印したライトは1から8の隣人を持ちますが、
<code>B</code>と印したライトは縁にあるので、1から5の隣人しかありません。</p>
<pre><code>1B5...
234...
......
..123.
..8A4.
..765.
</code></pre>
<p>ライトの次の状態は現在の状態（点灯または消灯）と
<strong>点灯している隣人の数</strong>に基づいて決まります。</p>
<ul>
<li><strong>点灯</strong>しているライトは
点灯している隣人が2または3であるとき点灯を続け、
さもなくば消灯します。</li>
<li><strong>消灯</strong>しているライトは
点灯している隣人がちょうど3のとき点灯し、
さもなくば消灯し続けます。</li>
</ul>
<p>すべてのライトは同時に更新されます。
ライトはみな同じ現在の状態で考えて次の状態に動きます。</p>
<p>6x6グリッドの構成例での動作ステップを示します。</p>
<p>初期状態：</p>
<pre><code>.#.#.#
...##.
#....#
..#...
#.#..#
####..
</code></pre>
<p>1ステップ後：</p>
<pre><code>..##..
..##.#
...##.
......
#.....
#.##..
</code></pre>
<p>2ステップ後：</p>
<pre><code>..###.
......
..###.
......
.#....
.#....
</code></pre>
<p>3ステップ後：</p>
<pre><code>...#..
......
...#..
..##..
......
......
</code></pre>
<p>4ステップ後：</p>
<pre><code>......
......
..##..
..##..
......
......
</code></pre>
<p>4ステップ後、この例は4つのライトが点灯しています。</p>
<p>あなたの100x100のライトで、与えられた初期構成で、
<strong>100ステップ後にはいくつのライトが点灯していますか？</strong></p>
<details><summary>解説</summary><div>
<p>せっかくなので、どんなイルミネーションになるのか鑑賞しながら100ステップ進めるプログラムを作りましょう。</p>
</div></details>
<h1 id="パート2-17"><a class="header" href="#パート2-17">パート2</a></h1>
<p>あなたは手順書をペラっとめくりました。
サンタからのメッセージの続きに、これは単にConwayのライフゲームの実装に過ぎないという指摘がありました。
少なくとも、購入したライトのグリッドに問題があることに気づくまでは。
4つの角に1つずつあるライトが<strong>点灯しっぱなし</strong>で消灯できません。
上記の例は、実際には次のようになります。</p>
<p>初期状態：</p>
<pre><code>##.#.#
...##.
#....#
..#...
#.#..#
####.#
</code></pre>
<p>1ステップ後：</p>
<pre><code>#.##.#
####.#
...##.
......
#...#.
#.####
</code></pre>
<p>2ステップ後：</p>
<pre><code>#..#.#
#....#
.#.##.
...##.
.#..##
##.###
</code></pre>
<p>3ステップ後：</p>
<pre><code>#...##
####.#
..##.#
......
##....
####.#
</code></pre>
<p>4ステップ後：</p>
<pre><code>#.####
#....#
...#..
.##...
#.....
#.#..#
</code></pre>
<p>5ステップ後：</p>
<pre><code>##.###
.##..#
.##...
.##...
#.#...
##...#
</code></pre>
<p>5ステップ後、この例では17ライトが点灯しています。</p>
<p>あなたの100x100のライトで、与えられた初期構成で、
ただし角の4つのライトは常に<strong>点灯</strong>しているとき、
<strong>100ステップ後にはいくつのライトが点灯していますか？</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="19日目ルドルフのための薬"><a class="header" href="#19日目ルドルフのための薬">19日目：ルドルフのための薬</a></h1>
<p>赤鼻のトナカイのルドルフは病気です！
彼の鼻はあまり明るく輝いていません、
そして彼は薬を必要としています。</p>
<p>赤鼻のトナカイ生物学は通常のトナカイ生物学と似ていません。
ルドルフは特製の薬を必要とするでしょう。
残念なことに、赤鼻のトナカイ化学も通常のトナカイ化学と似ていません。</p>
<p>北極には赤鼻のトナカイ核融合・核分裂プラントが装備されており、
必要なあらゆる赤鼻のトナカイ分子を構築することができます。
それはいくつかの入力分子から始めて、
それからそれが正しい分子を持つまでステップごとに1つの、
一連の<strong>置換</strong>をすることによって働きます。</p>
<p>ただし、この装置は使用する前に校正する必要があります。
校正は、与えられた出発点から1ステップで生成され得る分子の数を決定することで行います。</p>
<p>たとえば、以下の置換のみに対応した、ずっと単純な装置を想像してみてください。</p>
<pre><code>H =&gt; HO
H =&gt; OH
O =&gt; HH
</code></pre>
<p>上記の置換が与えられ、<code>HOH</code>から始めると、
次のような分子が生成される可能性があります。</p>
<ul>
<li><code>HOOH</code> （1番目の<code>H</code>に<code>H =&gt; HO</code>）</li>
<li><code>HOHO</code> （2番目の<code>H</code>に<code>H =&gt; HO</code>）</li>
<li><code>OHOH</code> （1番目の<code>H</code>に<code>H =&gt; OH</code>）</li>
<li><code>HOOH</code> （2番目の<code>H</code>に<code>H =&gt; OH</code>）</li>
<li><code>HHHH</code> （<code>O =&gt; HH</code>）</li>
</ul>
<p>よって、上記の例では、<code>HOH</code>からの1回の置換の後に、
<strong>4種類</strong>の異なる分子があります。
（<code>HOOH</code>が2回出現するため5種類ではありません。）
サンタのお気に入りの分子<code>HOHOHO</code>は、
（<code>H</code>から6つ、<code>O</code>から3つの9個の置換を経て）
<strong>7種類</strong>の分子になることができます。</p>
<p>装置は周囲の文字を無視して置換します。
たとえば、文字列<code>H2O</code>が与えられると、遷移<code>H =&gt; OO</code>により<code>OO2O</code>となります。</p>
<p>あなたのパズル入力はすべての可能な置換について説明しています。
そして最下部に、あなたが装置を校正するのに必要な薬品分子があります。
薬品分子に1つの置換を行うことができるすべてのさまざまな方法の後に、
<strong>何種類の異なる分子を作成することができますか？</strong></p>
<details><summary>解説</summary><div>
<p>原子記号は大文字1文字または大文字1文字+小文字1文字でひとつなので、原子記号一つをひとつの整数で扱うように読み込む。</p>
<pre><code class="language-haskell">import Data.Char

encode :: String -&gt; [Int]
encode (c1:c2:cs) | isLower c2 = ord c1 * 256 + ord c2 : encode cs
encode (c:cs) = ord c1 : encode cs
encode &quot;&quot; = []

parse :: String -&gt; (Int,[Int])
parse xs = (head $ parse w1, parse w3)
  where
    [w1,_,w3] = words xs
</code></pre>
<p>初期列に対して可能な置き換えを行った全ての結果を作る。
規則の左辺は重複があるので注意。</p>
<pre><code class="language-haskell">part1 rules molec0 = S.size s
  where
    rs = IM.fromListWith (++) [(l,[r]) | (l,r) &lt;- rules]
    (_, s) = foldr step ([], S.empty) molec0

    step elem (elems, s) = (elem:elems, S.union s1 $ S.map (elem :) s)
      where
        s1 = S.fromList [es ++ elems | es &lt;- IM.findWithDefault [] elem rs]
</code></pre>
</div></details>
<h1 id="パート2-18"><a class="header" href="#パート2-18">パート2</a></h1>
<p>これで装置は校正されたので、分子製造を始める準備が整いました。</p>
<p>分子製造は、常に単一の電子だけから始まります。
そして校正のときと同様に、一度にひとつの置換を適用します。</p>
<p>たとえば、次のような置換があるとします。</p>
<pre><code>e =&gt; H
e =&gt; O
H =&gt; HO
H =&gt; OH
O =&gt; HH
</code></pre>
<p><code>HOH</code>を作成したいならば、<code>e</code>から始め、次のように置換します。</p>
<ul>
<li><code>e =&gt; O</code> これは<code>O</code>を得るため</li>
<li><code>O =&gt; HH</code> これは<code>HH</code>を得るため</li>
<li><code>H =&gt; OHH</code> （2番目の<code>H</code>に）これで<code>HOH</code>を得る</li>
</ul>
<p>よって、<strong>3ステップ</strong>で<code>HOH</code>を作ることができます。
サンタの好きな分子<code>HOHOHO</code>は<strong>6ステップ</strong>で作ることができます。</p>
<p>薬を作るのにどれくらいかかりますか？
あなたのパズル入力にある
利用可能な<strong>置換</strong>と<strong>薬の分子</strong>を考えるとき、
<code>e</code>から薬の分子に行くための<strong>最小のステップ数</strong>はいくつですか？</p>
<details><summary>解説</summary><div>
<p>前向きな計算はどう考えても発散するので、目標から還元して電子1つに戻す。
また、規則は優しく作られていて、端から貪欲に書き換えを行えばよいと仮定して試す。
（もしこれがうまくいかないと、書き換えできる位置を見逃す形で深さ優先探索するコードが必要になる。）</p>
<p>規則の右辺の先頭文字をキーにして規則を分類しておく。</p>
<pre><code class="language-haskell">rulesM = IM.fromListWith (++) [(head r, [lr]) | lr@(_,r) &lt;- rules]
</code></pre>
<p>右畳み込みで、新たに繋がる文字をキーにして規則表を調べ、その中で実際に適合する規則を逆向きに適用した結果の一覧を作る。
変換を一度行ったら、それ以降は規則を調べず、残りの文字の連結につとめる。</p>
<pre><code class="language-haskell">-- m は新たな文字、msはその続きのこれまでの文字列
ms1 = m : ms
reps =
  [ l : drop (length r) ms1
  | (l,r) &lt;- IM.findWithDefault [] m rulesM
  , isPrefixOf r ms1
  ]
</code></pre>
<p><code>reps</code>が要素1ならその書き換えを実行、空リストなら書き換えずに次の文字へ、要素が複数あるなら失敗で落とす。
また、一度書き換えを行ったら、それを覚えるフラグによって、以降は書き換えをしないで抜ける。</p>
<pre><code class="language-haskell">-- molec が書き換え対象の列全体
(molec1, acted) = foldr step ([], False) molec
step m (ms, True) = (m:ms, True)
step m (ms, False)
  | null reps      = (m:ms, False)
  | singleton reps = (head reps, True)
  | otherwise      = error (show reps)
  where
    ms1 = ...
    reps = ...
</code></pre>
<p>書き換えが起きたなら繰り返し、さもなくば終了する。</p>
<pre><code class="language-haskell">loop cnt molec
  | acted = print (length molec1) &gt;&gt; loop (succ cnt) molec1
  | otherwise  = print (&quot;end&quot;, molec, cnt) &gt;&gt; return ()
  where
    ...
</code></pre>
<p>幸い、これで電子までさかのぼることができた。</p>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="20日目無限の小人と無限の家"><a class="header" href="#20日目無限の小人と無限の家">20日目：無限の小人と無限の家</a></h1>
<p>小人たちを忙しくしておくために、サンタは彼らにいくつかのプレゼントを
ドアからドアへ、手渡しで配達させます。
サンタは小人たちを
順に番号が1,2,3,4,5…と振られている家が無限に並ぶ通りに
送り込みました。</p>
<p>各小人にも番号が割り当てられており、
その番号に基づいて家にプレゼントを配達します。</p>
<ul>
<li>1番目の小人（1番）はすべての家にプレゼントを配達します。1, 2, 3, 4, 5, …</li>
<li>2番目の小人（2番）はひとつおきの家にプレゼントを配達します。2, 4, 6, 8, 10, …</li>
<li>3番目の小人はふたつおきのすべての家にプレゼントを配達します。3, 6, 9, 12, 15, …</li>
</ul>
<p>1で始まる番号が付けられた無数の小人がいます。
各小人は家ごとに自分の数の10倍に相当するプレゼントを配達します。</p>
<p>よって、通りの最初の9つの家は最終的に次のようになります。</p>
<pre><code>House 1 got 10 presents.
House 2 got 30 presents.
House 3 got 40 presents.
House 4 got 70 presents.
House 5 got 60 presents.
House 6 got 120 presents.
House 7 got 80 presents.
House 8 got 150 presents.
House 9 got 130 presents.
</code></pre>
<p>1番目の家はプレゼント10個受け取ります。
それはプレゼントを \(1 \times 10\) 個届ける1番の小人によってのみ訪問されます。
4番目の家は番号1,2,4の小人が訪れているので、
合計で \(10 + 20 + 40 = 70\) 個のプレゼントを受け取ります。</p>
<p>あなたのパズル入力の数と少なくとも同じだけの数のプレゼントを得る家の、
<strong>最も小さい家番号</strong>は何番ですか？</p>
<p>あなたのパズル入力は36000000です。</p>
<details><summary>解説</summary><div>
<p>家番号 \(N\) が \(a\) の倍数であるとき、プレゼントを \(10a\) 受け取る、
その総和が目標を超えるような最小の \(N\) を見つけたい。
家番号 \(N\) に、小人 \(N\) は必ず訪問するので、 \(N \leq 3,600,000\) が上限。</p>
<pre><code class="language-haskell">import Data.Array.Unboxed

theInput :: Int
theInput = 36000000
theInput10 = div theInput 10

part1 = head $ filter ((theInput10 &lt;=) . snd) $ assocs arr
  where
    arr :: UArray Int Int
    arr = accumArray (+) 1 (1,theInput10)
          [(j, i) | i &lt;- [2 .. theInput10], j &lt;- [i, i+i .. theInput10]]
</code></pre>
<p>探索範囲を倍々に増やしながら答えを見つけるまで続けるようなコードにすることもできる。</p>
<pre><code class="language-haskell">part1a = loop 1 100
  where
    loop lb ub
      | null ans = loop (succ ub) (min theInput (ub * 2))
      | otherwise = head ans
      where
        arr :: UArray Int Int
        arr = accumArray (+) 1 (lb,ub)
          [(j, i) | i &lt;- [2..ub], let j0 = i * divrup lb i, j &lt;- [j0, j0+i .. ub]]
        ans = filter ((theInput10 &lt;=) . snd) $ assocs arr

-- 切り上げ除算
divrup x y = negate $ div (negate x) y
</code></pre>
<p>こちらの方が少し速く完了する。</p>
</div></details>
<h1 id="パート2-19"><a class="header" href="#パート2-19">パート2</a></h1>
<p>小人たちは無限の数の家を訪れたくないと考えました。
代わりに、小人はそれぞれ50軒にプレゼントを配達した後に停止します。
それを補うために、
彼らは各家で自分の番号の11倍に相当するプレゼントを届けることにしました。</p>
<p>これらの変更により、
あなたのパズル入力の数と少なくとも同じ数のプレゼントを得る家の
新しい<strong>最小の家番号</strong>は何番ですか？</p>
<details><summary>解説</summary><div>
<p>家番号 \(K\) に訪れる小人の番号は \(K\) 以下である。
\(K=1\) から順に、小人 \(K\) の配達まで済ませた状況を作り、家 \(K\) の個数を確認する。
目標に達していなければさらに次に進む。このとき、\(K\) 以下の家の状況は今後更新されないので捨ててよい。</p>
<pre><code class="language-haskell">import qualified Data.IntMap as IM

part2 = loop 1 IM.empty
  where
    loop k im
      | n &gt;= theInput = (k, n)
      | otherwise     = loop (succ k) im1
      where
        ((k1, n), im1) =
          IM.deleteFindMin $
          IM.unionWith (+) im $
          IM.fromDistinctAscList $
          [(i, 11 * k) | i &lt;- map (k *) [1 .. 50]]
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21日目rpgシミュレータ20xx"><a class="header" href="#21日目rpgシミュレータ20xx">21日目：RPGシミュレータ20XX</a></h1>
<p>Little Henry Caseがクリスマス用の新しいビデオゲームを手に入れました。
それはRPGです、そして、彼はボスで立ち往生しています。
彼は店でどんな装備を買うべきかを知る必要があります。
彼はあなたにコントローラーを渡します。</p>
<p>このゲームでは、プレイヤー（あなた）と敵（ボス）が交互に攻撃します。
常にプレイヤーが最初に行動します。
各攻撃は相手のヒットポイントを少なくとも1減少させます。
先にヒットポイント0以下になったキャラクターが負けます。</p>
<p>各ターンに攻撃側によって与えられるダメージは、
攻撃側のダメージスコアから防御側のアーマースコアを引いたものになります。
攻撃者は常に少なくとも1ダメージを与えます。
したがって、攻撃側のダメージスコアが8で、
防御側のアーマースコアがである3場合、
防御側は5ヒットポイントを失います。
防御側のアーマースコアが300であれば、
防御側は依然として1ヒットポイントを失います。</p>
<p>あなたのダメージスコアとアーマースコアは両方ともゼロから始まります。
それらは金と引き換えにアイテムを購入することで増やすことができます。
始めあなたはアイテムなしで、お金はいくらでも必要なだけ持っています。
あなたの総ダメージスコアやアーマースコアは
あなたのアイテム全てからのそれらの属性値の合計になります。
あなたは<strong>100ヒットポイント</strong>を持っています。</p>
<p>これがアイテムショップで売っているものです。</p>
<pre><code>Weapons:    Cost  Damage  Armor
Dagger        8     4       0
Shortsword   10     5       0
Warhammer    25     6       0
Longsword    40     7       0
Greataxe     74     8       0

Armor:      Cost  Damage  Armor
Leather      13     0       1
Chainmail    31     0       2
Splintmail   53     0       3
Bandedmail   75     0       4
Platemail   102     0       5

Rings:      Cost  Damage  Armor
Damage +1    25     1       0
Damage +2    50     2       0
Damage +3   100     3       0
Defense +1   20     0       1
Defense +2   40     0       2
Defense +3   80     0       3
</code></pre>
<p>あなたは武器を一つだけ購入しなければなりません。二刀流ではありません。
防具はオプションですが、複数使用することはできません。
あなたは0～2個の指輪を購入することができます（両手にそれぞれ最大1個）。
あなたはあなたが買ったアイテムを全て使わなければなりません。
ショップには各アイテムが1つしかないので、
例えばダメージ+3の指輪を2つ買うことはできません。</p>
<p>たとえば、あなたは8ヒットポイント、5ダメージスコア、5アーマースコアを持ち、
ボスは12ヒットポイント、7ダメージスコア、2アーマースコアを持つとします。</p>
<ul>
<li>プレイヤーは \(5-2 = 3\) ダメージを与えます。ボスは9ヒットポイントになります。</li>
<li>ボスは \(7-5 = 2\) ダメージを与えます。プレイヤーは6ヒットポイントになります。</li>
<li>プレイヤーは \(5-2 = 3\) ダメージを与えます。ボスは6ヒットポイントになります。</li>
<li>ボスは \(7-5 = 2\) ダメージを与えます。プレイヤーは4ヒットポイントになります。</li>
<li>プレイヤーは \(5-2 = 3\) ダメージを与えます。ボスは3ヒットポイントになります。</li>
<li>ボスは \(7-5 = 2\) ダメージを与えます。プレイヤーは2ヒットポイントになります。</li>
<li>プレイヤーは \(5-2 = 3\) ダメージを与えます。ボスは0ヒットポイントになります。</li>
</ul>
<p>このシナリオでは、（かろうじて）プレイヤーが勝ちます！</p>
<p>あなたは<strong>100ヒットポイント</strong>を持っています。
ボスの実際の属性値はあなたのパズルの入力にあります。
あなたが使う<strong>最小の、それでも戦いに勝つことができる金額</strong>はいくらですか？</p>
<details><summary>解説</summary><div>
<p>お買い物の全ての場合を数え上げてみる。</p>
<p>武器はひとつだけ選んで購入する。</p>
<pre><code class="language-haskell">weapon &lt;- [(8,4.0),(10,5,0),(25,6,0),(40,7,0),(74,8,0)]
</code></pre>
<p>防具はひとつだけ選んで購入するか、使わないでもよい。</p>
<pre><code class="language-haskell">armor &lt;- [(0,0,0),(13,0,1),(31,0,2),(53,0,3),(75,0,4),(102,0,5)]
</code></pre>
<p>指輪は二つまで使える。</p>
<pre><code class="language-haskell">rings = [(25,1,0),(50,2,0),(100,3,0),(20,0,1),(40,0,2),(80,0,3),(0,0,0)]
(ring1:rs) &lt;- tails rings
ring2 &lt;- if null rs then [ring1] else rs
</code></pre>
<p>総当たりの組み合わせを、費用の安い順にする。</p>
<pre><code class="language-haskell">cags = sort
  [ weapon `add` armor `add` ring1 `add` ring2
  | weapon &lt;- ...]
add (a,b,c) (d,e,f) = (a+d,b+e,c+f)
</code></pre>
<p>自分のHP、攻撃力、防御力を \(h_1 = 100, a_1, g_1\)、
ボスのそれを \(h_2, a_2, g_2\) とする。</p>
<p>こちらの攻撃1回で削るHP量は \(\max(1, a_1-g_2)\) で、
ボスを倒すまでかかるターン数は \(\lceil \frac{h_2}{\max(1, a_1 - g_2)} \rceil\) である。</p>
<p>ボスからの攻撃1回で削られるHP量は \(\max(1, a_2-g_1)\) で、
耐えるターン数は \(\lceil \frac{h_1}{\max(1, a_1-g_2)} \rceil\) である。</p>
<p>結局、この戦いに勝つ条件は
\(\lceil \frac{h_1}{\max(1, a_1 - g_2)} \rceil \geq \lceil \frac{h_2}{\max(1, a_1 - g_2)} \rceil\)
となる。</p>
<pre><code class="language-haskell">win a1 g1 = divrup h1 (max 1 (a2 - g1)) &gt;= divrup h2 (max 1 (a1 - g2))

h2 = ...
a2 = ...
g2 = ... -- 入力データ

part1 = head $ filter (\(_,a1,g1) -&gt; win a1 g1) cags
</code></pre>
</div></details>
<h1 id="パート2-20"><a class="header" href="#パート2-20">パート2</a></h1>
<p>店主がボスと通じていることが判明しました。
店主はそうしたいものを何でも、あなたに買うように説得することができます。
他の規則はまだ適用され、彼はやはり各アイテムを1つずつしか持っていません。</p>
<p>あなたが使う<strong>最大の、それでも戦いに負けることになる金額</strong>はいくらですか？</p>
<details><summary>解説</summary><div>
<p>つまり上の逆順に、負ける最大の金額を探せばよい。</p>
<pre><code class="language-haskell">part2 = head $ filter (\(_,a1,g1) -&gt; not $ win a1 g1) $ reverse cags
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22日目魔法使いシミュレータ-20xx"><a class="header" href="#22日目魔法使いシミュレータ-20xx">22日目：魔法使いシミュレータ 20XX</a></h1>
<p>Little Henry Caseは、刀や杖でボスを倒すのは退屈だと判断しました。
今、彼は魔法使いでゲームをしています。
もちろん、彼は別のボスに立ち往生しているし、もう一度あなたの助けが必要です。</p>
<p>このバージョンでは、プレイヤーとボスが交互に交代しながら戦闘が進行します。
プレイヤーはやはり先に行動します。
しかし今、あなたは装備を持っていません。
代わりに、あなたは唱えるためにあなたの呪文の1つを選ばなければなりません。
先にヒットポイント0以下になったキャラクターが負けます。</p>
<p>あなたは魔法使いなので、あなたは鎧を着ることができず、
あなたは普通に攻撃することはできません。
しかし、あなたは<strong>魔法のダメージを与える</strong>ので、
あなたの対戦相手の装甲は無視され、そのためボスも事実上装甲は零です。
以前のように、（この場合、呪文からの）装甲がダメージを1未満に減少させるのであれば、
それは代わりに1になります。
つまり、ボスの攻撃は常に少なくとも1ダメージを与えます。</p>
<p>あなたの各ターンに、
あなたは唱えるためにあなたの呪文の一つを選ぶ必要があります。
呪文を唱える余裕がない場合、あなたは負けます。
呪文は<strong>マナ</strong>を消費します。
あなたは<strong>500</strong>マナから始めますが、上限はありません。
あなたは呪文を唱えるのに十分なマナを持っていなければならず、
あなたがそれを唱えたときにそのコストは即座に差し引かれます。
あなたの呪文はマジックミサイル、ドレイン、シールド、ポイズン、リチャージです。</p>
<ul>
<li><strong>マジックミサイル</strong>は53マナかかります。即座に4ダメージを与えます。</li>
<li><strong>ドレイン</strong>は73マナがかかります。
それは即座に2ダメージを与え、2ヒットポイントを回復します。</li>
<li><strong>シールド</strong>は113マナがかかります。
それは6ターン持続する<strong>効果</strong>を開始します。
それがアクティブになっている間、あなたのアーマースコアは7増加します。</li>
<li><strong>ポイズン</strong>は173マナかかります。
それは6ターン持続する<strong>効果</strong>を開始します。
それがアクティブである間、各ターンの開始時に、それはボスに3ダメージを与えます。</li>
<li><strong>リチャージ</strong>は229マナかかります。
それは5ターン持続する<strong>効果</strong>を開始します。
それがアクティブになっている間、各ターンの開始時に、
それはあなたに新しいマナを101与えます。</li>
</ul>
<p><strong>効果</strong>はすべて同じように機能します。
効果はプレイヤーのターンとボスのターンの両方の開始時に適用されます。
効果はタイマー（それらが持続するターン数）を伴って作成されます。
各ターンの開始時に、彼らが持っている効果を適用した後、
それらのタイマーは1減少する。
これによりタイマーが零になると、効果は終了します。
あなたはすでにアクティブになっている効果を開始する呪文を唱えることはできません。
ただし、効果はそれらが終了するのと同じターンに開始することができます。</p>
<p>たとえば、プレイヤーに10ヒットポイントと250マナがあり、
ボスに13ヒットポイントと8ダメージがあるとします。</p>
<pre><code>-- Player turn --
- Player has 10 hit points, 0 armor, 250 mana
- Boss has 13 hit points
Player casts Poison.

-- Boss turn --
- Player has 10 hit points, 0 armor, 77 mana
- Boss has 13 hit points
Poison deals 3 damage; its timer is now 5.
Boss attacks for 8 damage.

-- Player turn --
- Player has 2 hit points, 0 armor, 77 mana
- Boss has 10 hit points
Poison deals 3 damage; its timer is now 4.
Player casts Magic Missile, dealing 4 damage.

-- Boss turn --
- Player has 2 hit points, 0 armor, 24 mana
- Boss has 3 hit points
Poison deals 3 damage. This kills the boss, and the player wins.
</code></pre>
<p>それでは、
ボスが代わりに14ヒットポイントを持っていることを除いて、
同じ初期条件を仮定します。</p>
<pre><code>-- Player turn --
- Player has 10 hit points, 0 armor, 250 mana
- Boss has 14 hit points
Player casts Recharge.

-- Boss turn --
- Player has 10 hit points, 0 armor, 21 mana
- Boss has 14 hit points
Recharge provides 101 mana; its timer is now 4.
Boss attacks for 8 damage!

-- Player turn --
- Player has 2 hit points, 0 armor, 122 mana
- Boss has 14 hit points
Recharge provides 101 mana; its timer is now 3.
Player casts Shield, increasing armor by 7.

-- Boss turn --
- Player has 2 hit points, 7 armor, 110 mana
- Boss has 14 hit points
Shield's timer is now 5.
Recharge provides 101 mana; its timer is now 2.
Boss attacks for 8 - 7 = 1 damage!

-- Player turn --
- Player has 1 hit point, 7 armor, 211 mana
- Boss has 14 hit points
Shield's timer is now 4.
Recharge provides 101 mana; its timer is now 1.
Player casts Drain, dealing 2 damage, and healing 2 hit points.

-- Boss turn --
- Player has 3 hit points, 7 armor, 239 mana
- Boss has 12 hit points
Shield's timer is now 3.
Recharge provides 101 mana; its timer is now 0.
Recharge wears off.
Boss attacks for 8 - 7 = 1 damage!

-- Player turn --
- Player has 2 hit points, 7 armor, 340 mana
- Boss has 12 hit points
Shield's timer is now 2.
Player casts Poison.

-- Boss turn --
- Player has 2 hit points, 7 armor, 167 mana
- Boss has 12 hit points
Shield's timer is now 1.
Poison deals 3 damage; its timer is now 5.
Boss attacks for 8 - 7 = 1 damage!

-- Player turn --
- Player has 1 hit point, 7 armor, 167 mana
- Boss has 9 hit points
Shield's timer is now 0.
Shield wears off, decreasing armor by 7.
Poison deals 3 damage; its timer is now 4.
Player casts Magic Missile, dealing 4 damage.

-- Boss turn --
- Player has 1 hit point, 0 armor, 114 mana
- Boss has 2 hit points
Poison deals 3 damage. This kills the boss, and the player wins.
</code></pre>
<p>あなたは<strong>50ヒットポイント</strong>と<strong>500マナポイント</strong>から始めます。
ボスの実際の属性値はあなたのパズルの入力にあります。
あなたが使うことができ、それでも戦いに勝てる<strong>マナの最小量</strong>は何ですか？
（リチャージの効果を負のマナを「支出する」として含めないでください。）</p>
<h1 id="パート2-21"><a class="header" href="#パート2-21">パート2</a></h1>
<p>次回のゲームでは、難易度を「ハード」に上げます。</p>
<p>各<strong>プレイヤーターン</strong>の開始時（他の効果が適用される前）に、
あなたは1ヒットポイントを失います。
これで0ヒットポイント以下になった場合、あなたは負けます。</p>
<p>あなたとボスの開始属性値は上と同じで、
あなたが使うことができて、まだ戦いに勝つことができる<strong>マナの最小量</strong>は何ですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="23日目チューリングロックを開く"><a class="header" href="#23日目チューリングロックを開く">23日目：チューリングロックを開く</a></h1>
<p>Little Jane Marieはとある篤志家からクリスマスに彼女の最初のコンピュータを贈られました。
説明書とサンプルプログラムが付属していますが、コンピュータ自体が誤動作しているようです。
彼女はそのプログラムが何をするのか知りたがっているので、
彼女がそれを実行するのをあなたに手伝ってほしいのです。</p>
<p>このマニュアルでは、
コンピュータが2つのレジスタと6つの命令をサポートしていると説明しています。
（本当に、読者に確認しておくと、これは最新技術です。）
レジスタには<code>a</code>と<code>b</code>という名前が付けられ、負でない整数を保持できます。
値が0の状態で始まります。
命令は次のとおりです。</p>
<ul>
<li><code>hlf r</code> レジスタrを現在の値の<strong>半分に</strong>設定してから、次の命令に進みます。</li>
<li><code>tpl r</code> レジスタrを現在の値の<strong>3倍に</strong>設定してから、次の命令に進みます。</li>
<li><code>inc r</code> レジスタrを<strong>インクリメント</strong>する、すなわちそれに1を足して、次の命令に進みます。</li>
<li><code>jmp offset</code> は<strong>ジャンプ</strong>です。
それはそれ自身に対して相対的に<code>offset</code>離れた命令に進みます。</li>
<li><code>jie r, offset</code> は<code>jmp</code>に似ていますが、
レジスタrが偶数の場合にのみジャンプします。
（jump if even 「偶数の場合はジャンプ」）</li>
<li><code>jio r, offset</code> は<code>jmp</code>に似ていますが、
レジスタrが1の場合にのみジャンプします。
（jump if one 「1であればジャンプ」「奇数」ではないので注意。）</li>
</ul>
<p>3つのジャンプ命令はすべて、その命令に対する相対的<strong>オフセット</strong>で機能します。
オフセットは常にジャンプの方向を示す接頭辞<code>+</code>または<code>-</code>を付けて
（それぞれ順方向または逆方向）書かれます。
例えば、<code>jmp +1</code>は単に次の命令に進むだけで、
<code>jmp +0</code>は継続的にそれ自体に永遠に戻ります。</p>
<p>プログラムは、定義されている命令を超えて命令を実行しようとすると終了します。</p>
<p>たとえば、このプログラムは、<code>a</code>を<code>2</code>に設定します。
それは<code>jio</code>命令によって<code>tpl</code>命令がスキップされるためです。</p>
<pre><code>inc a
jio a, +2
tpl a
inc a
</code></pre>
<p>あなたのパズル入力のプログラムが実行を終了したときの<strong>レジスタbの値</strong>は何ですか？</p>
<details><summary>解説</summary><div>
<p>命令を観察すると、指定したレジスタの内容を演算して更新するものと、
レジスタの内容に関する条件によってジャンプをするもののふたつに分かれていることがわかる。
（無条件ジャンプも「常に成立する」条件が指定されていると見なせる。）</p>
<p>後で、レジスタの実体は配列で実現すると想定して、レジスタは番号で呼ぶことにする。
これらを踏まえて、命令を表す代数的データ型を定義する。</p>
<pre><code class="language-haskell">type Reg = Int
data Inst = Ialu (Int -&gt; Int) Reg | Ijmp (Int -&gt; Bool) Reg Int
</code></pre>
<p>命令一行を読み込む関数を定義する。
このとき命令に応じて妥当な関数を設定する。</p>
<pre><code class="language-haskell">parse :: String -&gt; Inst
parse xs =
  case words xs of
    [&quot;hlf&quot;, reg] -&gt; Ialu (flip div 2) (regp reg)
    [&quot;tpl&quot;, reg] -&gt; Ialu (3 *)        (regp reg)
    [&quot;inc&quot;, reg] -&gt; Ialu succ         (regp reg)
    [&quot;jmp&quot;, ofs] -&gt; Ijmp (const True) undefined (readofs ofs) -- 無条件
    [&quot;jie&quot;, reg, ofs] -&gt; Ijmp even   (regp reg) (readofs ofs)
    [&quot;jio&quot;, reg, ofs] -&gt; Ijmp (1 ==) (regp reg) (readofs ofs)
  where
    regp ('a':_) = 0             -- 後ろのコンマを無視できるように
    regp ('b':_) = 1
    readofs ('+':cs) = read cs   -- 数値は'+'付きだとreadできない
    readofs cs = read cs
</code></pre>
<p>プログラムカウンタが逸脱するまで命令を実行し続けるCPUエミュレータを作る。</p>
<pre><code class="language-haskell">exec :: Array Int Inst -&gt; Int -&gt; Array Reg Int -&gt; Array Reg Int
exec prog pc regF
  | not $ inRange (bounds prog) pc = regF
  | otherwise =
    case prog ! pc of
      Ialu f r -&gt; exec prog (succ pc) (regF // [(r, f $ regF ! r)])
      Ijmp p r ofs | p (regF ! r) -&gt; exec prog (pc + ofs) regF
                   | otherwise    -&gt; exec prog (succ pc)  regF
</code></pre>
<p>入力を読み込み、レジスタを0に初期化して実行し、レジスタの最終状態を観察する。</p>
<pre><code class="language-haskell">main = do
  co &lt;- readFile &quot;input.txt&quot;
  let is = map parse $ lines co
  let prog = listArray (1, length is) is
  putStrLn &quot;part 1&quot;
  print $ exec prog 1 (listArray (0,1) [0,0])
</code></pre>
</div></details>
<h1 id="パート2-22"><a class="header" href="#パート2-22">パート2</a></h1>
<p>匿名の篤志家はあなたがまんまと騙されて結果を出してくれたこと、ではなくて、
コンピュータのことでLittle Jane Marieを助けてくれたことを<strong>とても</strong>感謝しています。
レジスタaが代わりに1で始まった場合、
プログラムが実行を終了したときのレジスタbの値は何ですか？
という問題は、決してあなたを失望させることはないでしょう。
（ちょっと英語がよくわからない。）</p>
<details><summary>解説</summary><div>
<p>レジスタの初期値を変えて実行するだけ。</p>
<pre><code class="language-haskell">main = do
  ...
  putStrLn &quot;part 2&quot;
  print $ exec prog 1 (listArray (0,1) [1,0])
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="24日目バランスしてぶら下がっている"><a class="header" href="#24日目バランスしてぶら下がっている">24日目：バランスしてぶら下がっている</a></h1>
<p>クリスマスイブです、そしてサンタは今年の配達のためにそりに積み込んで​​います。
しかし、1つ小さな問題があります。
彼はそりのバランスをとることができません。
バランスが取れていなければ、彼は物理学に逆らうことはできず、
そして今年誰もプレゼントをもらうことができません。</p>
<p>無理をしないで。</p>
<p>サンタはそりにうまく詰め込む必要のあるすべての包みの重量のリストをあなたに提供しました。
包みは、<strong>まったく同じ重さの3つのグループ</strong>に分割する必要があり、
すべての包みを収める必要があります。
最初のグループはそりの客室に行き、
2番目と3番目のグループは左右のコンテナに入ります。
3つのグループすべてがまったく同じ重さになったときにのみ、そりは飛ぶことができます。
物理学に反することには規則があります、わかりますね！</p>
<p>もちろん、それだけが問題ではありません。
最初のグループ、つまり客室内に移動するグループは、
サンタの足元に余裕を持たせるために、
<strong>包みの数をできるだけ少なく</strong>する必要があります。
すべてのグループの重量が同じであれば、
他の2つのグループにはいくつ包みが含まれていてもかまいません。</p>
<p>さらに、サンタは、
可能な限り少ないものが最初のグループになるように包みを配置する方法が複数ある場合、
最初のグループが最小の<strong>量子もつれ</strong> (Quantum Entanglement)を持つ方法を選択して、
「複雑化」(complication, 合併症？) の可能性を減らすようにする必要があります。
包みのグループの量子もつれは、それらの重みの積、つまり、それらの重みを掛け合わせたときに得られる値です。
すべてのグループの重量が同じでかつ
最初のグループに含まれる可能性のある包みの数が最も少ない場合にのみ、量子もつれを考慮してください。</p>
<p>たとえば、1から5と7から11の重みを持つ10の包みがあるとします。
この状況に関して、
いくつかの一意な最初のグループ、その量子もつれ、
そして残りの包みを分割する方法は以下の通りです。</p>
<pre><code>Group 1;             Group 2; Group 3
11 9       (QE= 99); 10 8 2;  7 5 4 3 1
10 9 1     (QE= 90); 11 7 2;  8 5 4 3
10 8 2     (QE=160); 11 9;    7 5 4 3 1
10 7 3     (QE=210); 11 9;    8 5 4 2 1
10 5 4 1   (QE=200); 11 9;    8 7 3 2
10 5 3 2   (QE=300); 11 9;    8 7 4 1
10 4 3 2 1 (QE=240); 11 9;    8 7 5
9 8 3      (QE=216); 11 7 2;  10 5 4 1
9 7 4      (QE=252); 11 8 1;  10 5 3 2
9 5 4 2    (QE=360); 11 8 1;  10 7 3
8 7 5      (QE=280); 11 9;    10 4 3 2 1
8 5 4 3    (QE=480); 11 9;    10 7 2 1
7 5 4 3 1  (QE=420); 11 9;    10 8 2
</code></pre>
<p>これらのうち、<code>10 9 1</code>が最も小さい量子もつれ（90）を持っていますが、
2つの包みだけからなる構成<code>11 9</code>が、
客室内にあるときサンタに最も大きな足元の余裕を与えて勝ちます。
この状況では、理想的な配置に対する量子もつれは99です。
最初のグループに包みが2つしかない構成が2つあった場合は、
より小さな量子もつれを持つ構成が選択されます。</p>
<p>理想的な構成における包みの最初のグループの<strong>量子もつれ</strong>はいくつですか？</p>
<details><summary>解説</summary><div>
<p>入力の行数から、包みの個数はほどほどで、部分集合をビット表現するのに整数で足りる。
包みの部分集合について、その合計重量をキー、部分集合のビット表現のリストを値とするマップを、
「0個の取り合わせは0」から始めて、荷物をひとつずつ追加することで、全ての組み合わせの合計重量を求める。
ただし、総重量の1/3を超えるものは不要なので作らないようにする。
このマップの、総重量の1/3になる選択群から、条件を満たすものを選択する。</p>
<pre><code class="language-haskell">import qualified Data.IntMap as IM
import Data.List

compute1 xs = ...
  where
    w3 = div (sum xs) 3
    im = foldl' step (IM.singleton 0 [0]) $ zip xs [0..]
    step im (x, i) = IM.unionWith (++) im $ IM.fromAscList $
      [(w1, map (bit i .|.) bs) | (w,bs) &lt;- IM.assocs im, let w1 = w + x, w1 &lt;= w3]
    bs = im IM.! w3 :: [Int]
</code></pre>
<p>見つかった組み合わせを、その要素数順、次に量子もつれの順で整列する。
これを小さい方から試して、3つの組み合わせで、互いに重なりないようなものが、探したいものである。</p>
<pre><code class="language-haskell">compute1 xs = ans
  where
    ...
    cands = sort [(popCount b, qe, b) | b &lt;- bs, let qe = product [x | (i,x) &lt;- zip [0..pred num] xs, testBit b i]]
    ans = head
      [ qe
      | (_,qe,b1):cands1 &lt;- tails cands
      , (_,_ ,b2):cands2 &lt;- tails cands1, b1  .&amp;. b2 == 0, let b12 = b1 .|. b2
      , (_,_ ,b3)        &lt;-       cands2, b12 .&amp;. b3 == 0
      ]

main = readFile &quot;input.txt&quot; &gt;&gt;= print . compute1 . map read . lines
</code></pre>
</div></details>
<h1 id="パート2-23"><a class="header" href="#パート2-23">パート2</a></h1>
<p>何か変です…そりはまだバランスが取れていません。</p>
<p>「ホーホーホー」サンタは自分自身に夢中になります。「トランクを忘れた。」</p>
<p>再びそりのバランスを取りますが、今回は、包みを3つではなく4つのグループに分けます。
他の制約は依然として適用されます。</p>
<p>上記の包みの例を考えたときの、いくつかの新しい一意な最初のグループ、
それらの量子もつれ、そして残りの包みを分割する方法の一つを示します。</p>
<pre><code>11 4    (QE=44); 10 5;   9 3 2 1; 8 7
10 5    (QE=50); 11 4;   9 3 2 1; 8 7
9 5 1   (QE=45); 11 4;   10 3 2;  8 7
9 4 2   (QE=72); 11 3 1; 10 5;    8 7
9 3 2 1 (QE=54); 11 4;   10 5;    8 7
8 7     (QE=56); 11 4;   10 5;    9 3 2 1
</code></pre>
<p>このうち、そこに最初のグループに包みの最小の個数（2）を置く構成が3つあります。
<code>11 4</code>, <code>10 5</code>, <code>8 7</code>です。
これらの中で、<code>11 4</code>が量子もつれが最小なので、それが選択されます。</p>
<p>さて、理想的な構成における包みの最初のグループの<strong>量子もつれ</strong>はいくつですか？</p>
<details><summary>解説</summary><div>
<p>分割が4になるだけで、やることは変わらない。</p>
<pre><code class="language-haskell">compute2 xs = ans
  where
    w4 = div (sum xs) 4
    im = ...
    step im (x, i) = ...
    bs = im IM.! w4 :: [Int]
    cands = ...
    ans = head
      [ qe
      | (_,qe,b1):cands1 &lt;- tails cands
      , (_,_ ,b2):cands2 &lt;- tails cands1, b1   .&amp;. b2 == 0, let b12  = b1  .|. b2
      , (_,_ ,b3):cands3 &lt;- tails cands2, b12  .&amp;. b3 == 0, let b123 = b12 .|. b3
      , (_,_ ,b4)        &lt;-       cands3, b123 .&amp;. b4 == 0
      ]
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="25日目雪よ降れ"><a class="header" href="#25日目雪よ降れ">25日目：雪よ降れ</a></h1>
<p>メリークリスマス！
サンタはお天気制御装置を起動しています。
あなたは結局<a href="2015/./day1.html">ホワイトクリスマス</a>を得られそうです。</p>
<p>お天気制御装置がビービーと鳴りました！
装置のコンソールには、
取扱説明書のコードを入力するように求めるコピー防止メッセージが出ています。
どうやら、あなたがそのコードを与えない限り、それは実行を拒否するようです。
別に問題はありません。あなたはマニュアルからコードを調べるでしょう…</p>
<p>「ホー、ホー、ホー」サンタは大声で熟考します。
「マニュアルを見つけ出せる気がしない。」</p>
<p>製造元のサポート電話番号を調べて、電話をかけます。
良いこともあります - その49番目のスターはそれ自体で稼ぐことはできませんでした。
(???)</p>
<p>「ああ、その機械はかなり古いです！」と彼らは言います。
「そのモデルは6分前にサポートを終了しました。
そして、私たちはすべてのマニュアルをシュレッダーにかけたばかりです。
ただし、コード生成アルゴリズムを見つけることができると思います。」</p>
<p>あなたを20分間保留にした
（あなたの電話は彼らにとって非常に重要で、繰り返し思い出させてくれました）(???)
後、
彼らはついにコードシステムがどのように機能するかを覚えているエンジニアを見つけました。</p>
<p>コードは、左上隅から始まる無限の紙に印刷されています。
コードは対角線で埋められます。
空の最初のマスを1つもつ最初の行から始まり、コードは斜めに上と右に向かって埋められます。
このプロセスは、
<a href="https://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%B3%E3%83%88%E3%83%BC%E3%83%AB%E3%81%AE%E5%AF%BE%E8%A7%92%E7%B7%9A%E8%AB%96%E6%B3%95">無限の紙が覆われる</a>
まで繰り返されます。
よって、最初のいくつかのコードは次の順序で埋められます。</p>
<pre><code>   | 1   2   3   4   5   6
---+---+---+---+---+---+---+
 1 |  1   3   6  10  15  21
 2 |  2   5   9  14  20
 3 |  4   8  13  19
 4 |  7  12  18
 5 | 11  17
 6 | 16
</code></pre>
<p>たとえば、12番目のコードは4行2列に書き込まれます。
15番目のコードは1行5列に書き込まれます。</p>
<p>電話の向こうの声は、続けてコードが実際にどのように生成されるかを説明します。
最初のコードは<code>20151125</code>です。
その後、各コードは、前のコードに<code>252533</code>を乗算してから、
その値を<code>33554393</code>で除算した余りとして生成されます。</p>
<p>したがって、2番目のコード（2行1列にくる）を見つけるには、
前の値<code>20151125</code>から始めます。
それに<code>252533</code>を掛けて<code>5088824049625</code>を得ます。
そしてそれを<code>33554393</code>で割ると余りが<code>31916031</code>となります。
この余りが2番目のコードです。</p>
<p>「ああ！」と声がします。
「マニュアルにコードのページがあるのを見落としていたようです。読んでみましょう。」
あなたは彼の読み上げる番号を書き留めます。</p>
<pre><code>   |    1         2         3         4         5         6
---+---------+---------+---------+---------+---------+---------+
 1 | 20151125  18749137  17289845  30943339  10071777  33511524
 2 | 31916031  21629792  16929656   7726640  15514188   4041754
 3 | 16080970   8057251   1601130   7981243  11661866  16474243
 4 | 24592653  32451966  21345942   9380097  10600672  31527494
 5 |    77061  17552253  28094349   6899651   9250759  31663883
 6 | 33071741   6796745  25397450  24659492   1534922  27995004
</code></pre>
<p>「さて、覚えておいて」声は続きます。
「それは最初のいくつかの数字のすべてでさえありません。
例えば、あなたは行6列2の前に来るはずの行7列1の内容がありません。
でもこれだけ判っていれば充分で…
ああ、昼食の時間だよ、さようなら」通話が切断されます。</p>
<p>サンタはオロオロしています。
あなたのパズル入力には、装置のコンソールにあるメッセージが含まれています。
<strong>あなたは装置にどんなコードを与えますか？</strong></p>
<details><summary>解説</summary><div>
<p>行 <code>theRow</code> 列 <code>theCol</code> の値を聞かれている。
まず、それが数列の何個目の値かを、ひとつめの表を見ながら考える。</p>
<p>斜めの列の \(K\) 本めを考える。
それぞれの長さは順に \(1,2,3,\dots\) なので、その末尾の数は \(1 + 2 + \dots + K = K (K + 1) / 2\) となる。
またそれは行\(1\)列\(K\)の位置にある。</p>
<p>行 \(r\) 列\(c\) のマスは、そこから右上マスに\(r-1\)回移動した先にある、行\(1\)列\(c+r-1\)と同じ斜め列に属する。つまり \(K = c + r - 1\) 行に属する。
そのひとつ手前、\(K-1\)本めの斜め列の最後のマスの番号は \((K-1)K/2\) で、
行\(r\)列\(c\)のマスはそれからさらに\(c\)マス先にあるので \((c+r-2)(c+r-1)/2 + c\) 番である。</p>
<pre><code class="language-haskell">index r c = div ((c + r - 2) * (c + r - 1)) 2 + c
</code></pre>
<p>次に、数列の <code>index theRow theCol</code> 番めの値を求める。
第1項は <code>20151125</code>, 直前の項から次の項を得る漸化式から列を作る。</p>
<pre><code class="language-haskell">theSeed = 20151125
theMag  = 252533
modBase = 33554393

step :: Int -&gt; Int
step x = mod (x * theMag) modBase

theSeq = 0 : iterate step theSeed

part1 = theSeq (index theRow theCol)
</code></pre>
<p>しかし計算が終わらない。繰り返し回数が大きすぎる。</p>
<p>ここで、数列の定義をもう一度見てみる。</p>
<p>\(a_1 = 20151125\)<br />
\(a_{i+1} = a_i \times 252533 \bmod 33554393\)</p>
<p>剰余で考えればよいので、これはモジュロ演算で</p>
<p>\(a_i \equiv 20151125 \times 252533^{i-1} \bmod 33554393\)</p>
<p>と等しい。このべき乗は、2進数に基づいて高速に計算する定番の方法がある。</p>
<pre><code class="language-haskell">-- @gotoki_no_joe
powerish mul i a b = foldl' mul i [p | (True, p) &lt;- zip bs ps]
  where
    bs = map odd $ takeWhile (0 &lt;) $ iterate (flip div 2) b
    ps = iterate (\x -&gt; mul x x) a

part1a = powerish mul theSeed theMag $ pred $ index theRow theCol

mul x y = mod (x * y) modBase
</code></pre>
</div></details>
<h1 id="パート2-24"><a class="header" href="#パート2-24">パート2</a></h1>
<p>装置は活気を取り戻し、その後また沈黙します。
ビープ音がします。
「燃料不足」とコンソールに表示されます。
「先へ進むには<strong>50個のスター</strong>が必要です。<strong>スターがひとつ</strong>利用可能です。」</p>
<p>…「スターがひとつ利用可能？」あなたは燃料タンクを点検します。
確かに、唯一のスターがその友人を待って、一番下に座っています。
49個は自分で用意する必要があるようです。</p>
<p><strong>スターが足らない場合</strong><br />
あなたは装置を起動するのに十分な星がありません。さらに(?)個必要です。</p>
<p><strong>スターが49揃った場合</strong><br />
あなたはお天気制御装置を起動するのに充分なスターを持っています。</p>
<p>あなたはお天気制御装置に50個のスターを充填します。それは息を吹き返しました！</p>
<p><strong>雪が降り始めます。</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2016年"><a class="header" href="#2016年">2016年</a></h1>
<p>サンタのそりは動作制御のために非常に高精度のクロックを使用しており、
そのクロックの発振器はスターによって調律されています。
不幸にも、スターはイースターバニーに盗まれてしまいました。
クリスマスを救うには、
サンタは12月25日までに50個のスターをすべて取り返す必要があります。</p>
<p>パズルを解いてスターを集めよう。
サンタがパズルを解くのを助けることでスターを集めよう。
このアドベントカレンダーでは、毎日2つのパズルが利用可能になります。
2番目のパズルは、1番目を完了するとロックが解除されます。
各パズルで1つずつ星が貰えます。がんばろう！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1日目タクシーの時間がない"><a class="header" href="#1日目タクシーの時間がない">1日目：タクシーの時間がない</a></h1>
<p>あなたはどこかの都市の<strong>イースターバニー司令部</strong>の近くへ空中投下されました。
「近く」とは残念ながらできるだけ近くした結果でしかありません。
サンタ付きの小人たちが入手した
イースターバニー募集要項の指示はこの地点から開始されており、
それ以上にこれを分析する時間はありませんでした。</p>
<p>要項は、
あなたが与えられた座標（あなたが着地した場所）から、
北に向いた状態で始めるよう指示しています。
次に、90度左（L）または右（R）のいずれかの方向に向きを変えて、
指定した数のブロックを進み、新しい交差点で終了します。</p>
<p>このようなばかげた指示に徒歩で従う時間はありませんので、
少し時間を割いて目的地を見つけましょう。
<strong>碁盤の目</strong>のようになった都市の<strong>道だけを歩いて</strong>、
目的地までの最短距離はどれだけですか？</p>
<h2 id="例-4"><a class="header" href="#例-4">例</a></h2>
<ul>
<li><code>R2, L3</code> に従うと2ブロック東3ブロック北に到着し、
それは出発位置から5ブロック離れています。</li>
<li><code>R2, R2, R2</code> に従うと2ブロック南に到着し、
それは2ブロック離れています。</li>
<li><code>R5, L5, R5, R3</code> は12ブロック離れた場所に到着します。</li>
</ul>
<p>イースターバニー司令部は<strong>何ブロック先</strong>にありますか？</p>
<details><summary>解説</summary><div>
<p>まずは、入力を読み込んで、左右と進むブロック数のコマンド列に変換する。</p>
<pre><code class="language-haskell">import Data.Char

main1 = do
  co &lt;- readFile &quot;input.txt&quot;
  let is = parse co
  print is

parse :: String -&gt; [Either Int Int]
parse = loop
  where
    loop ('L':xs) = sub Left  xs
    loop ('R':xs) = sub Right xs
    loop &quot;&quot; = []
    sub f xs = f (read as) : loop (dropWhile (not.isUpper) bs)
      where
        (as,bs) = span isDigit xs
</code></pre>
<p>現在位置 \((x,y)\), 現在の向き \((d_x, d_y)\) を状態にして、コマンド列を消化する。</p>
<pre><code class="language-haskell">step ((x,y), (dx,dy)) (Left  n) = ((x - n * dy, y + n * dx), (- dy, dx))
step ((x,y), (dx,dy)) (Right n) = ((x + n * dy, y - n * dx), (dy, - dx))

main1 = do
  ...
  let ((x,y),_) = foldl step ((0,0), (0,1)) is
  print $ abs x + abs y
</code></pre>
</div></details>
<h1 id="パート2-25"><a class="header" href="#パート2-25">パート2</a></h1>
<p>その後、募集要項の裏面に指示が続いていることに気がつきました。
本当のイースターバニー司令部はあなたが最初に2度訪れる場所にあります。</p>
<p>たとえば、指示が R8, R4, R4, R8 である場合、
最初に2回訪れた場所は東に4ブロック離れた所です。</p>
<p>あなたが<strong>最初に2度訪れる場所</strong>は何ブロック離れていますか？</p>
<details><summary>解説</summary><div>
<p>細かくステップを分けて考える。
コマンド列から、1マスずつの差分の列を生成し、
原点上向きから出発して全ての座標の列に直し、
先頭から消費し、既出の座標を発見したところで停止する。</p>
<pre><code class="language-haskell">import Data.Set
import qualified Data.Set as S
import Data.List

deltas :: [Either Int Int] -&gt; [(Int, Int)]
deltas = concat . snd . mapAccumL step (0,1)
  where
    step (dx,dy) (Left  n) = sub n (- dy, dx)
    step (dx,dy) (Right n) = sub n (dy, - dx)
    sub n dxy = (dxy, replicate n dxy)

positions is = scanl add (0,0)
  where
    add (x, y) (dx, dy) = (x + dx, y + dy)

loop s (p:ps)
  | S.member p s = p
  | otherwise    = loop (S.insert p s) ps

main1 = do
  ...
  let (z,w) = loop S.empty $ positions $ deltas1 is
  print $ abs z + abs w
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2日目トイレのセキュリティ"><a class="header" href="#2日目トイレのセキュリティ">2日目：トイレのセキュリティ</a></h1>
<p>あなたは暗闇の中でイースター・バニー司令部に到着します。
しかし、あなたはとても慌ただしかったためにトイレに行っておくことを忘れていました！
このような素晴らしいオフィスビルは通常トイレに暗証番号によるロックが付いているので、
番号がないかフロントデスクを探します。</p>
<p>見つけた書類には次のように書いてありました。
「セキュリティを向上させるために、暗証番号は書き留めなくなりました。
代わりに、トイレに行くためには以下の手順を覚えておいて実行してください。」</p>
<p>この書類によると、押すべき各ボタンは、ひとつ前のボタンから始めて、
キーパッド上の隣接するボタンへ移動することで各ボタンを見つけることができると説明されています。
<code>U</code>は上に移動、<code>D</code>は下に移動、<code>L</code>は左に移動、<code>R</code>は右に移動。
命令の各行は1つのボタンに対応しており、
ひとつ前のボタン（最初の行の場合は「5」ボタン）から始めます。
各行の指示の最後に到達したボタンを押してください。
移動によりボタンから外れる場合は無視してください。</p>
<p>これをずっと覚えておくことはできませんので、トイレまで歩いていくうちにコードを把握することにします。
あなたはこのようなキーパッドを心に描いています：</p>
<pre><code>1 2 3
4 5 6
7 8 9
</code></pre>
<p>指示が以下の通りだとします。</p>
<pre><code>ULL
RRDDD
LURDL
UUUUD
</code></pre>
<ul>
<li>&quot;5&quot;から始め、上がって（&quot;2&quot;）左に（&quot;1&quot;）、
さらに左に（移動できないので&quot;1&quot;に留まります）、
よって最初のボタンは1です。</li>
<li>前のボタン（&quot;1&quot;）から始め、
右に2回移動し（&quot;3&quot;）、
次に3回下に（2回移動した後に&quot;9&quot;で停止し3回目を無視して）移動し
9で終わります。</li>
<li>&quot;9&quot;から続けて、左、上、右、下、左に移動し、8で終わります。</li>
<li>最後に、あなたは4回上がり（&quot;2&quot;で止まる）、次に1回下に移動し、
5で終わります。</li>
</ul>
<p>したがって、この例では、トイレの暗証番号は1985です。</p>
<p>あなたのパズルの入力は、フロントデスクで見つけた文書にあった指示です。
<strong>トイレの暗証番号</strong>は何ですか？</p>
<details><summary>解説</summary><div>
<p>キーパッドをグラフと考える。ノードはボタンで、文字で区別する。
移動できる有向辺は方向を表す文字がラベル付けされている。
キーパッドの図から、ネットワークを表す接続行列を表す写像を作る。</p>
<pre><code class="language-haskell">import qualified Data.Map

keypad1 = mkKeyPad [&quot;123&quot;, &quot;456&quot;, &quot;789&quot;]

mkKeyPad :: [String] -&gt; M.Map (Char,Char) Char
mkKeyPad xss = M.fromList $
  [ t | xs &lt;- xss, (v,w) &lt;- zip xs (tail xs), v /= ' ', w /= ' '
  , t &lt;- [((v,'R'),w),((w,'L'),v)]]
  ++
  [ t | (xs, ys) &lt;- zip xss (tail xss), (v,w) &lt;- zip xs ys, v /= ' ', w /= ' '
  , t &lt;- [((v,'D'),w),((w,'U'),v)]]
</code></pre>
<p>開始の文字と、一連の指示を受け取り、グラフを辿って最終的に到達した文字を返す。
辿れないときは無視する。</p>
<pre><code class="language-haskell">exec kp c ds = foldl step c ds
  where
    step c d = M.findWithDefault c (c,d) kp
</code></pre>
<p>入力を読み取り、'5' から始めて、行の内容に従ってグラフを辿る。
たどり着いた文字は結果でありかつ、次の行の開始位置になる。</p>
<pre><code class="language-haskell">import Data.List

main1 = do
  co &lt;- readFile &quot;input.txt&quot;
  putStrLn $ tail $ scanl (exec keypad ) '5' $ lines co
</code></pre>
</div></details>
<h1 id="パート2-26"><a class="header" href="#パート2-26">パート2</a></h1>
<p>ついにあなたはトイレにたどり着きました。
（ロビーから数分歩いているので、
この階には数多くの会議室やウォータークーラーがあることが見て取れます。）
では暗証番号を打ち込みましょう。
キーパッドが想像していたようなものと全く異なった驚きのほとんどが膀胱を狼狽させました。
トイレの暗証番号ロックのキーパッドデザイン会議に数百万人時間を注いだ成果とあなたは対峙しています。</p>
<pre><code>    1
  2 3 4
5 6 7 8 9
  A B C
    D
</code></pre>
<p>あなたはやはり &quot;5&quot; から始め、端にいるときに止まりますが、
上と同じ指示が与えられたときの結果は非常に異なります。</p>
<ul>
<li>あなたは &quot;5&quot; から始め、まったく動かず（上と左はどちらも端）、5で終わります。</li>
<li>&quot;5&quot;から続けて、右に2回下に3回移動し（&quot;6&quot;,&quot;7&quot;,&quot;B&quot;,&quot;D&quot;,&quot;D&quot;と通って）Dで終わります。</li>
<li>次に、&quot;D&quot;からもう5回移動して（&quot;D&quot;,&quot;B&quot;,&quot;C&quot;,&quot;C&quot;,&quot;B&quot;を通って）Bで終わります。</li>
<li>最後に、さらに5回移動した後、あなたは3で終わります。</li>
</ul>
<p>したがって、実際のキーパッドの配置に基づくと、暗証番号は<code>5DB3</code>になります。</p>
<p>パズル入力ファイルにある同じ指示を使用して、<strong>トイレの正しい暗証番号</strong>は何ですか？</p>
<details><summary>解説</summary><div>
<p>キーパッドのグラフを差し替えればよい。</p>
<pre><code class="language-haskell">keypad2 = mkKeyPad [&quot;  1  &quot;,&quot; 234 &quot;,&quot;56789&quot;,&quot; ABC &quot;,&quot;  D  &quot;]

main2 = do
  co &lt;- readFile &quot;input.txt&quot;
  putStrLn $ tail $ scanl (exec keypad2) '5' $ lines co
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3日目三角形広場"><a class="header" href="#3日目三角形広場">3日目：三角形広場</a></h1>
<p>（原題の「広場」はsquareで、三角形と掛かっている。）</p>
<p>あなたは頭がはっきりしてきたので、
イースターバニー司令部のこの部分を構成する
廊下とオフィス家具の迷路にもっと深く入っていきます。
ここはグラフィックデザイン部門に違いありません。
壁一面に三角形の仕様が貼り出されています。</p>
<p>いや、どうだろう？</p>
<p>設計文書は、それが定義する各三角形の辺の長さが記されています。
しかし… 5 10 25？三角形にならないものが混じっています。
あなたは三角形にならないものに印を付けずにはいられませんでした。</p>
<p>正しい三角形では、任意の2つの辺の合計が残りの辺よりも大きい必要があります。
例えば、上の「三角形」は、
\(5 + 10\) は25より大きくはないので、三角形になりません。</p>
<p>あなたのパズル入力では、
記述されている三角形のうち<strong>正しいものはいくつありますか？</strong></p>
<details><summary>解説</summary><div>
<p>三角形をなす条件を判定する述語を定義する。</p>
<pre><code class="language-haskell">property a b c = a + b &gt; c &amp;&amp; b + c &gt; a &amp;&amp; c + a &gt; b
</code></pre>
<p>条件を満たすものを数えればよい。</p>
<pre><code class="language-haskell">main1 =
  readFile &quot;input.txt&quot; &gt;&gt;=
  pure . map (map read . words) . lines &gt;&gt;=
  print . length . filter (\[a,b,c] -&gt; property a b c)
</code></pre>
</div></details>
<h1 id="パート2-27"><a class="header" href="#パート2-27">パート2</a></h1>
<p>あなたが設計文書に役立つ印を付け終わったところで、三角形が縦に3つの組で指定されていることに気付きました。
列の3つの数字の各組は三角形を指定します。行は無関係です。</p>
<p>たとえば、次の仕様があるとき、百の位が同じ数字は同じ三角形の一部になります。
（訳注：「百の位が同じ数字」は同じ三角形の一部になるための条件ではなくて、
数字列をどのような組み合わせで解釈するかの説明のためにそうしたということ）</p>
<pre><code>101 301 501
102 302 502
103 303 503
201 401 601
202 402 602
203 403 603
</code></pre>
<p>あなたのパズル入力において、行でなく列で読んで、
記述されている三角形のうち<strong>正しいものはいくつありますか？</strong></p>
<details><summary>解説</summary><div>
<p>3行ずつに切り分け、それらを転置し、全体を連結してからパート1と同じことをすればよい。</p>
<pre><code class="language-haskell">import Data.List
import Data.List.Split

main2 =
  readFile &quot;input.txt&quot; &gt;&gt;=
  pure . concat . map transpose . chunksOf 3 . map (map read . words) . lines &gt;&gt;=
  print . length . filter (\[a,b,c] -&gt; property a b c)
</code></pre>
</div></details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4日目不明瞭さによるセキュリティ"><a class="header" href="#4日目不明瞭さによるセキュリティ">4日目：不明瞭さによるセキュリティ</a></h1>
<p>（原題はSecurity Through Obscurityと韻を踏んでいる）</p>
<p>ついに、部屋のリストが表示された情報キオスクの場所に着きました。
もちろん、リストは暗号化され、囮データでいっぱいですが、
リストを解読するための説明はすぐそばにまるで隠すことなく置いてあります。
まずは囮データを削除するのがよいでしょう。</p>
<p>各部屋は、暗号化された名前（ダッシュで区切られた小文字）、
ダッシュ、セクタID、角括弧で囲んだチェックサム、
で構成されています。</p>
<p>チェックサムが
暗号化された名前の中で最も多く現れる5つの文字で、
多い順に並んでいて、
同順のものはアルファベット順であるならば、
部屋は本物です。（囮ではありません。）
例えば：</p>
<ul>
<li><code>aaaaa-bbb-z-y-x-123[abxyz]</code>は本物の部屋です。
最もよく現れる文字は<code>a</code>(5回)、<code>b</code>(3回)、
その後同順の<code>x</code>,<code>y</code>,<code>z</code>はアルファベット順に列挙されているからです。</li>
<li><code>a-b-c-d-e-f-g-h-987[abcde]</code>は本物の部屋です。
すべての文字は同順ですが（それぞれ1つ）、
最初の5つがアルファベット順にリストされているためです。</li>
<li><code>not-a-real-room-404[oarel]</code>は本物の部屋です。</li>
<li><code>totally-real-room-200[decoy]</code> は本物ではありません。</li>
</ul>
<p>上のリストのうち本物の部屋のセクタIDの合計は1514です。</p>
<p><strong>本物の部屋のセクタIDの合計はいくつですか？</strong></p>
<h1 id="パート2-28"><a class="header" href="#パート2-28">パート2</a></h1>
<p>囮データがすべて消えたので、このリストを解読して話を進める時間です。</p>
<p>部屋の名前は最先端の<strong>シフト暗号</strong>で暗号化されています。
これは適切なソフトウェアがなければほとんど解読できません。
しかし、イースターバニー司令部の情報キオスクのデザイナーは、
あなたのような暗号の達人を相手にすることを予想していませんでした。</p>
<p>部屋の名前を復号化するには、
部屋のセクターIDに等しい数だけ
各文字を前方にアルファベットで回転させます。
<code>A</code>は<code>B</code>になり、<code>B</code>は<code>C</code>になり、<code>Z</code>は<code>A</code>になり、等々。
ダッシュはスペースになります。</p>
<p>たとえば、
<code>qzmt-zixmtkozy-ivhz-343</code>
の実際の名前は
<code>very encrypted name</code>
です。</p>
<p>North Pole objectが格納されている部屋の<em>セクタID</em>は何ですか？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2022年"><a class="header" href="#2022年">2022年</a></h1>
<p>サンタのトナカイは通常、普通のトナカイフードを食べますが、
クリスマスにプレゼントを届けるには魔法力がたくさん必要です。
そのため、彼らのお気に入りのおやつは、ジャングルの奥深くでしか育たない特別な種類のスターフルーツです。
サンタ付きの小人は、そのスターフルーツが育つ果樹園への毎年恒例の遠征にあなたを連れてきました。</p>
<p>十分な魔法力を供給するには、遠征隊は12月25日までに最低50個のスターを回収する必要があります。
小人は果樹園にたくさんの果物があることを保証しますが、
あなたは途中で見つけたスターフルーツを全て収穫することにしました。念のためです。</p>
<p>パズルを解いてスターを集めよう。
アドベントカレンダーでは、毎日2つのパズルが利用可能になります。
最初のパズルを完了すると、2番目のパズルのロックが解除されます。
パズルごとに星が1つ付与されます。幸運を！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1日目--カロリー計算"><a class="header" href="#1日目--カロリー計算">1日目 : カロリー計算</a></h1>
<p>ジャングルは生い茂りすぎて、車での移動や空からのアクセスは困難に違いありません。
小人の遠征は伝統的に徒歩で行われます。
あなたのボートが陸地に近づくと、小人たちは物資の在庫を調べ始めます。
重要な考慮事項のひとつは食料です。
特に、それぞれの小人が運んでいるカロリーの量（パズル入力）です。</p>
<p>小人たちは、持ってきたさまざまな食料、おやつ、レーションなどに含まれるカロリーの量を順番に書き留めます。
1行に1項目ずつ。
小人たちは、自分の目録を前の小人の目録（存在する場合）と空行で区切ります。</p>
<p>例えば、小人たちが所持品のカロリーを書き終えて、次のリストになったとします。</p>
<pre><code>1000
2000
3000

4000

5000
6000

7000
8000
9000

10000
</code></pre>
<p>このリストは、5人の小人が運ぶ食品のカロリーを表しています。</p>
<ul>
<li>最初の小人はそれぞれ1000, 2000, 3000カロリーで合計6000カロリーの食料を運んでいます。</li>
<li>2番目の小人は4000カロリーの食品を1つ運んでいます。</li>
<li>3番目の小人は5000と6000カロリー、合計11000カロリーの食料を運んでいます。</li>
<li>4番目の小人は7000,8000,9000カロリー、合計24000カロリーの食料を運んでいます。</li>
<li>5番目の小人は10000カロリーある食品を1つ運んでいます。</li>
</ul>
<p>小人のお腹が空いて追加のおやつが必要になった場合、どの小人に求めればよいかを知る必要があります。
彼らは、最も多くのカロリーを運んでいる小人がどれだけのカロリーを運んでいるかを知りたがっています。
上記の例では、これは（4番目の小人が運ぶ）24000です。</p>
<p>最も多くのカロリーを運んでいる小人を見つけてください。
<strong>その小人が持っている総カロリーはいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

`Data.List.Split`には列を区切る方法がいくつか実装されている。
これを用いて小人ごとのリストに戻し、それぞれ和を取り、最大値を求めればよい。

```haskell
main1 =
  readFile "input.txt" >>=
  pure . map (map read) . wordsBy null . lines >>=
  print . maximum . map sum
```

</div></details>
-->
<h1 id="パート2-29"><a class="header" href="#パート2-29">パート2</a></h1>
<p>あなたが小人の疑問に対する答えを計算する頃には、
彼らは、最大のカロリーを運ぶ小人の在庫が最後にはなくなってしまう可能性があることにすでに気づいています.</p>
<p>この容認できない状況を回避するために、小人は代わりに、
最も多くのカロリーを運ぶ上位3人の小人が運ぶ総カロリーを知りたいと考えています。
そうすれば、小人の1人がおやつを使い果たしたとしても、2人の控えが残っています。</p>
<p>上の例では、上位3人の小人は4番目の小人（24000カロリーを持つ）、3番目の小人（11000カロリー）、
5番目の小人（10000カロリー）です。
この3人の小人が持っているカロリーの合計は45000です。</p>
<p>最も多くのカロリーを運ぶ上位3人の小人を見つけてください。
<strong>それらの小人は合計で何カロリーを持っていますか？</strong></p>
<!--
<details><summary>解説</summary><div>

最大値一つを `maximum` で得る代わりに、
整列して端を取り出すことで、上位3つのカロリーを足し合わせればよい。

```haskell
main2 =
  readFile "input.txt" >>=
  pure . map (sum . map read) . wordsBy null . lines >>=
  print . sum . take 3 . sortBy (flip compare)
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="2日目-じゃんけん"><a class="header" href="#2日目-じゃんけん">2日目: じゃんけん</a></h1>
<p>小人たちはビーチにキャンプを設置し始めています。
おやつ貯蔵庫に最も近いテントに誰が入るかを決めるために、巨大な<a href="https://ja.wikipedia.org/wiki/%E3%81%98%E3%82%83%E3%82%93%E3%81%91%E3%82%93">じゃんけん</a>トーナメントがすでに進行中です。</p>
<p>じゃんけんは2人のプレイヤー間のゲームです。各ゲームには多くのラウンドからなります。
各ラウンドで、両プレイヤーは同時に手の形を使用して石、紙、鋏のいずれかを選択します。
そしてそのラウンドの勝者が決まります。
石が鋏に勝利し、鋏が紙に勝利し、紙が石に勝利します。
両方のプレイヤーが同じ形を選択した場合、ラウンドは引き分けで終了します。</p>
<p>昨日のあなたの助けに感謝して、一人の小人が暗号化された戦略ガイド（パズルの入力）をあなたに渡します。
「最初の列は対戦相手の出す手です。<code>A</code>は石、<code>B</code>は紙、<code>C</code>は鋏です。2番目の列は…」
突然、その小人は誰かのテントを手伝って欲しいと呼ばれて行ってしまいました。</p>
<p>2番目の列について、あなたは推測します。
これはおそらく、あなたが対応して出す手に違いありません。
<code>X</code>は石、<code>Y</code>は紙、<code>Z</code>は鋏でしょう。
毎回勝つのは怪しいので、手は慎重に選ばれたに違いありません。</p>
<p>トーナメント全体の勝者は、最高得点のプレイヤーです。
合計スコアは、各ラウンドのスコアの合計です。
1ラウンドの得点は、選択した形の得点（石は1点、紙は2点、鋏は3点）にラウンドの結果の得点（負けた場合は0点、引き分けの場合は3点、勝った場合は6点）を加えたものです。</p>
<p>小人があなたを助けようとしているのか、それともハメようとしているのかわからないので、攻略ガイドに従った場合に得られるスコアを計算する必要があります。</p>
<p>たとえば、次の戦略ガイドが与えられたとします。</p>
<pre><code>A Y
B X
C Z
</code></pre>
<p>この戦略ガイドでは、次のことを予言し、勧めています。</p>
<ul>
<li>最初のラウンドでは、対戦相手は石(<code>A</code>)を選択し、自分は紙(<code>Y</code>)を選択する必要があります。
これはあなたの勝ちになり、スコアは8点（紙を選んだので 2 + 勝ったので 6）になります。</li>
<li>2ラウンドめは対戦相手が紙(<code>B</code>)を選び、自分は石('X')を選びます。
これは負けになりスコアは1 (1 + 0) 点を得ます。</li>
<li>第3ラウンドは両方のプレイヤーが鋏を選択して引き分けて、スコアは 3 + 3 = 6 になります。</li>
</ul>
<p>この例では、戦略ガイドに従う場合、あなたは合計スコア15(8 + 1 + 6) を得ます。</p>
<p><strong>すべてが戦略ガイドどおりに進んだ場合、合計スコアはいくつになりますか？</strong></p>
<!--
<details><summary>解説</summary><div>

入力の各行（の1文字めと3文字め）からラウンドの得点が計算でき、その合計を求める。

```haskell
main1 = readFile "input.txt" >>= print . sum . map score1 . lines
```

自分の出す手に応じて、形の点と、相手の手に応じて勝敗点を導く関数が選択できる。

```haskell
score1 (o:_:'X':_) = 1 + sub o (3,0,6) -- X=石 対 o=A/B/C での勝敗点
score1 (o:_:'Y':_) = 2 + sub o (6,3,0) -- 紙
score1 (o:_:'Z':_) = 3 + sub o (0,6,3) -- 鋏

sub 'A' (a,_,_) = a
sub 'B' (_,b,_) = b
sub 'C' (_,_,c) = c
```

</div></details>
-->
<h1 id="パート2-30"><a class="header" href="#パート2-30">パート2</a></h1>
<p>先ほどの小人がテントの手伝いを終え、忍び足で戻ってきました。
「とにかく、2番目の列には、ラウンドがどのように終了する必要があるかが示されています。
つまり、<code>X</code>は負ける必要があることを意味し、
<code>Y</code>はラウンドを引き分けで終了する必要があることを意味し、
<code>Z</code>は勝つ必要があることを意味します。
頑張って！」</p>
<p>合計スコアは同じ方法で計算されますが、今、指示されているようにラウンドを追えるためには
どの形を選べばよいかを導く必要があります。
上記の例は次のようになります。</p>
<ul>
<li>最初のラウンドで相手は石(<code>A</code>)を選択し、引き分け(<code>Y</code>)でラウンドを終了する必要があるため、こちらも石を選択します。これにより、1 + 3 = 4のスコアを得ます。</li>
<li>第2ラウンドでは、対戦相手は紙(<code>B</code>)を選択し、あなたは石を選択することで負け(<code>X</code>)て、スコアは 1 + 0 = 1 です。</li>
<li>第3ラウンドでは、相手の鋏を石で倒して 1 + 6 = 7のスコアを得ます。</li>
</ul>
<p>これで、超極秘戦略ガイドを正しく解読でき、合計スコアは12となります。</p>
<p>2番目の列のエルフの指示に従って、<strong>全てが戦略ガイドどおりに進んだ場合、合計スコアはいくつになるでしょうか？</strong></p>
<!--
<details><summary>解説</summary><div>

ラウンドの結果に応じて、勝敗点と、相手の手に応じて自分の手の形の点を導く関数が選択できる。

```haskell
main2 = readFile "input.txt" >>= print . sum . map score2 . lines

score2 (o:_:'X':_) = 0 + scoresub o (3,1,2) -- o=A/B/C に負けるための手の形点
score2 (o:_:'Y':_) = 3 + scoresub o (1,2,3) -- 引き分ける
score2 (o:_:'Z':_) = 6 + scoresub o (2,3,1) -- 勝つ
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-日目--リュックサックの再編成"><a class="header" href="#3-日目--リュックサックの再編成">3 日目 : リュックサックの再編成</a></h1>
<p>ある小人が、ジャングルへの旅の物資を全てのリュックサックに詰め込むという重要な仕事をしています。
残念ながら、その小人は梱包の指示をまるで無視したので、いくつかの荷物を再配置する必要があります.</p>
<p>各リュックサックには2つの大きな区画があります。
様々な種類の全ての荷物はそれぞれ、2つの区画のいずれかにだけ入れることになっています。
荷造りをした小人は、リュックサックごとに、同じ種類の荷物はひとつだけという規則に従いませんでした。</p>
<p>小人は現在各リュックサックに入っている全ての荷物のリストを作成しました（あなたのパズル入力）が、誤りを見つけるためにあなたの助けが必要です。
全ての荷物の種類は、単一の小文字または大文字で識別されます。
(つまり、<code>a</code>と<code>A</code>は異なる種類の荷物を指します。）</p>
<p>各リュックサックの荷物のリストは、全て一行の文字列として示されます。
リュックサックの2つの区画には常に同じ数の荷物が入っているため、文字列の前半は最初の区画の荷物を表し、文字列の後半は2番目の区画の荷物を表します。</p>
<p>例えば、次のような、6つのリュックサックの内容のリストがあるとします。</p>
<pre><code>vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
</code></pre>
<ul>
<li>最初のリュックサックには荷物  <code>vJrwpWtwJgWrhcsFMMfFFhFp</code> が入っています。
つまり、最初の区画には荷物 <code>vJrwpWtwJgWr</code> があり、
2番目の区画には荷物 <code>hcsFMMfFFhFp</code> が入っています。
両方の区画に現れている唯一の荷物の種類は小文字 <code>p</code> です。</li>
<li>2番目のリュックサックの区画には
<code>jqHRNqRjqzjGDLGL</code> と <code>rsFMfFZSrLrFZsSL</code>
が入っています。
両方の区画に現れている唯一の荷物の種類は大文字 <code>L</code> です。</li>
<li>3番目のリュックサックの区画には
<code>PmmdzqPrV</code> と <code>vPwwTWBwg</code>
があり、唯一の共通の種類は大文字 <code>P</code> です。</li>
<li>4番目のリュックサックの区画は種類 <code>v</code> のみを共有しています。</li>
<li>5番目のリュックサックの区画は種類 <code>t</code> のみを共有しています。</li>
<li>6番目のリュックサックの区画は種類 <code>s</code> のみを共有しています。</li>
</ul>
<p>荷物の再配置に優先順位を付けるために、全ての荷物の種類を優先度に変換できます。</p>
<ul>
<li>小文字の荷物種類 <code>a</code>～<code>z</code> は、優先度 1 から 26 を持ちます。</li>
<li>大文字の荷物種類 <code>A</code>～<code>Z</code> は、優先度 27 から 52 を持ちます。</li>
</ul>
<p>上記の例では、各リュックサックの両方の区画に現れる荷物種類の優先度は、16 (<code>p</code>), 38 (<code>L</code>), 42 (<code>P</code>), 22 (<code>v</code>), 20 (<code>t</code>), 19 (<code>s</code>) です。
これらの合計は157です。</p>
<p>各リュックサックの両方の区画に現れる荷物の種類を見つけます。<strong>これらの荷物種類の優先度の合計はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

`Data.List.intersect`で、リストを集合とみなして共通部分を取り出すことができる。

```haskell
import Data.List

main1 = body "input.txt" compute1

body fn cp = readFile fn >>= print . cp . lines

compute1 :: [String] -> Int
compute1 = sum . map func1

func1 :: String -> Int
func1 xs = prio $ head $ intersect as bs
  where
    (as,bs) = splitAt (div (length xs) 2) xs

-- 優先度
prio c
  | c <= 'Z'  = fromEnum c - fromEnum 'A' + 27
  | otherwise = fromEnum c - fromEnum 'a' + 1
```

</div></details>
-->
<h1 id="パート2-31"><a class="header" href="#パート2-31">パート2</a></h1>
<p>入れ間違えた荷物の特定が完了すると、小人が別の問題を抱えてやってきます。</p>
<p>安全のため、小人は3人ずつグループに分けられます。
全ての小人はグループを識別するバッジを持っています。
効率のために、3人の小人の各グループ内で、バッジは<strong>その小人3人ともが共通して持つ唯一の荷物の種類</strong>です。
つまり、グループのバッジが種類<code>B</code>の場合、3人の小人はみなリュックサックのどこかに種類<code>B</code>の荷物を持ち、
そしてそれ以外の種類の荷物は多くて2人までしかそれを持っていません。
（訳注：3人共通の種類はひとつに定まる、ということ。）</p>
<p>問題は、誰かがバッジに今年更新された証紙シールを貼り付け忘れたことです。
新しい証紙シールを貼り付けるために、全てのバッジをリュックサックから取り出す必要があります。</p>
<p>さらに、各グループのバッジに対応する荷物の種類を誰も書き留めていませんでした。
どの荷物種類が正解かを判断する唯一の方法は、各グループの3人の小人全てに共通する1つの荷物種類を見つけることです。</p>
<p>リスト内の3行ずつの各組は1つのグループに対応しますが、各グループは異なるバッジの荷物種類を持つことができます。
したがって、上記の例では、最初のグループのリュックサックは最初の3行です。</p>
<pre><code>vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
</code></pre>
<p>2番目のグループのリュックサックはその次の3行です。</p>
<pre><code>wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
</code></pre>
<p>最初のグループでは、3つのリュックサックすべてに現れる唯一の荷物種類は小文字 <code>r</code> です。
これが彼らのバッジに違いありません。
2番目のグループでは、バッジの荷物種類は <code>Z</code> です。</p>
<p>これらの荷物の優先順位は、証紙シール貼り付け作業を計画するために引き続き調べる必要があります。
ここでは、最初のグループは 18 (<code>r</code>)、2番目のグループは 52 (<code>Z</code>) です。
これらの合計は70です。</p>
<p>小人の3人グループそれぞれについて、バッジに対応する荷物種類を見つけます。
<strong>これらの荷物種類の優先度の合計はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

3人グループのリストに対して、`intersect`を2度使えば共通の要素が取り出せる。

```haskell
import Data.List.Split

main2 = body "input.txt" compute2

compute2 :: [String] -> Int
compute2 = sum . map func2 . chunksOf 3

func2 :: [String] -> Int
func2 = prio . head . foldl1 intersect
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-日目--キャンプの後片付け"><a class="header" href="#4-日目--キャンプの後片付け">4 日目 : キャンプの後片付け</a></h1>
<p>船から最後の物資を降ろす前に、場所を空ける必要があります。
そのため、数人の小人がキャンプの区画を片付ける仕事を割り当てられています。
全ての区画には一意の<strong>ID番号</strong>があり、小人にはそれぞれ区画IDの範囲がひとつずつ割り当てられています。</p>
<p>ところが、ある小人が区画の割り当てを互いに見比べたところ、
割り当ての多くに<strong>重複がある</strong>ことに気付きました。
重複をすばやく見つけて無駄な作業を減らすために、小人たちは二人一組になり、
<strong>それぞれの組の割り当て区画の大きなリスト</strong>（パズル入力）を作成します。</p>
<p>例えば、次の区画割り当て対のリストを考えてみましょう：</p>
<pre><code>2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8
</code></pre>
<p>最初の数個の対について、このリストの意味を説明します：</p>
<ul>
<li>最初の小人の組では、最初の小人には区画2-4（区画2,3,4）が割り当てられ、
2番目の小人には区画6-8（区画6,7,8）が割り当てられました。</li>
<li>2番目の小人の組には、それぞれ2つの区画が割り当てられました。</li>
<li>3番目の小人の組には、それぞれ3つの区画が割り当てられました。
一人は区画5,6,7で、もう一方は同じく7と、あと8,9です。</li>
</ul>
<p>このリストの例では、図示しやすいように1桁の区画IDを使用しています。
実際のリストにはもっと大きな数が含まれている可能性があります。
これらの区画割り当ての対は、視覚的には次のようになります。</p>
<pre><code>.234.....  2-4
.....678.  6-8

.23......  2-3
...45....  4-5

....567..  5-7
......789  7-9

.2345678.  2-8
..34567..  3-7

.....6...  6-6
...456...  4-6

.23456...  2-6
...45678.  4-8
</code></pre>
<p>一部の組は、彼らの割り当ての一方が他方を<strong>完全に含んでいる</strong>ことに気付きました。
例えば、<code>2-8</code>は<code>3-7</code>を完全に含んでおり、<code>6-6</code>は<code>4-6</code>に完全に含まれています。</p>
<p>一方の割り当てがもう一方の割り当てを完全に含む組では、組の小人の一人は、
相棒が既に清掃している区画だけを清掃するため、これらは最も再検討が必要と思われます。
この例では、そのような組が2組あります。</p>
<p><strong>一人の範囲がもう一人の範囲に完全に含まれる割り当ての組はいくつありますか？</strong></p>
<!--
<details><summary>解説</summary><div>

一行にある4つの数を順に \\(a,b,c,d\\) と呼ぶことにする。
データに矛盾がないこと、すなわち\\(a \leq b, c \leq d\\)は満たされていると仮定する。

行を読み取るのには、数字の並びの部分だけを抽出する必要がある。
次に出現する数字でない文字が固定なので、それを用いて取り出すのが簡易。

```haskell
import Data.List

parse :: String -> (Int,Int,Int,Int)
parse xs0 = (read as, read bs, read cs, read ds)
  where
    (as,_:xs1) = span ('-' /=) xs0
    (bs,_:xs2) = span (',' /=) xs1
    (cs,_:ds ) = span ('-' /=) xs2
```

完全に重なっているとは、\\(a \leq c \land d \leq b\\) または
\\(c \leq a \land b \leq d\\) である。
これを満たしている行の数を数える。

```haskell
prop1 (a,b,c,d) = a <= c && d <= b || c <= a && b <= d

main1 = readFile "input.txt" >>= print . length . filter prop1 . map parse . lines
```

</div></details>
-->
<h1 id="パート2-32"><a class="header" href="#パート2-32">パート2</a></h1>
<p>まだかなりの重複作業が予定されているようです。
代わりに、小人たちは重なりがある組のの数を知りたがっています。</p>
<p>上記の例では、最初の2つの組（<code>2-4,6-8</code>と<code>2-3,4-5</code>）は重なりませんが、
残りの4つ組（<code>5-7,7-9</code>, <code>2-8,3-7</code>, <code>6-6,4-6</code>, `2-6,4-8)）は重なります。</p>
<ul>
<li><code>5-7,7-9</code> は単一の区画<code>7</code>が重複しています。</li>
<li><code>2-8,3-7</code> は<code>3</code>から<code>7</code>までの全ての区画で重なっています。</li>
<li><code>6-6,4-6</code> 単一の区画<code>6</code>で重なっています。</li>
<li><code>2-6,4-8</code> は区画<code>4</code>,<code>5</code>,<code>6</code>で重なっています。</li>
</ul>
<p>したがって、この例では、重なりのある割り当て組のの数は4です。</p>
<p><strong>範囲が重複する割り当て組はいくつありますか？</strong></p>
<!--
<details><summary>解説</summary><div>

逆に、重複が**ない**とは、\\(b < c\\) または \\(d < a\\) が満たされることである。
これをそのまま書いてもいいし、ド・モルガンの法則を用いて
\\(\neg (b < c \lor d < a) = b \geq c \land d \geq a\\)
としてもよい。

```haskell
prop2 (a,b,c,d) = not (b < c || d < a)

main2 = readFile "input.txt" >>= print . length . filter prop2 . map parse . lines
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-日目-物資の山"><a class="header" href="#5-日目-物資の山">5 日目: 物資の山</a></h1>
<p>船から最後の物資が降ろされ次第、遠征隊は出発できます。
物資はそれぞれ印付きの木箱に収められ、積み上げられてスタックをなしていますが、
必要な物資は他の多くの木箱の下に埋もれているため、木箱を再配置する必要があります。</p>
<p>船には、木箱をスタック間で移動できる巨大な貨物クレーンがあります。
木箱がつぶれたり倒れたりしないように、クレーンのオペレーターは慎重に計画された一連の手順で木箱を再配置します。
木箱を再配置すると、目的の木箱が各スタックの一番上になります。</p>
<p>小人たちは、この繊細な手順の間、クレーンオペレーターの邪魔をしたくありませんが、どの木箱がどこに到着するのかを尋ねるのを忘れていました。
出発するために、再配置が完了したらできるだけ早く荷下ろしにかかれるように備えたいと思っています。</p>
<p>しかし彼らは、木箱のスタックの初期状態の図と再配置手順（パズル入力）しか持っていません。
例えば：</p>
<pre><code>    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 

move 1 from 2 to 1
move 3 from 1 to 3
move 2 from 2 to 1
move 1 from 1 to 2
</code></pre>
<p>この例では、木箱のスタックが3つあります。
スタック1は2つの木箱からなります。木箱<code>Z</code>は下にあり、木箱<code>N</code>は上にあります。
スタック2は3つの木箱からなります。下から上に、木箱 <code>M</code>, <code>C</code>, <code>D</code> です。
最後に、スタック3は1つの箱<code>P</code>からなります。</p>
<p>続きに、再配置手順が示されています。
手順の各ステップで、ある量の木箱が1つのスタックから別のスタックに移動されます。
上記の再配置手順の最初のステップでは、1つの木箱がスタック2からスタック1に移動され、
その結果次の構成になります。</p>
<pre><code>[D]        
[N] [C]    
[Z] [M] [P]
 1   2   3 
</code></pre>
<p>第2ステップでは、3つの木箱がスタック1からスタック3に移動します。
木箱は<strong>一度にひとつ</strong>ずつ運ばれるので、
結果として最初の木箱(<code>D</code>)は2つめ3つめの木箱の下に移されます。</p>
<pre><code>        [Z]
        [N]
    [C] [D]
    [M] [P]
 1   2   3
</code></pre>
<p>次に、両方の木箱がスタック2からスタック1に運ばれます。
ここでも木箱は一度に1つずつ移動されるため、木箱<code>C</code>は木箱<code>M</code>の下になります。</p>
<pre><code>        [Z]
        [N]
[M]     [D]
[C]     [P]
 1   2   3
</code></pre>
<p>最後に、1つの木箱がスタック1からスタック2に移動されます。</p>
<pre><code>        [Z]
        [N]
        [D]
[C] [M] [P]
 1   2   3
</code></pre>
<p>小人たちは、<strong>最後にどの木箱が各スタックの一番上になるか</strong>を知る必要があります。
この例では、一番上の木箱はスタック1では<code>C</code>、スタック2は<code>M</code>、スタック3は<code>Z</code>になため、
これらを組み合わせて、エルフに<code>CMZ</code>とメッセージを送る必要があります。</p>
<p><strong>再配置手順が完了した後、各スタックの一番上にある木箱は何ですか？</strong></p>
<!--
<details><summary>解説</summary><div>

ファイルを読み込んだら、前半と後半が空行で区切られているので、これで切り分け、空行は除く。

```haskell
(ls1, _:ls2) <- break null . lines <$> readFile "input.txt"
```

前半のスタックの絵は、スタックごとに、上を前にしたリストで取り出したい。
これは `Data.List.transpose` で転置したあと、必要な行だけ抜き出すことでできる。
（一番右のスタックが最大でない場合、行末を揃えるために空白を追加する必要がある。自分は不要だった。）
なお、前半の最後はスタック位置を表すだけで不要なので捨てる。

取り出したスタックの初期状態は、この後の手続き的な更新に備えて、
スタック番号をキーにした `IntMap` に入れておく。

```haskell
let ls1t = transpose $ init ls1
let m0 = IM.fromAscList $ zip [1..] $ map (dropWhile (' ' ==) . (ls1t !!)) [1,5..33]
```

ファイル後半の手順書は、3つの数を抜き出すだけでよい。

```haskell
parse :: String -> (Int,Int,Int)
parse xs = (read w1, read w2, read w3)
  where
    (_:w1:_:w2:_:w3:_) = words xs
```

ひとつの指示(a,b,c)を実行するには、スタックbから要素をひとつずつ取り出してスタックcに乗せることをa回繰り返す。

```haskell
step1 :: IM.IntMap String -> (Int,Int,Int) -> IM.IntMap String
step1 m1 (a,b,c) = IM.insert c imc $ IM.insert b imb m1
  where
    move 0 xs ys = (xs,ys)
    move k (x:xs) ys = move (pred k) xs (x:ys)
    (imb, imc) = move a (m1 IM.! b) (m1 IM.! c)
```

これを全ての行について実行した結果のスタックから、先頭要素を全て順に取り出したものが答えである。

```haskell
body step = do
  (ls1, _:ls2) <- break null . lines <$> readFile "input.txt"
  let ls1t = transpose $ init ls1
  let m0 = IM.fromAscList $ zip [1..] $ map (dropWhile (' ' ==) . (ls1t !!)) [1,5..33]
  let mZ = foldl step m0 $ map parse ls2
  putStrLn $ map head $ IM.elems mZ

main1 = body step1
```

</div></details>
-->
<h1 id="パート2-33"><a class="header" href="#パート2-33">パート2</a></h1>
<p>クレーンのオペレーターが木枠を巧みに再配置するのを見ていると、
手順があなたの予測とは違った進み方をしていることに気付きます。</p>
<p>クレーンの側面の文字に泥がかぶっていたので、さっと拭き取ります。
クレーンはCrateMover 9000ではありません。これは<strong>CrateMover 9001</strong>です。</p>
<p>CrateMover 9001は、多くの新しくエキサイティングな機能で有名です：
エアコン、革張りのシート、追加のカップホルダー、
そして<strong>複数の木箱を一度に持ち上げて移動する機能</strong>。</p>
<p>上記の例をもう一度考えます。木箱は同じ構成で始まります。</p>
<pre><code>    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 
</code></pre>
<p>単一の木箱をスタック2からスタック1に移動すると、以前と同じように動作します。</p>
<pre><code>[D]        
[N] [C]    
[Z] [M] [P]
 1   2   3 
</code></pre>
<p>しかし、スタック1からスタック3に3つの木箱を移動させる動作は、
これらの移動された3つの木箱<strong>順序が同じまま</strong>であることを意味し、次の新しい構成になります。</p>
<pre><code>        [D]
        [N]
    [C] [Z]
    [M] [P]
 1   2   3
</code></pre>
<p>次に、両方の木箱がスタック2からスタック1に移動され、<strong>順序も保持</strong>されます。</p>
<pre><code>        [D]
        [N]
[C]     [Z]
[M]     [P]
 1   2   3
</code></pre>
<p>最後に1つの木箱がスタック1からスタック2に移されます。今回移動されるのは木箱<code>C</code>です。</p>
<pre><code>        [D]
        [N]
        [Z]
[M] [C] [P]
 1   2   3
</code></pre>
<p>この例では、CrateMover 9001が木箱をまったく異なる順序 <code>MCD</code> に配置しています。</p>
<p>再配置プロセスが完了する前に、シミュレーションを更新して、
小人が最後の物資を降ろす準備をして待つべき場所を把握できるようにします。
<strong>再配置手順が完了した後、各スタックの一番上にある木箱は何ですか？</strong></p>
<!--
<details><summary>解説</summary><div>

スタックの要素をひとつずつ移動させる代わりに、
指定された個数分だけ一度に、同じ順で移す。

```haskell
step2 :: IM.IntMap String -> (Int,Int,Int) -> IM.IntMap String
step2 m1 (a,b,c) = IM.insert c imc $ IM.insert b imb2 m1
  where
    (imb1, imb2) = splitAt a (m1 IM.! b)
    imc = imb1 ++ m1 IM.! c

main2 = body step2
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-日目-チューニングのトラブル"><a class="header" href="#6-日目-チューニングのトラブル">6 日目: チューニングのトラブル</a></h1>
<p>準備がようやく完了しました。
あなたは小人たちと徒歩でキャンプを出発し、スターフルーツの果樹園に向けて進み始めます。</p>
<p>密集した下草の中を移動していると、小人の1人が携帯<strong>装置</strong>を渡してくれます。
彼はそれが多くの素晴らしい機能を持っていると言いますが、今セットアップする最も重要なものは<strong>通信システム</strong>です.</p>
<p>しかし、あなたは信号ベースのシステムを扱った経験が豊富
（[2016/6][2016/25][2019/7][2019/9][2019/16][2021/25]）
だと聞いたので、
彼は他の小人に、彼らの故障したデバイスを1つ渡しても大丈夫だと確信させました。
もちろんあなたは簡単にそれを直せるでしょう。</p>
<p>コントのようなタイミングで、その装置はカラフルな火花をいくらか放ちます。</p>
<p>小人と通信できるようにするには、<strong>装置が小人の信号にロックオン</strong>する必要があります。
信号は、装置が一度に1つずつ受信する、一見ランダムな文字列です。</p>
<p>通信システムを修正するには、データストリームから<strong>パケット開始マーカー</strong>を検出する
サブルーチンをデバイスに追加する必要があります。
小人が使用しているプロトコルでは、パケットの開始は、<strong>全て異なる4文字の列</strong>によって示されます。</p>
<p>装置はサブルーチンにデータストリームバッファ（パズル入力）を送信します。
サブルーチンは、受信した直近4文字が全て異なっている最初の位置を特定する必要があります。
具体的には、バッファの先頭から最初の4文字マーカーの末尾までの文字数を報告する必要があります。</p>
<p>例えば、次のデータストリーム バッファを受け取ったとします：</p>
<pre><code>mjqjpqmgbljsphdztnvjfqwrcgsmlb
</code></pre>
<p>最初の3文字 (<code>mjq</code>) が受信された後、マーカーを見つけるのに十分な文字がまだ受信されていません。
最初にマーカーが発生する可能性があるのは4文字めが受信された後で、
すると最新の4文字は <code>mjqj</code> となります。
<code>j</code> が繰り返されているため、これはマーカーではありません。</p>
<p>最初にマーカーが現れるるのは<strong>7文字め</strong>が到着した後です。
そのとき、直近で受け取った4文字は <code>jpqm</code> であり、これは全てが異なります。
この場合、7文字が処理された後に最初のパケット開始マーカーが完成するため、
サブルーチンは値7を報告する必要があります。</p>
<p>次にいくつかの例を示します。</p>
<ul>
<li><code>bvwbjplbgvbhsrlpgdmjqwftvncz</code> : 最初のマーカーは5文字後</li>
<li><code>nppdvjthqldpwncqszvftbrmjlhg</code> : 最初のマーカーは6文字後</li>
<li><code>nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg</code> : 最初のマーカーは10文字後</li>
<li><code>zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw</code> : 最初のマーカーは11文字後</li>
</ul>
<p><strong>最初のパケット開始マーカーが検出されるまでに、何文字を処理する必要がありますか？</strong></p>
<!--
<details><summary>解説</summary><div>

全ての位置から開始した4文字の並びを作るには、`Data.List.Split.divvy` も使えるが、
`map (take 4) . tails` でできる。

これを `nub` しても4文字のままであるものの先頭がいくつめかを数え、文字の長さ分補正する。

なぜか、マーカーの長さをパラメータ化しておいてみる。

```haskell
main1 = readFile "input.txt" >>= print . detect 4

detect :: Int -> String -> Int
detect k = (k +) . length . takeWhile id . map ((k >) . length . nub . take k) . tails
```

</div></details>
-->
<h1 id="パート2-34"><a class="header" href="#パート2-34">パート2</a></h1>
<p>装置の通信システムはパケットを正しく検出していますが、まだ正しく動きません。
<strong>メッセージ</strong>も探す必要があるようです。</p>
<p><strong>メッセージ開始マーカー</strong>は、パケット開始マーカーと同じですが、4文字ではなく<strong>異なる14文字</strong>で構成される点が異なります。</p>
<p>上記の全ての例のメッセージ開始マーカーの最初の位置は次のとおりです。</p>
<ul>
<li><code>mjqjpqmgbljsphdztnvjfqwrcgsmlb</code> : 最初のマーカーは19文字後</li>
<li><code>bvwbjplbgvbhsrlpgdmjqwftvncz</code> : 最初のマーカーは23文字後</li>
<li><code>nppdvjthqldpwncqszvftbrmjlhg</code> : 最初のマーカーは23文字後</li>
<li><code>nznrnfrfntjfmvfwmzdfjlvtqnbhcprsg</code> : 最初のマーカーは29文字後</li>
<li><code>zcfzfwzzqfrljwzlrfnpqdbhtmscgvjw</code> : 最初のマーカーは26文字後</li>
</ul>
<p><strong>最初のメッセージ開始マーカーが検出されるまでに、何文字を処理する必要がありますか？</strong></p>
<!--
<details><summary>解説</summary><div>

パラメータ化しておいたので、それを変更するだけ。

```haskell
main2 = readFile "input.txt" >>= print . detect 14
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-日目-デバイスに空き容量がありません"><a class="header" href="#7-日目-デバイスに空き容量がありません">7 日目: デバイスに空き容量がありません</a></h1>
<p>遠征が進むにつれて、鳥のさえずりや雨滴が葉に当たる音が聞こえます。
時折、遠くでもっと大きな音が聞こえることさえあります。
どれくらい大きな動物が現れるのでしょう？</p>
<p>小人があなたにくれた装置には、通信システム以外にも問題があります。
システムアップデートを実行しようとすると、次のようになります。</p>
<pre><code>$ system-update --please --pretty-please-with-sugar-on-top
Error: No space left on device
</code></pre>
<p>おそらく、いくつかのファイルを削除することで、
アップデートのための空き容量を確保できるでしょう。</p>
<p>ファイルシステムをあちこち調べて状況を評価し、
結果の端末出力 (パズルの入力) を保存します。
それは例えば次のようなものです：</p>
<pre><code>$ cd /
$ ls
dir a
14848514 b.txt
8504156 c.dat
dir d
$ cd a
$ ls
dir e
29116 f
2557 g
62596 h.lst
$ cd e
$ ls
584 i
$ cd ..
$ cd ..
$ cd d
$ ls
4060174 j
8033020 d.log
5626152 d.ext
7214296 k
</code></pre>
<p>ファイルシステムは、ファイル（単なるデータ）とディレクトリ（他のディレクトリやファイルを含むことができる）の木で構成されます。
一番外側のディレクトリは <code>/</code> と呼ばれます。
ファイルシステムをナビゲートし、ディレクトリを出入りして、現在いるディレクトリの内容を一覧表示できます。</p>
<p>端末出力内で、 <code>$</code> で始まる行は<strong>実行したコマンド</strong>です。
これは最近のコンピュータと非常によく似ています。</p>
<ul>
<li><code>cd</code> は<strong>ディレクトリの変更</strong>を意味します。
これは現在のディレクトリを変更しますが、具体的な結果は引数によって異なります。
<ul>
<li><code>cd x</code> 1レベル<strong>中に入り</strong>ます。
現在のディレクトリで <code>x</code> という名前のディレクトリを探し、それを現在のディレクトリにします。</li>
<li><code>cd ..</code> 1レベル<strong>外に出</strong>ます。
現在のディレクトリを含むディレクトリを見つけ、そのディレクトリを現在のディレクトリにします。</li>
<li><code>cd /</code> 現在のディレクトリを最も外側のディレクトリに切り替えます。</li>
</ul>
</li>
<li><code>ls</code> <strong>リスト</strong>を意味します。現在のディレクトリに直接含まれる全てのファイルとディレクトリを出力します。
<ul>
<li><code>123 abc</code> は、現在のディレクトリに <code>abc</code> という名前で大きさ <code>123</code> のファイルが含まれていることを意味します。</li>
<li><code>dir xyz</code> は、現在のディレクトリに <code>xyz</code> という名前のディレクトリが含まれていることを意味します。</li>
</ul>
</li>
</ul>
<p>上記の例のコマンドと出力から、ファイルシステムが視覚的に次のようになっていることがわかります。</p>
<pre><code>- / (dir)
  - a (dir)
    - e (dir)
      - i (file, size=584)
    - f (file, size=29116)
    - g (file, size=2557)
    - h.lst (file, size=62596)
  - b.txt (file, size=14848514)
  - c.dat (file, size=8504156)
  - d (dir)
    - j (file, size=4060174)
    - d.log (file, size=8033020)
    - d.ext (file, size=5626152)
    - k (file, size=7214296)
</code></pre>
<p>ここには4つのディレクトリがあります。
<code>/</code> （最外のディレクトリ）、<code>a</code> と <code>d</code> (<code>/</code>にある) と <code>e</code>(<code>a</code> にある) です。
これらのディレクトリには、さまざまな大きさのファイルも含まれています。</p>
<p>ディスクがいっぱいなので、あなたの最初の一手はきっと、
削除するのに適したディレクトリを見つけることです。
これを行うには、各ディレクトリの<strong>合計サイズ</strong>を求める必要があります。
ディレクトリの合計サイズは、直接的または間接的に含まれるファイルのサイズの合計です。
（ディレクトリ自体は、固有のサイズを持っているとは見なしません。）</p>
<p>上記のディレクトリの合計サイズは次のようになります。</p>
<ul>
<li>ディレクトリ <code>e</code> の合計サイズは<strong>584</strong>です。
というのは、それがサイズ584のファイル<code>i</code>だけを持っており、他のディレクトリがないためです。</li>
<li>ディレクトリ <code>a</code> には、ファイル<code>f</code>(サイズ29116)、<code>g</code>(サイズ2557)、<code>h.lst</code>(サイズ 62596)が含まれており、
さらにファイル<code>i</code>を間接的に持つ（<code>j</code>を持つ<code>e</code>を<code>a</code>は含む）ため、合計サイズは<strong>94853</strong>です。</li>
<li>ディレクトリ <code>d</code> の合計サイズは24933642です。</li>
<li>最も外側のディレクトリである <code>/</code> には全てのファイルが含まれます。
その合計サイズは48381165で、これは全てのファイルのサイズの合計です。</li>
</ul>
<p>まず、合計サイズが<strong>100000以下</strong>のディレクトリをすべて見つけてから、
それらの合計サイズの合計を計算します。
上記の例では、そのようなディレクトリは <code>a</code> と <code>e</code> です。
それらの合計サイズの合計は <strong>95437</strong> (94853 + 584) です。
（この例のように、この手順はファイルを複数回勘定します！）</p>
<p>合計サイズが100000以下の全てのディレクトリを見つけます。
<strong>これらのディレクトリの合計サイズの合計はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

`cd`コマンドはカレントディレクトリを変更する。
`ls`コマンドの結果は、カレントディレクトリにあるファイルの容量リストが続くことを意味する。
存在しないディレクトリに`cd`することはないと仮定する。（エラーメッセージの形式が説明されていないため。）
同じディレクトリで複数回`ls`する可能性は気に掛けておく。

ディレクトリごとにそこに含まれるファイルの容量の合計が知りたいが、
ディレクトリが入れ子になっていることも配慮しないといけない。
そこで、ディレクトリやファイルの完全パス名を名前のの文字列の（逆順の）リストで表現し、
完全パス名にそのファイルの容量を対応付けたペアのリストから、そのマップを作ることで重複を払拭する。

カレントディレクトリという状態を持ちまわすため、`mapAccumL`を用いる。
ファイル容量を報告しない行もあるので、出力は`Maybe`で包む。

```haskell
import qualified Data.Map as M
import Data.List
import Data.Maybe

parseFile :: [String] -> M.Map [String] Int
parseFile = M.fromList . catMaybes . snd . mapAccumL step []
  where
    step :: [String] -> String -> ([String], Maybe ([String], Int))
    step dir l =
      case words l of
        ["$", "cd", ".."] -> (tail dir, Nothing)
        ["$", "cd", "/"] -> ([], Nothing)
        ["$", "cd", d] -> (d:dir, Nothing)
        ["$", "ls"] -> (dir, Nothing)
        ["dir", _] -> (dir, Nothing)
        [n, fn] -> (dir, Just (fn:dir, read n))
        _ -> error $ "unexpected" ++ l
```

このマップの対応リストを取り出し、キーの`tails . tail`について容量をばらまいて足し合わせると、
全てのディレクトリについて、それが直接的または間接的に含むファイル容量のマップが作れる。

```haskell
accumlate :: M.Map [String] Int -> M.Map [String] Int
accumlate m = M.fromListWith (+)
  [(p, sz) | (path, sz) <- M.assocs m, p <- tails (tail path)]
```

ここから100000以下の容量を抜き出し、合計する。

```haskell
main1 = body1 "input.txt"

body1 fn = readFile fn >>= print . sum . filter (100000 >=) . M.elems . accumlate . parseFile . lines
```

</div></details>
-->
<h1 id="パート2-35"><a class="header" href="#パート2-35">パート2</a></h1>
<p>これで、削除するディレクトリを選択する準備が整いました。</p>
<p>ファイルシステムで利用できる合計ディスク容量は<strong>70,000,000</strong>です。
アップデートを実行するには、少なくとも<strong>30,000,000</strong>の空き使用容量が必要です。
アップデートを実行するのに<strong>十分なスペースを解放する</strong>、削除できるディレクトリを見つける必要があります。</p>
<p>上の例では、最も外側のディレクトリの合計サイズ（すなわち使用済み領域の合計）は48381165です。
これは、現在の空き容量が21618835であることを意味しますが、
これはアップデートに必要とされる30000000に足りません。
従って、更新を実行するには、合計サイズが8381165以上のディレクトリをひとつ削除する必要があります。</p>
<p>これを実現するには、次の選択肢があります。</p>
<ul>
<li>ディレクトリ <code>e</code> を削除すると、未使用領域が584だけ増えます。</li>
<li>ディレクトリ <code>a</code> を削除すると、未使用領域が94853だけ増えます。</li>
<li>ディレクトリ <code>d</code> を削除すると、未使用領域が24933642だけ増えます。</li>
<li>ディレクトリ <code>/</code> を削除すると、未使用領域が48381165だけ増えます。</li>
</ul>
<p>ディレクトリ<code>e</code>と<code>a</code>はどちらも小さすぎます。
それらを削除しても、十分なスペースが解放されません。
一方、ディレクトリ<code>d</code>とディレクトリ<code>/</code>はどちらも十分に大きいです。
これらの中から、最小の<code>d</code>を選択し、未使用スペースを24933642だけ増やします。</p>
<p>削除した場合に、
アップデートを実行するのに十分なスペースをファイルシステム上で解放する
最小のディレクトリを見つけます。
<strong>そのディレクトリの合計サイズはどれだけですか？</strong></p>
<!--
<details><summary>解説</summary><div>

間接的に含むものも入れた、各ディレクトリの容量マップは上で作った。
そのマップにおいて、`/` すなわち `[] :: [String]` に割り当てられた値が現在の総使用量。
\\(70,000,000 - root の使用量 + 解放容量 \geq 30,000,000\\)
すなわち
\\(解放容量 \geq rootの使用量 - 40,000,000\\)
を満たす最小の容量をマップから探す。

```haskell
main2 = body2 "input.txt"

body2 fn = do
  m <- accumlate . parseFile . lines <$> readFile fn
  let limit = m M.! [] - 40000000
  print . minimum . filter (limit <=) . M.elems $m
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="8日目-樹上の木の家"><a class="header" href="#8日目-樹上の木の家">8日目: 樹上の木の家</a></h1>
<p>遠征隊は、格子状に注意深く植えられた背の高い木の独特の区画に出くわします。
小人たちは、以前の遠征で、森林再生の取り組みとしてこれらの木を植えたと説明しています。
今、彼らはこれがツリーハウスに適した場所であるかどうかに興味を持っています.</p>
<p>まず、ツリーハウスを<strong>隠す</strong>のに十分な樹木がここにあるかどうかを判断します。
これを行うには、行または列に沿ってまっすぐ見たときに、<strong>グリッドの外側から見える</strong>木の数を数える必要があります。</p>
<p>小人は既に<a href="https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AF%E3%83%83%E3%83%89%E3%83%AD%E3%83%BC%E3%82%BF%E3%83%BC">ドローン</a>を発進させ、
それぞれの木の高さの地図を生成しています（パズル入力）。例えば：</p>
<pre><code>30373
25512
65332
33549
35390
</code></pre>
<p>それぞれの木は数字1文字で表されます。その値が木の高さです。
ここで<code>0</code>は最も短く、<code>9</code>が最も高いです。</p>
<p>ひとつの木に関して、その木とグリッドの外周までの間にある他の全ての木がその木<strong>よりも低い</strong>とき、
その木は<strong>外から見える</strong>状態です。
同じ行または列にある木のみを考慮します。
つまり、その木から上、下、左、右だけを見てください。</p>
<p>グリッドの端にある全ての木は<strong>見えます</strong>。
これらはすでに端にあるため、視界を遮る木はありません。
この例では、これにより考慮すべき木として<strong>内部の9本</strong>のみが残ります。</p>
<ul>
<li>左上の<code>5</code>は左と上から<strong>見えます</strong>。
（右や下からは見えません、途中に高さ<code>5</code>の他の木があるからです。）</li>
<li>上中央の<code>5</code>は上と右から見えます。</li>
<li>右上の<code>1</code>はどの方向からも見えません。
それが見えるようにするには、それと外周までの間は高さ0の木だけでないといけません。</li>
<li>左中央の<code>5</code>は<strong>見えます</strong>が、右からのみです。</li>
<li>中心の<code>3</code>はどの方向からも見えません。
それが見えるようにするには、それと外周までの間は高さ2以下の木だけでないといけません。</li>
<li>右中央の3は右から<strong>見えます</strong>。</li>
<li>一番下の行では、中央の5は<strong>見えます</strong>が、3と4は見えません。</li>
</ul>
<p>端にある16本の木が見え、その他に内部にある木の5本が見えるので、
この配置では合計で21本の木が見えます。</p>
<p>あなたの地図について考えてください。
<strong>グリッドの外から見える木は何本ありますか？</strong></p>
<!--
<details><summary>解説</summary><div>

地図データを読み込んだら、行ごとに分け、地図の高さと幅も数えておく。

```haskell
dss <- lines <$> readFile "input.txt"
let h = length dss
let w = length $ head dss
```

ひとつの方向から見たときの木の高さの列があるとき、
前から順にそれらが見えるかどうかを判定するには、
手前までの最大値よりも自分が高いかどうかを比較すればよい。
ただし先頭については、それより手前の最大値が求められない点に注意する。

```haskell
check :: Ord a => [a] -> [Bool]
check xs = True : zipWith (<>) (scanl1 max xs) (tail xs)
```

`dss`に対して、
それぞれに`check`をそのまま適用すると左から、`reverse`してから適用すると右から、
`transpose`した結果へそれぞれに適用すると上から、さらに`reverse`すると下から、
見えるかどうかの判定結果が得られる。

木のそれぞれがいずれかの方向から見えるかどうかは、
この4方向からの結果のいずれかで見えればよいので、
`accumArray`でこれを足し合わせて数える。

```haskell
tdss = transpose dss
arr = accumArray (||) False ((1,1),(h,w)) $
  [((i,j), True) | (i,ds) <- zip [1..] dss , (j,True) <- zip [1..] (check ds)] ++
  [((i,j), True) | (i,ds) <- zip [1..] dss , (j,True) <- zip [w, pred w..] (check $ reverse ds)] ++
  [((i,j), True) | (j,ds) <- zip [1..] tdss, (i,True) <- zip [1..] (check ds)] ++
  [((i,j), True) | (j,ds) <- zip [1..] tdss, (i,True) <- zip [h, pred h..] (check $ reverse ds)]
```

この配列の中の `True` の個数が答えである。

```haskell
length . filter id . elems $ arr
```

</div></details>
-->
<h1 id="パート2-36"><a class="header" href="#パート2-36">パート2</a></h1>
<p>視界を覆う木の量に満足している小人たちは、ツリーハウスを建てるのに最適な場所だけが知りたいです。
彼らはたくさんの<strong>木</strong>を見たいと思っています。</p>
<p>ひとつの木に対して、そこからの見通しを測定するには、その木から上、下、左、右を見ます。
外周に到達した場合、または対象の木と同じ高さまたはそれよりも高い最初の木に到達した場合に停止します。
（木が端にある場合、少なくとも1つの見通しは零になります。）</p>
<p>小人たちは、上記の規則で見つかったものよりも背の高い遠くの木を気にしません。
提案されたツリーハウスには、乾燥を保つために大きな「ひさし」が付いているため、
いずれにせよツリーハウスより高いところを見ることはできません。</p>
<p>上の例で、2 行目中央の<code>5</code>を考えてみましょう：</p>
<pre><code>30 3 73
25[5]12
65 3 32
33 5 49
35 3 90
</code></pre>
<ul>
<li>見上げると、その視界は遮られていません。それは（高さ3の）1本の木を見ることができます。</li>
<li>左を見ると、その視界はすぐに遮られます。木は1本（高さ5、すぐ隣）のみを見ることができます。</li>
<li>右を見ると、その視界は遮られていません。木が2本見えます。</li>
<li>見下ろすと、その視界は最終的に遮られます。
2本の木を見ることができます（高さ3が1本、次に視界を遮る高さ5の木）。</li>
</ul>
<p>木の<strong>景観スコア</strong>は、4つの方向のそれぞれの見通しを<strong>掛け合わせる</strong>ことによって求められます。
この木の場合、その値は4（\(1 \times 1 \times 2 \times 2\)の掛け算により求められます）です。</p>
<p>しかし、もっとうまくやることができます：
4行目の真ん中にある高さ5の木を考えてみましょう：</p>
<pre><code>30 3 73
25 5 12
65 3 32
33[5]49
35 3 90
</code></pre>
<ul>
<li>見上げると、その視界は2本めの木で遮られています（高さ5の別の木によって）。</li>
<li>左を見ると、その視界は遮られていません。2本の木が見えます。</li>
<li>見下ろしても、視界も遮られません。1本の木が見えます。</li>
<li>右を見ると、その視界は2本めの木で遮られています (高さ9の巨木によって）。</li>
</ul>
<p>この木の景観スコアは8 \((2 \times 2 \times 1 \times 2)\) です。
ここがツリーハウスの理想の場所です。</p>
<p>マップ上のそれぞれの木を調べてください。
<strong>いずれかの木で達成される最大の景観スコアはいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

ある木から外周までの高さの列があるとき、その方向の見通しは、
その高さ以上になるまでの木の本数であるが、視界を遮ったその木も数える。
しかし、外周まで遮られずに視界が達したとき、数える木がないので、この二つを区別する必要がある。

```haskell
viewscore (x:xs) =
  case span (x >) xs of
    (as,[ ]) -> length as
    (as,_:_) -> succ $ length as
```

`reverse`を高速化するテクニックで、要素をひとつずつ移動させる内部関数を立てた。

```haskell
reverse xs = rev [] xs
  where
    rev ys [] = ys
    rev ys (x:xs) = rev (x:ys) xs
```

これと同様にして、一列の木の並びに対して、全ての木のそこから右とそこから左の見通しを同時に計算できる。

```haskell
part2sub ys [] = []
part2sub ys (x:xs) = viewscore ys * viewscore xs : part2sub (x:ys) xs
  where
    count zs = case span (x >) zs of
      (as,[]) -> length as
      (as,_ ) -> succ $ length as
```

あとは、全ての行と、パート1同様に`transpose`を用いて全ての列についてこれを行い、
結果を掛け合わせて最大値を見つける。

```haskell
part2 h w dss = maximumBy (compare `on` snd) . assocs $ arr
  where
    tdss = transpose dss
    arr = accumArray (*) 1 ((1,1),(h,w)) $
      [((i,j), s) | (i,ds) <- zip [1..] dss , (j,s) <- zip [1..] $ part2sub [] ds] ++
      [((i,j), s) | (j,ds) <- zip [1..] tdss, (i,s) <- zip [1..] $ part2sub [] ds]
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="9日目-吊り橋"><a class="header" href="#9日目-吊り橋">9日目: 吊り橋</a></h1>
<p>この吊り橋は、あなたが歩くと軋みます。
どれほど古いものなのか、あなたの体重を支えられるかどうかも怪しいです。</p>
<p>とはいえ、小人の体重を支えるぶんには大丈夫なようです。
橋は、あなたのはるか眼下の巨大な川によって切り開かれた峡谷にまたがっています。</p>
<p>あなたは慎重に足を踏み入れます。それにより、ロープは伸びてねじれます。
あなたは、ロープの物理をモデル化して気を紛らわせることにしました。
踏んではいけない場所を見つけることができるかもしれません。</p>
<p>両端に結び目があるロープを考えます。
これらの結び目は、ロープの<strong>頭</strong>と<strong>尾</strong>を示しています。
頭が尻尾から十分に離れると、尾は頭の方に引っ張られます。</p>
<p><a href="https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%A9%E3%83%B3%E3%82%AF%E9%95%B7">プランク長</a>
に関する漠然とした推論により、2次元グリッド上の結び目の位置をモデル化できるはずです。
すると、頭結び目の<strong>仮想的な一連の動き</strong>（パズルの入力）に従うことで、
<strong>尾</strong>がどのように動くかを決定できます。</p>
<p>前述のプランク長により、ロープはきわめて短くする必要があります。
実際、頭(<code>H</code>)と尾(<code>T</code>)は<strong>常に接触している</strong>必要があります。
（角で接している場合と、重なり合っている場合も、接触していると見なします。）</p>
<pre><code>....
.TH.
....

....
.H..
..T.
....

...
.H. (H は T に重なっている)
...
</code></pre>
<p>頭が尻尾から2歩上、下、左、右にある場合、尻尾もその方向に1歩移動して、十分に近い状態を保つ必要があります。</p>
<pre><code>.....    .....    .....
.TH.. -&gt; .T.H. -&gt; ..TH.
.....    .....    .....

...    ...    ...
.T.    .T.    ...
.H. -&gt; ... -&gt; .T.
...    .H.    .H.
...    ...    ...
</code></pre>
<p>それ以外の場合、頭と尾が接しておらず、同じ行または列にない場合、尾は常に1ステップ斜めに移動して追いつきます。</p>
<pre><code>.....    .....    .....
.....    ..H..    ..H..
..H.. -&gt; ..... -&gt; ..T..
.T...    .T...    .....
.....    .....    .....

.....    .....    .....
.....    .....    .....
..H.. -&gt; ...H. -&gt; ..TH.
.T...    .T...    .....
.....    .....    .....
</code></pre>
<p>頭が一連の動きに追従するときに、尾がどこに行くのかを理解する必要があります。
頭と尾の両方が同じ位置から始まり、重なり合っていると仮定します。</p>
<p>例えば：</p>
<pre><code>R 4
U 4
L 3
D 1
R 4
D 1
L 5
R 2
</code></pre>
<p>この一連の動作により、頭が<strong>右</strong>に4歩移動し、次に4歩<strong>上</strong>に移動し、
次に3歩<strong>左</strong>に移動し、次に1歩<strong>下</strong>に移動します。
各ステップの後、ステップによって頭が尾に隣接していない場合は、尾の位置を更新する必要があります。
視覚的には、これらの動きは次のように表せます。
（<code>s</code>は開始位置を示す印で、参照点です。）</p>
<pre><code>== 初期状態 ==

......
......
......
......
H.....  (H は T, s と重なっている)

== R 4 ==

......
......
......
......
TH....  (T は s と重なっている)

......
......
......
......
sTH...

......
......
......
......
s.TH..

......
......
......
......
s..TH.

== U 4 ==

......
......
......
....H.
s..T..

......
......
....H.
....T.
s.....

......
....H.
....T.
......
s.....

....H.
....T.
......
......
s.....

== L 3 ==

...H..
....T.
......
......
s.....

..HT..
......
......
......
s.....

.HT...
......
......
......
s.....

== D 1 ==

..T...
.H....
......
......
s.....

== R 4 ==

..T...
..H...
......
......
s.....

..T...
...H..
......
......
s.....

......
...TH.
......
......
s.....

......
....TH
......
......
s.....

== D 1 ==

......
....T.
.....H
......
s.....

== L 5 ==

......
....T.
....H.
......
s.....

......
....T.
...H..
......
s.....

......
......
..HT..
......
s.....

......
......
.HT...
......
s.....

......
......
HT....
......
s.....

== R 2 ==

......
......
.H....  (H は T と重なっている)
......
s.....

......
......
.TH...
......
s.....
</code></pre>
<p>ロープのシミュレーションを実施すると、
<strong>尾が少なくとも一度訪れた</strong>全ての位置を数えることができます。
この図では、<code>s</code>は今回も開始位置（これは尾も訪問している）、
<code>#</code>は尾が訪問したその他の位置を印しています。</p>
<pre><code>..##..
...##.
.####.
....#.
s###..
</code></pre>
<p>したがって、13箇所が、尾が少なくとも一度訪れた位置です。</p>
<p>完全に架空の一連の動作をシミュレーションしてください。
<strong>ロープの尾が少なくとも一度訪れる位置は何か所ですか？</strong></p>
<!--
<details><summary>解説</summary><div>

- 頭は4近傍で1ずつだけ移動する。
- 尾は頭と横軸縦軸ともに差が1までなら許容される。（動かない）
- いずれかの軸はずれておらず、もう一方の軸だけ2ずれた場合、そのずれを1修正して4近傍に移動する。
- 両方の軸がずれた場合、両方について補正をかける。

この規則に合うように、頭の位置と尾の位置から、尾の新しい位置を求める計算を定義する。

```haskell
follow (tx,ty) (hx,hy)
  | abs dx <= 1 && abs dy <= 1 = (tx,ty)
  | dx == 0 = (tx, ty1)
  | dy == 0 = (tx1, ty)
  | otherwise = (tx1, ty1)
  where
    dx = hx - tx
    dy = hy - ty
    tx1 = tx + signum dx
    ty1 = ty + signum dy
```

あとは、ファイルを読み込み、頭の位置の系列を作る
尾を追尾させ、その座標を集合に入れて、要素数を数える。

```haskell
import qualified Data.Set as S

main1 = body1 "input.txt"
test1 = body1 "test.txt"

body1 fn = readFile fn >>= print . compute1 . lines

compute1 :: [String] -> Int
compute1 ls = S.size $ S.fromList tailPoss
  where
    headPoss =
      scanl add (0,0) $
      concatMap ((\[d,n] -> replicate (read n) (delta $ head d)) . words) ls
    tailPoss = scanl follow (0,0) headPoss

add (x,y) (z,w) = (x+z, y+w)

delta 'U' = (0,-1)
delta 'D' = (0, 1)
delta 'L' = (-1,0)
delta 'R' = ( 1,0)
```

</div></details>
-->
<h1 id="パート2-37"><a class="header" href="#パート2-37">パート2</a></h1>
<p>ロープがプツリと切れる！
突然、川はあなたがこれまでに見たことのあるよりもはるかに近づいています。
橋はまだそこにありますが、千切れたロープの一部は、空中を落下しつつあるあなたに向かって鞭打っています!</p>
<p>ロープの動きが速すぎて掴めません。
叩かれるのを避けるために体を反らせる方法を選択するのに数秒しかありません。
幸いなことに、シミュレーションを拡張して、より長いロープに対応できます。</p>
<p>結び目が2つではなく、<strong>10</strong>個の結び目で構成されるロープをシミュレーションする必要があります。
結び目のひとつはやはりロープの頭で、一連の動きに従って動きます。
ロープの続きにある結び目はそれぞれ、前と同じ規則を使用して、その直前の結び目に従います。</p>
<p>上記の例と同じ一連の動きを使用しますが、
結び目を<code>H</code>,<code>1</code>,<code>2</code>,…,<code>9</code>と印すと、動きは次のようになります。</p>
<pre><code>== 初期状態 ==

......
......
......
......
H.....  (H は 1, 2, 3, 4, 5, 6, 7, 8, 9, s と重なっている)

== R 4 ==

......
......
......
......
1H....  (1 は 2, 3, 4, 5, 6, 7, 8, 9, s と重なっている)

......
......
......
......
21H...  (2 は 3, 4, 5, 6, 7, 8, 9, s と重なっている)

......
......
......
......
321H..  (3 は 4, 5, 6, 7, 8, 9, s と重なっている)

......
......
......
......
4321H.  (4 は 5, 6, 7, 8, 9, s と重なっている)

== U 4 ==

......
......
......
....H.
4321..  (4 は 5, 6, 7, 8, 9, s と重なっている)

......
......
....H.
.4321.
5.....  (5 は 6, 7, 8, 9, s と重なっている)

......
....H.
....1.
.432..
5.....  (5 は 6, 7, 8, 9, s と重なっている)

....H.
....1.
..432.
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

== L 3 ==

...H..
....1.
..432.
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

..H1..
...2..
..43..
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

.H1...
...2..
..43..
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

== D 1 ==

..1...
.H.2..
..43..
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

== R 4 ==

..1...
..H2..
..43..
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

..1...
...H..  (H は 2 と重なっている)
..43..
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

......
...1H.  (1 は 2 と重なっている)
..43..
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

......
...21H
..43..
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

== D 1 ==

......
...21.
..43.H
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

== L 5 ==

......
...21.
..43H.
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

......
...21.
..4H..  (H は 3 と重なっている)
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

......
...2..
..H1..  (H は 4と、1 は 3 と重なっている)
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

......
...2..
.H13..  (1 は 4 と重なっている)
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

......
......
H123..  (2 は 4 と重なっている)
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

== R 2 ==

......
......
.H23..  (H は 1 と、2 は 4 と重なっている)
.5....
6.....  (6 は 7, 8, 9, s と重なっている)

......
......
.1H3..  (H は 2, 4 と重なっている)
.5....
6.....  (6 は 7, 8, 9, s と重なっている)
</code></pre>
<p>さて、新たな尾<code>9</code>が訪れる位置を追跡する必要があります。
この例では、尻尾は決して動かないため、1箇所を訪問するだけです。
ただし<strong>注意してください</strong>。
以前よりも多くの種類の動きが可能になるため、
あなたのシミュレーションによるロープと上のロープを視覚的に比較することをお勧めします。</p>
<p>より大きな例を次に示します。</p>
<pre><code>R 5
U 8
L 8
D 3
R 17
D 10
L 25
U 20
</code></pre>
<p>これらの動作は次のようになります (個々のステップは示されていません)。</p>
<pre><code>== 初期状態 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........H..............  (H は 1, 2, 3, 4, 5, 6, 7, 8, 9, s と重なっている)
..........................
..........................
..........................
..........................
..........................

== R 5 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........54321H.........  (5 は 6, 7, 8, 9, s と重なっている)
..........................
..........................
..........................
..........................
..........................

== U 8 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
................H.........
................1.........
................2.........
................3.........
...............54.........
..............6...........
.............7............
............8.............
...........9..............  (9 は s と重なっている)
..........................
..........................
..........................
..........................
..........................

== L 8 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
........H1234.............
............5.............
............6.............
............7.............
............8.............
............9.............
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
..........................

== D 3 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
.........2345.............
........1...6.............
........H...7.............
............8.............
............9.............
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
..........................

== R 17 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
................987654321H
..........................
..........................
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
..........................

== D 10 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........s.........98765
.........................4
.........................3
.........................2
.........................1
.........................H

== L 25 ==

..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
H123456789................

== U 20 ==

H.........................
1.........................
2.........................
3.........................
4.........................
5.........................
6.........................
7.........................
8.........................
9.........................
..........................
..........................
..........................
..........................
..........................
...........s..............
..........................
..........................
..........................
..........................
..........................
</code></pre>
<p>こうして、尾(<code>9</code>)は36箇所（<code>s</code>を含む）を少なくとも一度訪問します。</p>
<pre><code>..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
..........................
#.........................
#.............###.........
#............#...#........
.#..........#.....#.......
..#..........#.....#......
...#........#.......#.....
....#......s.........#....
.....#..............#.....
......#............#......
.......#..........#.......
........#........#........
.........########.........
</code></pre>
<p>結び目の10個ある長いロープの一連の動作をシミュレーションします。
<strong>ロープの尾が少なくとも一度訪れる位置は何か所ですか？</strong></p>
<!--
<details><summary>解説</summary><div>

「前の結び目の位置を追尾した列を作る」という計算を9回重ねて実行するように変更する。

```haskell
main2 = body2 "input.txt"
test2 = body2 "test.txt"
test3 = body2 "test2.txt"

body2 fn = readFile fn >>= print . S.size . compute2 . lines

compute2 :: [String] -> S.Set (Int,Int)
compute2 ls = S.fromList tailPoss
  where
    headPoss =
      scanl add (0,0) $
      concatMap ((\[d,n] -> replicate (read n) (delta $ head d)) . words) ls
    knot xys = scanl follow (0,0) xys
    tailPoss = iterate knot headPoss !! 9
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="10日目-ブラウン管-crt"><a class="header" href="#10日目-ブラウン管-crt">10日目: ブラウン管 (CRT)</a></h1>
<p>ロープを避け、川に飛び込み、岸まで泳ぎます。</p>
<p>小人は上流で彼らと再会することについて何かを叫んでいますが、
川の流れが騒がしすぎて彼らが何を言っているのか正確にはわかりません。
彼らは橋を渡り終え、視界から消えます。</p>
<p>小人があなたの携帯端末の通信システムを機能させることを優先した理由こそ、
このような状況に違いありません。
リュックから取り出してみると、画面の大きなひび割れからゆっくりと水が流れ出ていて、
すぐにはあまり役に立たないことがわかります。</p>
<p><strong>そうでもない！</strong>
つまり、あなたは装置のビデオシステムの代替品を設計できるからです！
それは、正確な<strong>クロック回路</strong>で駆動される、
ある種の<a href="https://ja.wikipedia.org/wiki/%E3%83%96%E3%83%A9%E3%82%A6%E3%83%B3%E7%AE%A1">ブラウン管</a>画面と
簡単なCPUのようです。
クロック回路は一定の速さで時を刻みます。それぞれの刻みを<strong>サイクル</strong>と呼びます。</p>
<p>まず、CPUから送信されている信号を理解することから始めます。
CPUには単一のレジスタ<code>X</code>があります。これは値<code>1</code>で始まります。
CPUは次の2つの命令のみをサポートします。</p>
<ul>
<li><code>addx V</code> 完了するまでに<strong>2サイクル</strong>かかります。
2サイクル<strong>後</strong>、<code>X</code>レジスタは値<code>V</code>だけ増加します。
（<code>V</code>は負の値になることもあります。）</li>
<li><code>noop</code> 完了するまでに<strong>1サイクル</strong>かかります。それ以外の効果はありません。</li>
</ul>
<p>CPUは、プログラム（パズル入力）にあるこれらの命令を使用して、
どういうわけか、何を描画するかを画面に伝えます。</p>
<p>次の小さなプログラムを考えましょう：</p>
<pre><code>noop
addx 3
addx -5
</code></pre>
<p>このプログラムの実行は次のように進行します。</p>
<ul>
<li>最初のサイクルの開始時に、<code>noop</code>命令の実行が開始されます。
最初のサイクルでは、<code>X</code>は<code>1</code>です。
最初のサイクルの後、<code>noop</code>命令は何もせずに実行を終了します。</li>
<li>2番目のサイクルの開始時に、<code>addx 3</code>命令の実行が開始されます。
2番目のサイクル中は、<code>X</code>はまだ<code>1</code>です。</li>
<li>3番目のサイクルでは、<code>X</code>はまだ<code>1</code>です。
3番目のサイクルの後、<code>addx 3</code>命令は実行を終了し、<code>X</code>は<code>4</code>に設定されます。</li>
<li>4番目のサイクルの開始時に、<code>addx -5</code>命令の実行が開始されます。
4番目のサイクルの間、<code>X</code>はまだ<code>4</code>です。</li>
<li>5番目のサイクルの間、<code>X</code>はまだ<code>4</code>です。
5番目のサイクルの後、<code>addx -5</code>命令は実行を終了し、<code>X</code>は<code>-1</code>に設定されます。</li>
</ul>
<p>実行中にレジスタ<code>X</code>の値を観察することで、何かを学ぶことができるかもしれません。
ここでは、20番目のサイクルとその後40サイクルごと
（つまり、20番目、60番目、100番目、140番目、180番目、220番目のサイクル）の信号強度
（サイクル数に<code>X</code>レジスタの値を乗じた値）を考えてみましょう。</p>
<p>例えば、次のもう少し大きいプログラムを考えてみましょう：</p>
<pre><code>addx 15
addx -11
addx 6
addx -3
addx 5
addx -1
addx -8
addx 13
addx 4
noop
addx -1
addx 5
addx -1
addx 5
addx -1
addx 5
addx -1
addx 5
addx -1
addx -35
addx 1
addx 24
addx -19
addx 1
addx 16
addx -11
noop
noop
addx 21
addx -15
noop
noop
addx -3
addx 9
addx 1
addx -3
addx 8
addx 1
addx 5
noop
noop
noop
noop
noop
addx -36
noop
addx 1
addx 7
noop
noop
noop
addx 2
addx 6
noop
noop
noop
noop
noop
addx 1
noop
noop
addx 7
addx 1
noop
addx -13
addx 13
addx 7
noop
addx 1
addx -33
noop
noop
noop
addx 2
noop
noop
noop
addx 8
noop
addx -1
addx 2
addx 1
noop
addx 17
addx -9
addx 1
addx 1
addx -3
addx 11
noop
noop
addx 1
noop
addx 1
noop
noop
addx -13
addx -19
addx 1
addx 3
addx 26
addx -30
addx 12
addx -1
addx 3
addx 1
noop
noop
noop
addx -9
addx 18
addx 1
addx 2
noop
noop
addx 9
noop
noop
noop
addx -1
addx 2
addx -37
addx 1
addx 3
noop
addx 15
addx -21
addx 22
addx -6
addx 1
noop
addx 2
addx 1
noop
addx -10
noop
noop
addx 20
addx 1
addx 2
addx 2
addx -6
addx -11
noop
noop
noop
</code></pre>
<p>興味のある信号強度は、次のように求められます：</p>
<ul>
<li>20番目のサイクルでは、 レジスタ<code>X</code>の値は<code>21</code>であるため、信号強度は\(20 \times 21 = 420\)です。
(20番目のサイクルは二つめの<code>addx -1</code>の途中で起き、
このときのレジスタ<code>X</code>の値は、開始値の<code>1</code>と、この位置までの全ての<code>addx</code>命令の値を足し合わせた値となります。
\(1 + 15 - 11 + 6 - 3 + 5 - 1 - 8 + 13 + 4 = 21\)</li>
<li>60番目のサイクルでは、レジスタ<code>X</code>の値は<code>19</code>であるため、信号強度は\(60 \times 19 = 1140\)です。</li>
<li>100番目のサイクルでは、レジスタ<code>X</code>の値は<code>18</code>であるため、信号強度は\(100 \times 18 = 1800\)です。</li>
<li>140番目のサイクルでは、レジスタ<code>X</code>の値は<code>21</code>であるため、信号強度は\(140 \times 21 = 2940\)です。</li>
<li>180番目のサイクルでは、レジスタ<code>X</code>の値は<code>16</code>であるため、信号強度は\(180 \times 16 = 2880\)です。</li>
<li>220番目のサイクルでは、レジスタ<code>X</code>の値は<code>18</code>であるため、信号強度は\(220 \times 18 = 3960\)です。</li>
</ul>
<p>これらの信号強度の合計は<strong>13140</strong>です。</p>
<p>20回目、60回目、100回目、140回目、180回目、220回目のサイクルの信号強度を求めます。
<strong>これらの6つの信号強度の合計はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

命令列を行ごとに区切って与える。
命令列によって、時間が流れてXの値が変化していく。
次のクロックの開始時のXの値を生成するループを作る。

```haskell
loop :: Int -> [String] -> [Int]
loop x (cs:css) =
  case words cs of
    ["noop"] -> x : loop x css
    ["addx",arg] -> let x1 = x + read arg in x : x1 : loop x1 css
loop x [] = [x]
```

必要な時刻のレジスタ値を抜き出して答えを計算する。

```haskell
body1 fn = do
  ls <- lines <$> readFile fn
  let xs = 0 : loop 1 ls
  print $ sum $ map (\i -> i * xs !! pred i) [20,60..220]

main1 = body1 "input.txt"
```

</div></details>
-->
<h1 id="パート2-38"><a class="header" href="#パート2-38">パート2</a></h1>
<p><code>X</code>レジスタが<a href="https://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%97%E3%83%A9%E3%82%A4%E3%83%88_(%E6%98%A0%E5%83%8F%E6%8A%80%E8%A1%93)">スプライト</a>の水平位置を制御しているようです。
具体的には、スプライトの幅は3ピクセルで、レジスタ<code>X</code>はそのスプライトの<strong>中央</strong>の水平位置を設定します。
（このシステムでは、「垂直位置」のようなものはありません。
CRTが現在描画している場所にスプライトの水平位置がピクセルを置くとき、
それらのピクセルが描画されます。）</p>
<p>あなたはCRTのピクセルを数えます: 幅40ピクセル、高さ6ピクセルです。
このCRT画面は、ピクセルの一番上の行を左から右に描画し、次にその下の行というように描画します。
各行の左端のピクセルは位置<code>0</code>にあり、各行の右端のピクセルは位置<code>39</code>にあります。</p>
<p>CPUと同様に、CRTはクロック回路と密接に結びついています。
CRTは<strong>各サイクルで1つのピクセルを描画します</strong>。
画面の各ピクセルを<code>#</code>で表して、
各行の最初と最後のピクセルが描画されるサイクルは次のとおりです。</p>
<pre><code>Cycle   1 -&gt; ######################################## &lt;- Cycle  40
Cycle  41 -&gt; ######################################## &lt;- Cycle  80
Cycle  81 -&gt; ######################################## &lt;- Cycle 120
Cycle 121 -&gt; ######################################## &lt;- Cycle 160
Cycle 161 -&gt; ######################################## &lt;- Cycle 200
Cycle 201 -&gt; ######################################## &lt;- Cycle 240
</code></pre>
<p>したがって、 CPU命令とCRT描画操作のタイミングを慎重に調整することで、
各ピクセルが描画された瞬間にスプライトが表示されるかどうかを決定できるはずです。
3つのピクセルのうちの1つが現在描画されているピクセルになるようにスプライトが配置された場合、
画面は<strong>点灯している</strong>ピクセル (<code>#</code>) を生成します。
そうでない場合、画面はピクセルを<strong>暗いまま</strong> (<code>.</code>) にします。</p>
<p>上の大きな例の最初の数ピクセルは、次のように描画されます。</p>
<pre><code>Sprite position: ###.....................................

Start cycle   1: begin executing addx 15
During cycle  1: CRT draws pixel in position 0
Current CRT row: #

During cycle  2: CRT draws pixel in position 1
Current CRT row: ##
End of cycle  2: finish executing addx 15 (Register X is now 16)
Sprite position: ...............###......................

Start cycle   3: begin executing addx -11
During cycle  3: CRT draws pixel in position 2
Current CRT row: ##.

During cycle  4: CRT draws pixel in position 3
Current CRT row: ##..
End of cycle  4: finish executing addx -11 (Register X is now 5)
Sprite position: ....###.................................

Start cycle   5: begin executing addx 6
During cycle  5: CRT draws pixel in position 4
Current CRT row: ##..#

During cycle  6: CRT draws pixel in position 5
Current CRT row: ##..##
End of cycle  6: finish executing addx 6 (Register X is now 11)
Sprite position: ..........###...........................

Start cycle   7: begin executing addx -3
During cycle  7: CRT draws pixel in position 6
Current CRT row: ##..##.

During cycle  8: CRT draws pixel in position 7
Current CRT row: ##..##..
End of cycle  8: finish executing addx -3 (Register X is now 8)
Sprite position: .......###..............................

Start cycle   9: begin executing addx 5
During cycle  9: CRT draws pixel in position 8
Current CRT row: ##..##..#

During cycle 10: CRT draws pixel in position 9
Current CRT row: ##..##..##
End of cycle 10: finish executing addx 5 (Register X is now 13)
Sprite position: ............###.........................

Start cycle  11: begin executing addx -1
During cycle 11: CRT draws pixel in position 10
Current CRT row: ##..##..##.

During cycle 12: CRT draws pixel in position 11
Current CRT row: ##..##..##..
End of cycle 12: finish executing addx -1 (Register X is now 12)
Sprite position: ...........###..........................

Start cycle  13: begin executing addx -8
During cycle 13: CRT draws pixel in position 12
Current CRT row: ##..##..##..#

During cycle 14: CRT draws pixel in position 13
Current CRT row: ##..##..##..##
End of cycle 14: finish executing addx -8 (Register X is now 4)
Sprite position: ...###..................................

Start cycle  15: begin executing addx 13
During cycle 15: CRT draws pixel in position 14
Current CRT row: ##..##..##..##.

During cycle 16: CRT draws pixel in position 15
Current CRT row: ##..##..##..##..
End of cycle 16: finish executing addx 13 (Register X is now 17)
Sprite position: ................###.....................

Start cycle  17: begin executing addx 4
During cycle 17: CRT draws pixel in position 16
Current CRT row: ##..##..##..##..#

During cycle 18: CRT draws pixel in position 17
Current CRT row: ##..##..##..##..##
End of cycle 18: finish executing addx 4 (Register X is now 21)
Sprite position: ....................###.................

Start cycle  19: begin executing noop
During cycle 19: CRT draws pixel in position 18
Current CRT row: ##..##..##..##..##.
End of cycle 19: finish executing noop

Start cycle  20: begin executing addx -1
During cycle 20: CRT draws pixel in position 19
Current CRT row: ##..##..##..##..##..

During cycle 21: CRT draws pixel in position 20
Current CRT row: ##..##..##..##..##..#
End of cycle 21: finish executing addx -1 (Register X is now 20)
Sprite position: ...................###..................
</code></pre>
<p>プログラムを最後まで実行させると、CRTは次の映像を生成します。</p>
<pre><code>##..##..##..##..##..##..##..##..##..##..
###...###...###...###...###...###...###.
####....####....####....####....####....
#####.....#####.....#####.....#####.....
######......######......######......####
#######.......#######.......#######.....
</code></pre>
<p>あなたのプログラムによって与えられた画像をレンダリングします。
<strong>CRTに表示される8つの大文字は何ですか？</strong></p>
<!--
<details><summary>解説</summary><div>

時刻 \\(t\\) のスキャン位置が光るかどうかは、時刻 \\(t-1\\) のレジスタの値で定まる。
スキャン位置 \\((t - 1) \bmod 40\\) と
レジスタの値の差が \\(\pm 1\\) に収まっているとき、ピクセルは光る。

```haskell
import Data.List.Split

body2 fn = do
  ls <- lines <$> readFile fn
  let xs = 1 : loop 1 ls
  let ps = zipWith sprite [0..] xs
  mapM_ putStrLn $ chunksOf 40 ps

sprite t x
  | pred x <= tm && tm <= succ x = '#'
  | otherwise = ' '
  where
    tm = mod t 40

main2 = body2 "input.txt"
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="11日目-サルインザミドル中間猿攻撃"><a class="header" href="#11日目-サルインザミドル中間猿攻撃">11日目: サル・イン・ザ・ミドル（中間猿攻撃）</a></h1>
<p>ようやく川を遡り始めると、リュックが思ったよりもずっと軽いことに気づきます。
ちょうどその時、リュックの荷物のひとつが頭上を飛んでいきます。
サルはあなたの無くし物で<a href="https://en.wikipedia.org/wiki/Keep_away">Keep Away</a>をして遊んでいます！</p>
<p>荷物を取り戻すには、サルがどこに荷物を投げるかを予測できる必要があります。
注意深い観察の結果、サルは<strong>それぞれの荷物に対するあなたの心配度</strong>に基づいて行動していることに気付きました。</p>
<p>それぞれのサルが現在持っている荷物、それらの荷物に対するあなたの心配度、
心配度に基づいてサルがどのように決定を下すかについて、
あなたは何やらメモを取りました（パズル入力）。
例えば：</p>
<pre><code>Monkey 0:
  Starting items: 79, 98
  Operation: new = old * 19
  Test: divisible by 23
    If true: throw to monkey 2
    If false: throw to monkey 3

Monkey 1:
  Starting items: 54, 65, 75, 74
  Operation: new = old + 6
  Test: divisible by 19
    If true: throw to monkey 2
    If false: throw to monkey 0

Monkey 2:
  Starting items: 79, 60, 97
  Operation: new = old * old
  Test: divisible by 13
    If true: throw to monkey 1
    If false: throw to monkey 3

Monkey 3:
  Starting items: 74
  Operation: new = old + 3
  Test: divisible by 17
    If true: throw to monkey 0
    If false: throw to monkey 1
</code></pre>
<p>それぞれのサルはいくつかの属性を持ちます。</p>
<ul>
<li><code>Starting items</code> サルが現在持っている荷物のそれぞれの<strong>心配度</strong>の、サルがそれを検分する順番のリストです。</li>
<li><code>Operation</code> サルが荷物を検分することで、あなたの心配度がどのように変化するかを示しています。
（例えば <code>new = old * 5</code> とあるとき、
サルが荷物を検分した後の心配度が、検査前の心配度の5倍になることを意味します。）</li>
<li><code>Test</code> は、サルがあなたの心配度を使用して、次にどこに荷物を投げるかを決定する方法を示しています。
<ul>
<li><code>If true</code> テストが真になるときに荷物がどうなるかを示します。</li>
<li><code>If false</code> テストが偽の場合に荷物がどうなるかを示します。</li>
</ul>
</li>
</ul>
<p>サルが荷物を検分した後、あなたの心配度に対してTestをする前に、
サルの検分が荷物を駄目にせずに済んだというあなたの安堵が、
あなたの心配度を<strong>3で割り</strong>、最も近い整数に切り捨てます。
（訳注：「近い」でなく床関数での切り捨て）</p>
<p>サルは順に荷物を検分して投げます。
あるサルの番では、そのサルが持っている全ての荷物を一度にひとつずつ、リストにある順に、
検分しては投げます。
サル<code>0</code>が最初に、次にサル<code>1</code>というように、全てのサルに順番が回るまで続けます。
全てのサルに一度順番が回る過程を<strong>ラウンド</strong>（一巡）と呼びます。</p>
<p>サルが別のサルに荷物を投げると、その荷物は受け取ったサルのリストの<strong>末尾</strong>に入ります。
あるサルが開始時にリストに荷物がない状態であったとしても、
順番が回ってきたときには検分して投げる荷物を大量に持っていることになる可能性があります。
サルが自分の番の開始時に荷物を持っていない場合、そのサルの番はそれで終わりです。</p>
<p>上記の例では、最初のラウンドは次のように進行します。</p>
<pre><code>Monkey 0:
  Monkey inspects an item with a worry level of 79.
    Worry level is multiplied by 19 to 1501.
    Monkey gets bored with item. Worry level is divided by 3 to 500.
    Current worry level is not divisible by 23.
    Item with worry level 500 is thrown to monkey 3.
訳：
サル 0:
  サルが心配度79の荷物を検分します。
  心配度に19を掛けて1501になります。
  サルが荷物に飽きました。心配度は3で割って500になります。
  現在の心配度は23で割り切れません。
  心配度500の荷物がサル3に投げられます。
</code></pre>
<p>続き</p>
<pre><code>  Monkey inspects an item with a worry level of 98.
    Worry level is multiplied by 19 to 1862.
    Monkey gets bored with item. Worry level is divided by 3 to 620.
    Current worry level is not divisible by 23.
    Item with worry level 620 is thrown to monkey 3.
Monkey 1:
  Monkey inspects an item with a worry level of 54.
    Worry level increases by 6 to 60.
    Monkey gets bored with item. Worry level is divided by 3 to 20.
    Current worry level is not divisible by 19.
    Item with worry level 20 is thrown to monkey 0.
  Monkey inspects an item with a worry level of 65.
    Worry level increases by 6 to 71.
    Monkey gets bored with item. Worry level is divided by 3 to 23.
    Current worry level is not divisible by 19.
    Item with worry level 23 is thrown to monkey 0.
  Monkey inspects an item with a worry level of 75.
    Worry level increases by 6 to 81.
    Monkey gets bored with item. Worry level is divided by 3 to 27.
    Current worry level is not divisible by 19.
    Item with worry level 27 is thrown to monkey 0.
  Monkey inspects an item with a worry level of 74.
    Worry level increases by 6 to 80.
    Monkey gets bored with item. Worry level is divided by 3 to 26.
    Current worry level is not divisible by 19.
    Item with worry level 26 is thrown to monkey 0.
Monkey 2:
  Monkey inspects an item with a worry level of 79.
    Worry level is multiplied by itself to 6241.
    Monkey gets bored with item. Worry level is divided by 3 to 2080.
    Current worry level is divisible by 13.
    Item with worry level 2080 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 60.
    Worry level is multiplied by itself to 3600.
    Monkey gets bored with item. Worry level is divided by 3 to 1200.
    Current worry level is not divisible by 13.
    Item with worry level 1200 is thrown to monkey 3.
  Monkey inspects an item with a worry level of 97.
    Worry level is multiplied by itself to 9409.
    Monkey gets bored with item. Worry level is divided by 3 to 3136.
    Current worry level is not divisible by 13.
    Item with worry level 3136 is thrown to monkey 3.
Monkey 3:
  Monkey inspects an item with a worry level of 74.
    Worry level increases by 3 to 77.
    Monkey gets bored with item. Worry level is divided by 3 to 25.
    Current worry level is not divisible by 17.
    Item with worry level 25 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 500.
    Worry level increases by 3 to 503.
    Monkey gets bored with item. Worry level is divided by 3 to 167.
    Current worry level is not divisible by 17.
    Item with worry level 167 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 620.
    Worry level increases by 3 to 623.
    Monkey gets bored with item. Worry level is divided by 3 to 207.
    Current worry level is not divisible by 17.
    Item with worry level 207 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 1200.
    Worry level increases by 3 to 1203.
    Monkey gets bored with item. Worry level is divided by 3 to 401.
    Current worry level is not divisible by 17.
    Item with worry level 401 is thrown to monkey 1.
  Monkey inspects an item with a worry level of 3136.
    Worry level increases by 3 to 3139.
    Monkey gets bored with item. Worry level is divided by 3 to 1046.
    Current worry level is not divisible by 17.
    Item with worry level 1046 is thrown to monkey 1.
</code></pre>
<p>第1ラウンドの後、サルはそれぞれ次の心配度の荷物を持っています：</p>
<pre><code>Monkey 0: 20, 23, 27, 26
Monkey 1: 2080, 25, 167, 207, 401, 1046
Monkey 2: 
Monkey 3: 
</code></pre>
<p>サル<code>2</code>と<code>3</code>は、このラウンドの終了時に荷物を持っていません。
彼らはどちらもラウンド中に全ての荷物を検分し、ラウンドが終了する前にそれらを全て投げました。</p>
<p>この過程は、さらに数ラウンド続きます。</p>
<pre><code>After round 2, the monkeys are holding items with these worry levels:
第2ラウンドの後にサルたちが持つ荷物の心配度：
Monkey 0: 695, 10, 71, 135, 350
Monkey 1: 43, 49, 58, 55, 362
Monkey 2: 
Monkey 3: 

After round 3, the monkeys are holding items with these worry levels:
Monkey 0: 16, 18, 21, 20, 122
Monkey 1: 1468, 22, 150, 286, 739
Monkey 2: 
Monkey 3: 

After round 4, the monkeys are holding items with these worry levels:
Monkey 0: 491, 9, 52, 97, 248, 34
Monkey 1: 39, 45, 43, 258
Monkey 2: 
Monkey 3: 

After round 5, the monkeys are holding items with these worry levels:
Monkey 0: 15, 17, 16, 88, 1037
Monkey 1: 20, 110, 205, 524, 72
Monkey 2: 
Monkey 3: 

After round 6, the monkeys are holding items with these worry levels:
Monkey 0: 8, 70, 176, 26, 34
Monkey 1: 481, 32, 36, 186, 2190
Monkey 2: 
Monkey 3: 

After round 7, the monkeys are holding items with these worry levels:
Monkey 0: 162, 12, 14, 64, 732, 17
Monkey 1: 148, 372, 55, 72
Monkey 2: 
Monkey 3: 

After round 8, the monkeys are holding items with these worry levels:
Monkey 0: 51, 126, 20, 26, 136
Monkey 1: 343, 26, 30, 1546, 36
Monkey 2: 
Monkey 3: 

After round 9, the monkeys are holding items with these worry levels:
Monkey 0: 116, 10, 12, 517, 14
Monkey 1: 108, 267, 43, 55, 288
Monkey 2: 
Monkey 3: 

After round 10, the monkeys are holding items with these worry levels:
Monkey 0: 91, 16, 20, 98
Monkey 1: 481, 245, 22, 26, 1092, 30
Monkey 2: 
Monkey 3: 

...

After round 15, the monkeys are holding items with these worry levels:
Monkey 0: 83, 44, 8, 184, 9, 20, 26, 102
Monkey 1: 110, 36
Monkey 2: 
Monkey 3: 

...

After round 20, the monkeys are holding items with these worry levels:
Monkey 0: 10, 12, 14, 26, 34
Monkey 1: 245, 93, 53, 199, 115
Monkey 2: 
Monkey 3: 
</code></pre>
<p>一度に全てのサルを追跡することは不可能です。
荷物を取り戻す望みを繋ぐには、<strong>最も活発な2匹</strong>のサルに集中する必要があります。
20ラウンドにわたってそれぞれのサルが<strong>荷物を検分した合計回数</strong>を数えます。</p>
<ul>
<li>サル0は荷物を101回検分しました</li>
<li>サル1は荷物を 95回検分しました</li>
<li>サル2は荷物を  7回検分しました</li>
<li>サル3は荷物を105回検分しました</li>
</ul>
<p>この例では、最も活発な2匹のサルが荷物を101回と105回検査しました。
この状況でのいたずら（<strong>monkey business</strong>）の度合いは、
これらを乗算することで<strong>10605</strong>と求めることができます。</p>
<p>サルが20ラウンドにわたって検分した荷物の数を数えて、どのサルを追いかけるべきかを特定します。
<strong>20ラウンドの物投げサルの悪ふざけの後、いたずらの度合いはいくつですか？</strong>
（原文 stuff-slinging simian shenanigans 物を投げるサルのいたずら）</p>
<!--
<details><summary>解説</summary><div>

実際のパズル入力でもサルはたかだか8匹なので、データはファイルから読み込みせずに手作業でプログラムに直す。
サルを表すデータ型を定義する。

```haskell
type WorryLevel = Int
data Monkey = Monkey
  { si  :: [WorryLevel]              -- Starting items
  , op  :: WorryLevel -> WorryLevel  -- Operation
  , tst :: WorryLevel                -- testの除数
  , t   :: Int                       -- 割り切れるときに投げる先
  , f   :: Int }                     -- 割り切れないときに投げる先

testData =
  [ Monkey [79, 98]         (19 *) 23 2 3
  , Monkey [54, 65, 75, 74] (6 +)  19 2 0
  , Monkey [79, 60, 97]     (^ 2)  13 1 3
  , Monkey [74]             (3 +)  17 0 1
  ]
```

激しく状態変化が起きるので、命令型言語が似合っている内容なのは否めない。
その近似として、IOモナドの中で、`IOArray` を用いて状況を表現する。
サルの持ち物リストは `Data.Sequence` で扱う。

```haskell
import Control.Monad
import Data.Array.IO
import qualified Data.Sequence as Q
import Data.Foldable
import Data.List

phase1 :: [Monkey] -> IO ()
phase1 ms =
  do
-- サルの持ち物リストの配列
    qv <- newListArray (0, nM) $ map (Q.fromList . si) ms :: IO (IOArray Int (Q.Seq WorryLevel))
-- 荷物を検分した回数カウンタ配列
    cv <- newArray (0, nM) 0 :: IO (IOArray Int Int)
-- 20ラウンド繰り返す
    forM_ [1..20] (\round -> do
-- それぞれのサルに順番を回す
      forM_ (zip [0..] ms) (\(i, m) -> do
-- 持ち物リストを読み出す
        q <- readArray qv i
-- これは全て投げるのでリストを空にする
        writeArray qv i Q.empty
-- 検分した回数を増やす
        readArray cv i >>= writeArray cv i . (Q.length q +)
-- それぞれの荷物について
        forM_ (toList q) (\item -> do
-- 心配度はサル固有の計算の後3で割る
            let item1 = div (op m item) 3
-- 割り切れるかどうかで送り先jを決める
            let j = if mod item1 (tst m) == 0 then t m else f m
-- そのサルの持ち物リストの末尾に追加する
            readArray qv j >>= writeArray qv j . (Q.|> item1)
            )
        )
-- (確認用) ラウンド終了後の持ち物リスト
      print ("round ", round)
      md <- getElems qv
      mapM_ print md
      )
-- いたずら度を算出
    cnts <- getElems cv
    print $ product $ take 2 $ sortBy (flip compare) cnts
  where
    nM = pred $ length ms
```

IOモナドですることで、デバッグ出力も容易にできた。

</div></details>
-->
<h1 id="パート2-39"><a class="header" href="#パート2-39">パート2</a></h1>
<p>あなたは荷物を取り返せないのではないかと心配になってきました。
実際、猿の検分が荷物に損傷を与えなかったというあなたの安堵は、
<strong>あなたの心配度が3で割られることをもはや引き起こさない</strong>ほど心配しています。</p>
<p>残念ながら、その安堵は、あなたの心配度が<strong>途方もないレベル</strong>に達するのを防いでいた全てでした。
<strong>心配度を管理できるようにする別の方法</strong>を見つける必要があるでしょう。</p>
<p>この相場で、あなたはサルたちに<strong>非常に長い間</strong>、どうにか<strong>10000ラウンド</strong>我慢することになります。</p>
<p>これらの新しい規則で、10000ラウンド後のいたずら度を把握できます。
上記と同じ例を使用します。</p>
<ul>
<li>第1ラウンドの後
<ul>
<li>サル0は荷物を2回検分しました</li>
<li>サル1は荷物を4回検分しました</li>
<li>サル2は荷物を3回検分しました</li>
<li>サル3は荷物を6回検分しました</li>
</ul>
</li>
<li>20ラウンド後
<ul>
<li>サル0は荷物を 99回検分しました</li>
<li>サル1は荷物を 97回検分しました</li>
<li>サル2は荷物を  8回検分しました</li>
<li>サル3は荷物を103回検分しました</li>
</ul>
</li>
<li>1000ラウンド後
<ul>
<li>サル0は荷物を5204回検分しました</li>
<li>サル1は荷物を4792回検分しました</li>
<li>サル2は荷物を 199回検分しました</li>
<li>サル3は荷物を5192回検分しました</li>
</ul>
</li>
</ul>
<pre><code>== After round 2000 ==
Monkey 0 inspected items 10419 times.
Monkey 1 inspected items 9577 times.
Monkey 2 inspected items 392 times.
Monkey 3 inspected items 10391 times.

== After round 3000 ==
Monkey 0 inspected items 15638 times.
Monkey 1 inspected items 14358 times.
Monkey 2 inspected items 587 times.
Monkey 3 inspected items 15593 times.

== After round 4000 ==
Monkey 0 inspected items 20858 times.
Monkey 1 inspected items 19138 times.
Monkey 2 inspected items 780 times.
Monkey 3 inspected items 20797 times.

== After round 5000 ==
Monkey 0 inspected items 26075 times.
Monkey 1 inspected items 23921 times.
Monkey 2 inspected items 974 times.
Monkey 3 inspected items 26000 times.

== After round 6000 ==
Monkey 0 inspected items 31294 times.
Monkey 1 inspected items 28702 times.
Monkey 2 inspected items 1165 times.
Monkey 3 inspected items 31204 times.

== After round 7000 ==
Monkey 0 inspected items 36508 times.
Monkey 1 inspected items 33488 times.
Monkey 2 inspected items 1360 times.
Monkey 3 inspected items 36400 times.

== After round 8000 ==
Monkey 0 inspected items 41728 times.
Monkey 1 inspected items 38268 times.
Monkey 2 inspected items 1553 times.
Monkey 3 inspected items 41606 times.

== After round 9000 ==
Monkey 0 inspected items 46945 times.
Monkey 1 inspected items 43051 times.
Monkey 2 inspected items 1746 times.
Monkey 3 inspected items 46807 times.

== After round 10000 ==
Monkey 0 inspected items 52166 times.
Monkey 1 inspected items 47830 times.
Monkey 2 inspected items 1938 times.
Monkey 3 inspected items 52013 times.
</code></pre>
<p>10000ラウンド後、最も活発な 2 匹のサルは52166回と52013回、荷物を検分しました。
これらを掛け合わせると、この状況でのいたずら度は<strong>2713310158</strong>です。</p>
<p>荷物が検分された後に、心配度が3で割られることはなくなりました。
心配度を管理できるように保つ別の方法を見つける必要があります。
パズル入力の初期状態からやり直すと、
<strong>10000ラウンド後のいたずら度はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

ラウンド回数を指定できるように `phase1` を改造して実行すると結果が例と食い違う。
`Int`がオーバーフローしている。
`type WorryLevel = Integer` とすると、1000回の結果がいつまでも求められない。
心配度をそのまま扱うと、途方もない桁数になってしまう。

全てのサルが、投げる先の判定を「特定の数で割り切れるかどうか」で行っていることに注目する。
つまり、それらの数で割り切れる値かどうかだけが正しく判断できればよい。

そこで心配度を、
サル全員の割る数の最小公倍数（もしくは全ての掛けた数）を法にしたモジュロ整数
で扱うように修正する。`WorryLevel`は`Int`のままで構わない。

コメントを付けたところだけが `phase1` からの変更部分。

```haskell
phase2 :: [Monkey] -> Int -> IO ()
phase2 ms times =
  do
    qv <- newListArray (0, nM) $ map (Q.fromList . si) ms :: IO (IOArray Int (Q.Seq WorryLevel))
    cv <- newArray (0, nM) 0 :: IO (IOArray Int Int)
-- ラウンド回数は引数で指定
    forM_ [1..times] (\round -> do
      forM_ (zip [0..] ms) (\(i, m) -> do
        q <- readArray qv i
        readArray cv i >>= writeArray cv i . (Q.length q +)
        writeArray qv i Q.empty
        forM_ (toList q) (\item -> do
-- 心配度は3で割らないが、モジュロをとる
            let item1 = mod (op m item) base
            let j = if mod item1 (tst m) == 0 then t m else f m
            readArray qv j >>= writeArray qv j . (Q.|> item1)
            )
        )
      )
    cnts <- getElems cv
    print cnts
    print $ product $ take 2 $ sortBy (flip compare) cnts
  where
    nM = pred $ length ms
-- 法にするための最小公倍数を求める
    base = foldl1 lcm $ map tst ms
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><!-- 五時之丞 いいなそれ。 如之丈 なんだが。-->
<h1 id="12-日目-山登りアルゴリズム"><a class="header" href="#12-日目-山登りアルゴリズム">12 日目: 山登りアルゴリズム</a></h1>
<p>あなたは携帯機器を使用して小人と連絡を取ろうとしましたが、
あなたが辿っている川は位置が低すぎて適切な信号を受信できませんでした。</p>
<p>機器に周辺領域の高さ地図を要求します（パズル入力）。
高さ地図は、グリッドに分割された上空から見た周辺地域を示しています。
グリッドの各正方形の標高は、1 つの小文字で示されます。
ここで <code>a</code> は最低の標高、<code>b</code> は次に低い標高、というように最高の標高 <code>z</code> まで続きます。</p>
<p>高さ地図には他に、現在の位置 (<code>S</code>) と最良の信号を受信できる位置 (<code>E</code>) の印も含まれています。
現在の位置 (<code>S</code>) は標高 <code>a</code> を持ち、
最高の信号を受信できるはずの場所 (<code>E</code>) は標高 <code>z</code> を持ちます。</p>
<p>あなたは <code>E</code> に到達したいのですが、エネルギーを節約するために、
できるだけ<strong>少ないステップ数で</strong>到達する必要があります。
各ステップでは、ちょうど1マス上下左右に移動できます。
登山用具を取り出さなくても済むように、目的地のマスの標高は、
現在のマスの標高より<strong>たかだか1だけ高くなる</strong>ならば許されます。
つまり、現在の標高が <code>m</code> の場合、標高 <code>n</code> に進むことはできますが、標高 <code>o</code> に進むことはできません。
（これは、目的のマスの標高が現在のマスの標高よりもずっと低くなる方は構わないことも意味しています。）</p>
<p>例えば：</p>
<pre><code>Sabqponm
abcryxxl
accszExk
acctuvwj
abdefghi
</code></pre>
<p>ここでは、左上隅から始めます。あなたの目的地は真ん中近くです。
下または右に移動することから始めることもできますが、
最終的には一番下の <code>e</code> に向かう必要があります。
そこから、螺旋状に進むことで目的地へ行くことができます。</p>
<pre><code>v..v&lt;&lt;&lt;&lt;
&gt;v.vv&lt;&lt;^
.&gt;vv&gt;E^^
..v&gt;&gt;&gt;^^
..&gt;&gt;&gt;&gt;&gt;^
</code></pre>
<p>上の図における記号は、上 (<code>^</code>)、下 (<code>v</code>)、左 (<code>&lt;</code>)、右 (<code>&gt;</code>)に移動してそのマスから出る経路であることを示します。
最良の信号を受信できるはずの場所はここでも <code>E</code> で示され、<code>.</code> は訪問されないマスの印です。</p>
<p>この経路は、31ステップで目的地に到達します。これは可能な限り少ない数です。</p>
<p><strong>現在の位置から最適な信号を受信できる場所に移動するのに必要な最小のステップ数はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

幅優先探索で、出発地点から到達できたマスに到達済みの印を書き込んでいく。
目的地のマスが書き込まれたところで繰り返しを終了する。
これをするためには、到達済みフラグの、書き換え可能な二次元配列が必要。
さらに、標高地図もランダムアクセスしたいので二次元配列に保存する。

地図は行ごとの文字列のリストとして読み込む。

```haskell
phase1 fn = do
  ls <- lines <$> readFile fn
  ...
```

ここから、`S`の位置と`E`の位置を見つけておく。

```haskell
phase1 fn = do
  ...
  let [spos] = locate 'S' ls
  let [epos] = locate 'E' ls
  ...

locate v xss = [(i,j) | (i,xs) <- zip [1..] xss, (j,x) <- zip [1..] xs, v == x]
```

標高地図の二次元配列を作る際は、`S`と`E`はその標高に置き換える。

```haskell
import Data.Array.Unboxed

phase1 fn = do
  ...
  let w = length (head ls)
  let h = length ls
  let a2z = listArray ((1,1),(h,w)) $ map se2az $ concat ls :: UArray (Int,Int) Char
  ...

se2az 'S' = 'a'
se2az 'E' = 'z'
se2az  c  =  c
```

フラグの二次元配列の初期値は到達済みを `True` とする。

```haskell
import Data.Array.IO

phase1 fn = do
  ...
  da <- newArray ((1,1),(h,w)) False :: IO (IOUArray (Int,Int) Bool)
  ...
```

これらを利用して、幅優先探索を行う。
未処理の地点のリストをひとつずつ消費し、そこが到達済みなら捨てる。
未到達なら、到達済みとチェックし、その周辺4地点の標高が+1までに収まっていれば、
次に調査するべき地点のリストに加える。
処理する地点のリストが尽きたら、
距離を1増やして、次に調査するべき地点のリストを処理する地点のリストに持ち替えて繰り返す。
目的地の距離が判明した時点で終了する。

```haskell
import Data.Ix

phase1 fn = do
  ...
  loopWrap a2z da epos spos >>= print

loopWrap :: UArray (Int, Int) Char -> IOUArray (Int,Int) Bool -> (Int,Int) -> (Int,Int) -> IO Int
loopWrap a2z da epos spos = loop 0 [spos] []
  where
    bnds = bounds a2z
    loop :: Int -> [(Int,Int)] -> [(Int,Int)] -> IO Int
    loop _ [] [] = error "cannot reach to E"
    loop cnt [] qs = loop (succ cnt) qs []
    loop cnt (p:ps) qs =
      do
        b <- readArray da p
        if b then loop cnt ps qs else do
          writeArray da p True
          if p == epos then return cnt else do
            let h1 = succ $ a2z ! p
            qs1 <- foldM (\qs d -> do
              let q = add p d
              if not (inRange bnds q) || h1 < a2z ! q then return qs else do
                d <- readArray da q
                return $ if d then qs else q:qs
              ) qs deltas
            loop cnt ps qs1
```

</div></details>
-->
<h1 id="パート2-40"><a class="header" href="#パート2-40">パート2</a></h1>
<p>丘を上っていくとき、小人がここをハイキングコースにしようとしているのではないかとあなたは訝しみました。
ただし、この出発地点はあまり風光明媚ではありません。
おそらく、より良い出発点を見つけることができるでしょう。</p>
<p>ハイキング中の運動を最大限にするために、コースはできるだけ低い標高、つまり <code>a</code> から始める必要があります。
目的地はやはり<code>E</code> と印されたマスです。
ただし、コースはやはり最も近道である必要があります。
つまり、目的地に到達するためのステップ数は最小で済ませてください。
したがって、標高 <code>a</code> である任意のマスから、<code>E</code> と印されたマスまでの最短経路を見つける必要があります。</p>
<p>上記の例をもう一度考えてみましょう。</p>
<pre><code>Sabqponm
abcryxxl
accszExk
acctuvwj
abdefghi
</code></pre>
<p>ここで、開始位置には6つの選択肢があります。
（<code>a</code> と印された5つと、高度 <code>a</code> にあると見なされる <code>S</code> と印されたマス）
左下のマスから始めると、最も早くゴールに到達できます。</p>
<pre><code>...v&lt;&lt;&lt;&lt;
...vv&lt;&lt;^
...v&gt;E^^
.&gt;v&gt;&gt;&gt;^^
&gt;^&gt;&gt;&gt;&gt;&gt;^
</code></pre>
<p>この経路は、可能な限り少ない手順である<strong>29</strong>ステップで目的地に到達します。</p>
<p><strong>標高 <code>a</code> の任意のマスから出発して、最良の信号を受信できる場所に移動するのに必要な最小ステップ数はいくつですか？</strong></p>
<!--
<details><summary>解説</summary><div>

幅優先探索の動作を少し修正する。

- `E`の地点から出発する。
- 移動できる地点の標高の判断が逆になる。
- 新たに到達した地点の標高が初めて `a` であったとき、その距離が答えである。

```haskell
phase2 fn = do
  ...
  loop2Wrap a2z da epos >>= print

loop2Wrap :: UArray (Int, Int) Char -> IOUArray (Int,Int) Bool -> (Int,Int) -> IO Int
loop2Wrap a2z da epos = loop 0 [epos] []
  where
    bnds = bounds a2z
    loop :: Int -> [(Int,Int)] -> [(Int,Int)] -> IO Int
    loop _ [] [] = error "cannot reach to height 'a'"
    loop cnt [] qs = loop (succ cnt) qs []
    loop cnt (p:ps) qs =
      do
        b <- readArray da p
        if b then loop cnt ps qs else do
          writeArray da p True
          if a2z ! p == 'a' then return cnt else do
            let h1 = pred $ a2z ! p
            qs1 <- foldM (\qs d -> do
              let q = add p d
              if not (inRange bnds q) || h1 > a2z ! q then return qs else do
                d <- readArray da q
                return $ if d then qs else q:qs
              ) qs deltas
            loop cnt ps qs1
```

</div></details>
-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="13日目-救難信号"><a class="header" href="#13日目-救難信号">13日目: 救難信号</a></h1>
<p>編集中</p>
<!--
丘を登り、再びエルフとの接触を試みます。ただし、代わりに、予期していなかった信号を受信します:救難信号です。

ハンドヘルド デバイスはまだ正常に動作していないはずです。遭難信号からのパケットが順不同でデコードされました。メッセージをデコードするには、受信したパケット (パズルの入力) のリストを並べ替える必要があります。

リストはパケットのペアで構成されています。ペアは空白行で区切られます。正しい順序になっているパケットのペアの数を特定する必要があります。

例えば：

[1,1,3,1,1]
[1,1,5,1,1]

[[1],[2,3,4]]
[[1],4]

[9]
[[8,7,6]]

[[4,4],4,4]
[[4,4],4,4,4]

[7,7,7,7]
[7,7,7]

[]
[3]

[[[]]]
[[]]

[1,[2,[3,[4,[5,6,7]]]],8,9]
[1,[2,[3,[4,[5,6,0]]]],8,9]
パケット データは、リストと整数で構成されます。各リストは で始まり[、 で終わり]、0 個以上のカンマ区切りの値 (整数またはその他のリスト) を含みます。各パケットは常にリストであり、それぞれの行に表示されます。

2 つの値を比較する場合、最初の値はleftと呼ばれ、2 番目の値はrightと呼ばれます。それで：

両方の値が integer の場合、小さい方の整数が最初に来る必要があります。左の整数が右の整数より小さい場合、入力は正しい順序になります。左の整数が右の整数より大きい場合、入力は正しい順序ではありません。それ以外の場合、入力は同じ整数です。入力の次の部分のチェックを続けます。
両方の値がリストである場合は、各リストの最初の値を比較し、次に 2 番目の値を比較します。左側のリストが最初に項目を使い果たした場合、入力は正しい順序になっています。正しいリストが最初に項目を使い果たした場合、入力は正しい順序ではありません。リストが同じ長さで、比較によって順序が決定されない場合は、入力の次の部分のチェックを続けます。
ちょうど 1 つの値が整数である場合は、その整数を唯一の値として含むリストに整数を変換してから、比較を再試行します。たとえば、[0,0,0]と を比較する場合2、正しい値を[2]( を含むリスト2) に変換します。[0,0,0]代わりにと を比較することで結果が得られます[2]。
これらの規則を使用して、例のどのペアが正しい順序であるかを判断できます。

== Pair 1 ==
- Compare [1,1,3,1,1] vs [1,1,5,1,1]
  - Compare 1 vs 1
  - Compare 1 vs 1
  - Compare 3 vs 5
    - Left side is smaller, so inputs are in the right order

== Pair 2 ==
- Compare [[1],[2,3,4]] vs [[1],4]
  - Compare [1] vs [1]
    - Compare 1 vs 1
  - Compare [2,3,4] vs 4
    - Mixed types; convert right to [4] and retry comparison
    - Compare [2,3,4] vs [4]
      - Compare 2 vs 4
        - Left side is smaller, so inputs are in the right order

== Pair 3 ==
- Compare [9] vs [[8,7,6]]
  - Compare 9 vs [8,7,6]
    - Mixed types; convert left to [9] and retry comparison
    - Compare [9] vs [8,7,6]
      - Compare 9 vs 8
        - Right side is smaller, so inputs are not in the right order

== Pair 4 ==
- Compare [[4,4],4,4] vs [[4,4],4,4,4]
  - Compare [4,4] vs [4,4]
    - Compare 4 vs 4
    - Compare 4 vs 4
  - Compare 4 vs 4
  - Compare 4 vs 4
  - Left side ran out of items, so inputs are in the right order

== Pair 5 ==
- Compare [7,7,7,7] vs [7,7,7]
  - Compare 7 vs 7
  - Compare 7 vs 7
  - Compare 7 vs 7
  - Right side ran out of items, so inputs are not in the right order

== Pair 6 ==
- Compare [] vs [3]
  - Left side ran out of items, so inputs are in the right order

== Pair 7 ==
- Compare [[[]]] vs [[]]
  - Compare [[]] vs []
    - Right side ran out of items, so inputs are not in the right order

== Pair 8 ==
- Compare [1,[2,[3,[4,[5,6,7]]]],8,9] vs [1,[2,[3,[4,[5,6,0]]]],8,9]
  - Compare 1 vs 1
  - Compare [2,[3,[4,[5,6,7]]]] vs [2,[3,[4,[5,6,0]]]]
    - Compare 2 vs 2
    - Compare [3,[4,[5,6,7]]] vs [3,[4,[5,6,0]]]
      - Compare 3 vs 3
      - Compare [4,[5,6,7]] vs [4,[5,6,0]]
        - Compare 4 vs 4
        - Compare [5,6,7] vs [5,6,0]
          - Compare 5 vs 5
          - Compare 6 vs 6
          - Compare 7 vs 0
            - Right side is smaller, so inputs are not in the right order
すでに正しい順序になっているペアのインデックスは何ですか? (最初のペアのインデックスは 1、2 番目のペアのインデックスは 2 というように続きます。) 上記の例では、正しい順序のペアは 1、2、4、および 6 です。これらの指数の合計は です13。

どのペアのパケットがすでに正しい順序になっているかを判断します。これらのペアのインデックスの合計は?


- - パート2 - -
あとは、すべてのパケットを正しい順序に並べるだけです。受信したパケットのリストの空白行は無視してください。

遭難信号プロトコルには、2 つの追加の分割パケットを含めることも必要です。

[[2]]
[[6]]
前と同じルールを使用して、すべてのパケット (受信したパケットのリストにあるパケットと 2 つの分割パケット) を正しい順序に編成します。

上記の例では、パケットを正しい順序に並べた結果は次のようになります。

[]
[[]]
[[[]]]
[1,1,3,1,1]
[1,1,5,1,1]
[[1],[2,3,4]]
[1,[2,[3,[4,[5,6,0]]]],8,9]
[1,[2,[3,[4,[5,6,7]]]],8,9]
[[1],4]
[[2]]
[3]
[[4,4],4,4]
[[4,4],4,4,4]
[[6]]
[7,7,7]
[7,7,7,7]
[[8,7,6]]
[9]
その後、分割パケットを見つけます。この救難信号のデコーダー キーを見つけるには、2 つの分割パケットのインデックスを決定し、それらを乗算する必要があります。(最初のパケットはインデックス 1、2 番目のパケットはインデックス 2 など)。この例では、分割パケットは10 番目と14 番目であるため、デコーダ キーは です140。

すべてのパケットを正しい順序に編成します。遭難信号のデコーダキーは何ですか?
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
