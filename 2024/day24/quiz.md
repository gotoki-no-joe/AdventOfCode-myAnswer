# 24日目：こんがらがった配線

あなたと歴史学者たちは、ジャングルのどこかにある[大きな林](../../2022/day23/quiz.md)の端に到着します。
最後の事件の後、妖精たちは果物を監視する小さな装置を設置しました。
歴史学者たちが林を探している間、彼らの一人が監視装置を見てくれないかと尋ねます。
どうやら最近故障したようです。

その装置はブール論理ゲートを通じて数値を生成しようとしているようです。
各ゲートには2つの入力と1つの出力があります。
ゲートは全て、**真** (`1`) または**偽** (`0`) の値を扱います。

- ANDゲートは、**両方**の入力が`1`の場合に`1`を出力します。いずれかの入力が`0`の場合、これらのゲートは`0`を出力します。
- ORゲートは、**1つまたは両方**の入力が`1`の場合に`1`を出力します。両方の入力が`0`の場合、これらのゲートは`0`を出力します。
- XORゲートは、入力が**異なる**場合に`1`を出力します。入力が同じ場合、これらのゲートは`0`を出力します。

ゲートは、出力を生成する前に両方の入力が受信されるのを待ちます。
配線は `0`, `1` を伝送するか、または全く値を持たないことができます。
ループはありません。
ゲートがひとたび出力を決定すると、その出力はシステム全体がリセットされるまで変化しません。
各配線は最大で1つのゲート出力に接続されますが、多くのゲート入力に接続することができます。

動作中のシステムをいじって感電するリスクを冒すのではなく、
ゲートの接続と配線の初期値を全て書き留めて（あなたのパズル入力）、
比較的安全に検討できるようにします。例えば：

```
x00: 1
x01: 1
x02: 1
y00: 0
y01: 1
y02: 0

x00 AND y00 -> z00
x01 XOR y01 -> z01
x02 OR y02 -> z02
```

ゲートは入力を待っているため、いくつかの配線は値を持って始まる必要があります（システム全体への入力として）。
前半はこれらの値を指定します。
例えば `x00: 1` は `x00` という名前の配線が値 `1` で始まることを意味します
（ゲートが既にその配線にその値を出力しているかのように）。

後半では、全てのゲートとそれに接続されている配線を列挙します。
例えば `x00 AND y00 -> z00` は、入力に配線 `x00` と `y00` が接続され
その出力を配線 `z00` に書き込む`AND`ゲートがあることを述べています。

この例では、これらのゲートをシミュレーションすると、
最終的に配線`z00`に`0`が、配線`z01`に`0`が、配線`z02`に`1`が現れます。

最終的に、システムは `z` で始まる全ての配線のビットを組み合わせて**数値**を生成しようとしています。
`z00`は最下位ビットで、次に`z01`、次に`z02`、以下同様に続きます。

この例では、3つの出力ビットが2進数の`100`を形成し、これは10進数の**4**に相当します。

より大きな例を示します：

```
x00: 1
x01: 0
x02: 1
x03: 1
x04: 0
y00: 1
y01: 1
y02: 1
y03: 1
y04: 1

ntg XOR fgs -> mjb
y02 OR x01 -> tnw
kwq OR kpj -> z05
x00 OR x03 -> fst
tgd XOR rvg -> z01
vdt OR tnw -> bfw
bfw AND frj -> z10
ffh OR nrd -> bqk
y00 AND y03 -> djm
y03 OR y00 -> psh
bqk OR frj -> z08
tnw OR fst -> frj
gnj AND tgd -> z11
bfw XOR mjb -> z00
x03 OR x00 -> vdt
gnj AND wpb -> z02
x04 AND y00 -> kjc
djm OR pbm -> qhw
nrd AND vdt -> hwm
kjc AND fst -> rvg
y04 OR y02 -> fgs
y01 AND x02 -> pbm
ntg OR kjc -> kwq
psh XOR fgs -> tgd
qhw XOR tgd -> z09
pbm OR djm -> kpj
x03 XOR y03 -> ffh
x00 XOR y04 -> ntg
bfw OR bqk -> z06
nrd XOR fgs -> wpb
frj XOR qhw -> z04
bqk OR frj -> z07
y03 OR x01 -> nrd
hwm AND bqk -> z03
tgd XOR rvg -> z12
tnw OR pbm -> gnj
```

`z`で始まる全ての配線の値を待った後、このシステムの配線は次の値を持っています：

```
bfw: 1
bqk: 1
djm: 1
ffh: 0
fgs: 1
frj: 1
fst: 1
gnj: 1
hwm: 1
kjc: 0
kpj: 1
kwq: 0
mjb: 1
nrd: 1
ntg: 0
pbm: 1
psh: 1
qhw: 1
rvg: 0
tgd: 0
tnw: 1
vdt: 1
wpb: 0
z00: 0
z01: 0
z02: 0
z03: 1
z04: 0
z05: 1
z06: 1
z07: 1
z08: 1
z09: 1
z10: 1
z11: 0
z12: 0
```

全ての`z`で始まる配線のビットを組み合わせると、二進数`0011111101000`が生成されます。
この数を10進数に変換すると2024になります。

ゲートと配線のシステムをシミュレートします。
`z`で始まる配線に出力される10進数はいくつですか？

# パート2

監視装置をより詳しく調査した結果、シミュレーションしているシステムが
**ふたつの2進数を加算**しようとしていることがわかりました。

具体的には、`x` で始まる配線のビットをひとつの2進数として扱い、
`y` で始まる配線のビットをふたつめの2進数として扱い、
それらふたつの数を加算しようとしています。
この演算の出力は、`z` で始まる配線上に2進数として生成されます。
（3つの場合全てにおいて、配線`00`が最下位ビットで、その後に`01`, `02`と続きます。）

あなたのパズル入力にある配線の初期値は、間違った値に合計される数値のペアの**ひとつの実例**を表しています。
最終的には、入力として与えられる**任意の**2つの2進数は正しく処理されるべきです。
つまり、`x` で始まる配線と `y` で始まる配線のビットの任意の組み合わせに対して、
それらのビットが表す2つの数の合計が、`z` で始まるワイヤ上に2進数として生成されるべきです。

例えば、4本の`x`配線、4本の`y`配線、5本の`z`配線を持つ加算システムがあるとき、
`x`配線に任意の4ビット数を供給し、`y`配線に任意の4ビット数を供給し、
最終的にその2つの数の合計を`z`配線に5ビット数として見つけることができるはずです。
このようなシステムに数を提供する方法の1つは、
`x`配線に`11`（2進数で`1011`）を、`y`配線に`13`（2進数で`1101`）を送ることです：

```
x00: 1
x01: 1
x02: 0
x03: 1
y00: 1
y01: 0
y02: 1
y03: 1
```

システムが正しく動作しているならば、全てのゲートの処理が完了した後、
`z`配線上に5ビットの2進数`11000`として24 (11+13) がみつかるはずです。

```
z00: 0
z01: 0
z02: 0
z03: 1
z04: 1
```

残念ながら、あなたの実際のシステムは、もっと多くのビットで数を加算する必要があり、そのためにもっと多くの配線があります。

デバイスの擦り傷や傷の科学捜査的分析に基づいて、
出力配線が**入れ替えられた**ゲートのペアがちょうど**4組**あることがわかります。
（ひとつのゲートはそのようなペアのひとつにしか入ることができません。
つまり、ゲートの出力は複数回入れ替えられることはありません。）

例えば、以下のシステムは、`x00`から`x05`までの6ビット数と`y00`から`y05`までの6ビット数のビット単位のANDを求め、
その結果を`z00`から`z05`までの6ビット数として書き込むことになっています：

```
x00: 0
x01: 1
x02: 0
x03: 1
x04: 0
x05: 1
y00: 0
y01: 0
y02: 1
y03: 1
y04: 0
y05: 1

x00 AND y00 -> z05
x01 AND y01 -> z02
x02 AND y02 -> z01
x03 AND y03 -> z03
x04 AND y04 -> z04
x05 AND y05 -> z00
```

しかしこの例では、2組のゲートの出力配線が入れ替わっており、そのためシステムが誤った答えを生成しています。
出力が入れ替わった最初のゲートのペアは `x00 AND y00 -> z05` と `x05 AND y05 -> z00` です。
2番目のゲートのペアは `x01 AND y01 -> z02` と `x02 AND y02 -> z01` です。
これら2つの入れ替わりを修正すると、`x`または`y`で始まる配線の任意の初期値のセットに対して
意図した通りに動作するシステムが得られます：

```
x00 AND y00 -> z00
x01 AND y01 -> z01
x02 AND y02 -> z02
x03 AND y03 -> z03
x04 AND y04 -> z04
x05 AND y05 -> z05
```

この例では、2組のゲートの出力が入れ替わりに関与しています。
出力配線の名前をソートしてカンマで結合すると、
入れ替わりに関与する配線のリストは `z00,z01,z02,z05` となります。

もちろん、実際のシステムはこれよりもはるかに複雑で、
出力を入れ替える必要があるゲートは`z`で始まる配線に接続されているものに限らず**どれも**可能性があります。
出力配線`aaa`と`eee`を、`ooo`と`z99`を、`bbb`と`ccc`を、`aoc`と`z24`を入れ替える必要があると判明した場合、
あなたの答えは `aaa,aoc,bbb,ccc,eee,ooo,z24,z99` となります。

あなたのゲートと配線のシステムには、出力配線を入れ替える必要があるゲートが**4組**あります
ー 全部で**8本**の配線です。
あなたのシステムが正しく加算を行うために、どの4組のゲートの出力を入れ替える必要があるかを特定してください。
入れ替えに関与する8本の配線の名前をソートして、それらの名前をカンマで結合すると何になりますか？
