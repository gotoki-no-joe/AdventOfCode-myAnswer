さてどうしたもんか。

命令を、st -> st な関数closureに変換して直接プログラム化するのを、機械でするまでもなく手でやれてしまいそうなのでそうするのが早いかなと。

サンプルの場合
0,3,5,4,3,0

0,3 : A >> 3 -> A
5,4 : out A
3,0 : jnz 0
なのでAを3ビットシフトしては3ビットずつ出力するわけで、
最初に捨てられる分も含めて

ghci> foldr (\x acc -> acc * 8 + x) 0 [0,0,3,5,4,3,0]
117440

117440 = 00,011,100,101,011,000,000

これで出る。

input.txt の場合

2,4,1,2,7,5,0,3,4,7,1,7,5,5,3,0

0: 2,4 : A & 7 -> B
1: 1,2 : B xor 2 -> B
2: 7,5 : A >> B -> C
3: 0,3 : A >> 3 -> A
4: 4,7 : B xor C -> B
5: 1,7 : B xor 7 -> B
6: 5,5 : out (B & 7)
7: 3,0 : jnz 0

Aは3ビットずつ右シフトされ、0になったら次のoutで終わり。

b0 = a .&. 7     : 3bit
b1 = xor b0 2    : 3bit
c2 = shiftR a b1 : big
a3 = shiftR a 3
b4 = xor b1 c2   : big
b5 = xor b4 7    : 3bit つまり、cも3ビットしか考えなくていい
out b5 (& 7)
jnz 0

b0に切り出す今回の3ビットによって、
   xor 2
0  2
1  3
2  0
3  1
4  6
5  7
6  4
7  5

とc2に切り出すビット位置が変化する。
ともかくその結果のその位置の3ビットについてxorした結果が出力されるので、
b0の値8通り×c2のとある位置の値8通り
で、出る値も定まる

b / c
[[0,1,2,3,4,5,6,7]
,[1,0,3,2,5,4,7,6]
,[2,3,0,1,6,7,4,5]
,[3,2,1,0,7,6,5,4]
,[4,5,6,7,0,1,2,3]
,[5,4,7,6,1,0,3,2]
,[6,7,4,5,2,3,0,1]
,[7,6,5,4,3,2,1,0]]

全ての値が、それぞれ8とおりの設定で可能。
8^16 = 281,474,976,710,656
ちょっと組み合わせの数が多いな。

ただし、最後の数字を出すときはAは3ビットしかない。

0-7で走らせたら、0が出て終わるのは5のときだった。
次は、3,0と出て終わる、かつ4-6ビットは5のときとは？

下3ビットが7(47)または3(43)がそうでした。
それで、次は 5,3,0と出て終わるようなのは？
と幅優先探索していけば見つかるねこれ。
