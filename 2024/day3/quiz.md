# 3日目: じっくり考える

(原文 Mull It Over : 問題の `mul` と掛けている)

「コンピュータに問題があり、主任歴史学者の在庫があるかどうかわかりません。
倉庫を確認していただければと思います」
と、[北極トボガンそり貸し店](../../2020/day2/quiz.md)の店主が少し取り乱した様子で言いました。
歴史学者たちは倉庫の方に行きました。

店主はあなたのほうを向いて言いました。
「なぜ当店のコンピュータにまた問題が発生しているのか、調べては貰えませんか？」

コンピュータはプログラムを実行しようとしているようですが、
メモリ（あなたのパズル入力）が**破損**しています。
全ての命令がごちゃ混ぜになっています！

プログラムの目的は、単に**いくつかの数値を掛け合わせる**ことのようです。
これは `mul(X,Y)` のような命令で実行されます。
ここで `X`  と `Y` はそれぞれ1～3桁の数値です。
例えば `mul(44,46)` は44と46を掛けて2024という結果になります。
同様に `mul(123,4)` は123と4を掛けます。

ただし、プログラムのメモリが破損しているため、**無視する**べき無効な文字も多数あります。
これは `mul` 命令の一部のように見えてもです。
`mul(4*`, `mul(6,9!`, `?(12,34)`, or `mul ( 2 , 4 )` などの文字列では**何もしません**。

例として、次の破損したメモリの一部を考ましょう：

```
xmul(2,4)%&mul[3,7]!@^do_not_mul(5,5)+mul(32,64]then(mul(11,8)mul(8,5))
```

ハイライト表示された（されてません、原文参照）4箇所だけが実際のmul命令です。
各命令の結果を合計すると 161 $(2*4 + 5*5 + 11*8 + 8*5)$ となります。

破損したメモリをスキャンして、破損していない `mul` 命令を探します。
乗算の結果をすべて合計するといくつになりますか？

# パート 2

破損したメモリをスキャンすると、一部の条件文もまだ無傷なことに気付きました。
プログラム内の破損していない一部の条件文を処理すれば、より正確な結果が得られる可能性があります。

処理する必要がある新しい命令が2つあります：

- `do()` 命令により、以降の `mul` 命令が**有効**になります。
- `don't()` 命令は以降の `mul` 命令を**無効**にします。

**直近の** `do()` 命令または `don't()` 命令のみが適用されます。
プログラムの開始時には、`mul` 命令は**有効**になっています。

例えば：

```
xmul(2,4)&mul[3,7]!^don't()_mul(5,5)+mul(32,64](mul(11,8)undo()?mul(8,5))
```

この破損したメモリは前の例と似ていますが、
今回は `mul(5,5)` と `mul(11,8)` 命令が、それらの前に `don't()` 命令があるために**無効**になっています。
他の `mul` 命令は、`do()` 命令によって再度**有効**になる最後の命令を含め、普通に機能します。

今回は結果の合計は48 $(2*4 + 8*5)$ です。

新しい命令を処理します。有効になっている乗算の結果をすべて合計するといくつになりますか？
