
1回転の操作が済むと、全ての `O` は東に寄っている。
東西方向に見て、`#` で区切られたそれぞれの区画に、`O` がいくつあるか、という個数だけで状況は識別できる。
どこにも寄っていない `O` の存在する初期状態はこの過程で出現する心配はないので無視する。

区画の個数を数えてみる。

```haskell
import Data.List.Split

countSpans = sum . map (length . wordsBy ('#' ==))
```

```
ghci> runner "sample.txt" countSpans
20
ghci> runner "input.txt" countSpans
1444
```

なので長さ1444の整数リストで表すのでは芸がない。一つの区画の長さはたかだか100なので、7ビットもあれば十分。
`divMod (1444 * 7) 8 = (1263, 4)` で1264バイトは素朴なビット表現より長くなってしまった。

それぞれの区画に素数を割り当て、`O`の個数を乗じた値を掛け合わせると、素因数分解により元の数が取り出せるが、
とてつもなく大きな数になってしまって役に立たない。
これを大きな素数でモジュロして、確率で衝突するハッシュを作ることもできるが、
ハッシュマップのある言語を物欲しそうに横目で見ながら、
単純なビット置き換えで続けよう。


リストのままでするときのビット表現への写像関数

```haskell
l2b :: [String] -> Integer
l2b = foldl' step 0 . filter ('#' /=) . concat
  where
    step acc 'O' = acc .<<. 1 .|. 1
    step acc '.' = acc .<<. 1
```

