# 20 日目: パルス伝播

あなたの助けにより、妖精たちは適切な部品を見つけて全ての機械を修理することができました。
後は、コマンドを送信して機械群を起動し、砂を再び流すだけです。

機械群は遠く離れており、長い**ケーブル**で接続されています。
ケーブルは機械に直接接続されるのではなく、さまざまな初期化タスクを実行し、
通信中継器としても機能する、機械に接続された通信**モジュール**に接続されています。

モジュールは**パルス**を使用して通信します。
各パルスは**ハイ**パルスまたは**ロー**パルスのいずれかです。
モジュールがパルスを送信すると、その種類のパルスが**宛先モジュール**のリスト内の各モジュールに送信されます。

いくつかの異なる種類のモジュールがあります。

**フリップフロップ**モジュール（接頭辞 `%`）は**オン**または**オフ**のいずれかの状態を持ちます。
最初は**オフ**になっています。
フリップフロップモジュールがハイパルスを受信した場合、それは無視され、何も起こりません。
しかし、フリップフロップモジュールがローパルスを受信すると、**オンとオフが切り替わります**。
オフになっていた場合はオンになり、ハイパルスが送信されます。
オンになっていた場合はオフになり、ローパルスが送信されます。

**NAND**モジュール（接頭辞 `&`）接続された入力モジュールの**それぞれ**から受信した直近のパルスの種類を**記憶**します。
最初は各入力について**ローパルス**を記憶します。
パルスを受信すると、NANDモジュールはまずその入力に関する記憶を更新します。
次に、全ての入力について**ハイパルス**を記憶している場合は**ローパルス**を、
さもなくば**ハイパルス**を送信します。

一つだけ、**放送モジュール**（名前は `broadcaster`）があります。
パルスを受信すると、同じパルスを全ての宛先モジュールに送信します。

ここ、砂機械司令部には、ボタンが1つ付いたモジュールがあります。
これは**ボタンモジュール**です。
ボタンを押すと、**ローパルス**が1つ `broadcaster` モジュールに直接送信されます。

ボタンを押した後は、もう一度押す前に、全てのパルスが配信され、完全に処理されるまで待つ必要があります。
モジュールがまだパルスを処理している場合は、決してボタンを押さないでください。

パルスは常に**送信された順に**処理されます。
したがって、パルスがモジュール `a`, `b`, `c` に送信され、
次にモジュール `a` がそのパルスを処理してさらなるパルスを送信する場合、
`b` モジュールと `c` モジュールに送信されたパルスが先に処理されます。

モジュール構成（あなたのパズル入力）には、各モジュールがリストされます。
モジュールの名前の前には、その種類を識別する記号が付いています。（例外もあります。）
名前の後には矢印と宛先モジュールのリストが続きます。
例えば：

```
broadcaster -> a, b, c
%a -> b
%b -> c
%c -> inv
&inv -> a
```

このモジュール構成では、ブロードキャスターには、a、b、c という名前の 3 つの宛先モジュールがあります。これらの各モジュールはフリップフロップ モジュールです (% プレフィックスで示されています)。 a は b に出力し、 c は inv という名前の別のモジュールに出力します。 inv は結合モジュール (& プレフィックスで示されています) であり、入力が 1 つしかないため、 のように動作します。インバータ (受信したパルスの逆のタイプを送信します)。 a に出力します。

ボタンを 1 回押すと、次のパルスが送信されます。

button -low-> broadcaster
broadcaster -low-> a
broadcaster -low-> b
broadcaster -low-> c
a -high-> b
b -high-> c
c -high-> inv
inv -low-> a
a -low-> b
b -low-> c
c -low-> inv
inv -high-> a
このシーケンスの後、フリップフロップ モジュールはすべてオフになるため、もう一度ボタンを押すと同じシーケンスが繰り返されます。

さらに興味深い例を次に示します。

broadcaster -> a
%a -> inv, con
&inv -> b
%b -> con
&con -> output
このモジュール構成には、broadcaster、2 つのフリップフロップ (a および b という名前)、単一のフリップフロップが含まれます。入力結合モジュール (inv)、複数入力結合モジュール (con)、および output という名前の型なしモジュール (テスト用)目的）。多入力連結モジュールconは 2 つのフリップフロップ モジュールを監視し、両方がオンの場合はロー パルスを送信します。 を output モジュールに追加します。

ボタンを 1 回押すと、次のようになります。

button -low-> broadcaster
broadcaster -low-> a
a -high-> inv
a -high-> con
inv -low-> b
con -high-> output
b -high-> con
con -low-> output
両方のフリップフロップがオンになり、Low パルスが output に送信されます。ただし、両方のフリップフロップがオンになり、con 2 つの入力のそれぞれからの High パルスを記憶しているため、もう一度ボタンを押すと、別の動作が行われます。

button -low-> broadcaster
broadcaster -low-> a
a -low-> inv
a -low-> con
inv -high-> b
con -high-> output
フリップフロップ a がオフになります。ここで、 con はモジュール a からの Low パルスを記憶しているため、High パルスのみを output に送信します。

ボタンを 3 回押します。

button -low-> broadcaster
broadcaster -low-> a
a -high-> inv
a -high-> con
inv -low-> b
con -low-> output
b -low-> con
con -high-> output
今回は、フリップフロップ a がオンになり、次にフリップフロップ b がオフになります。ただし、b がオフになる前に、con に送信されたパルスが最初に処理されるため、すべての高パルスが簡単に記憶されます< /span> に送信します。< /span> がその状態を更新し、High パルスを がオフになり、output に送信します。その後、フリップフロップ を入力として使用し、Low パルスを bconoutput

最後に、a をオン、b をオフにして、ボタンを 4 回押します。

button -low-> broadcaster
broadcaster -low-> a
a -low-> inv
a -low-> con
inv -high-> b
con -high-> output
これでサイクルが完了します。a がオフになり、con は低いパルスのみを記憶し、すべてのモジュールが元の状態に復元されます。

ケーブルを暖めるために、エルフたちは1000 回ボタンを押しました。その結果、送信されたパルスの数はいくつですか (ボタン自体によって送信されたパルスを含む)?

最初の例では、ボタンを押すたびに同じことが起こります。8 ロー パルスと 4 ハイ パルスが送信されます。したがって、 ボタンを 1000 回押すと、 8000 ロー パルスと 4000 ハイ パルスが送信されます。これらを掛け合わせると 32000000 になります。

2 番目の例では、ボタンを 1000 回押した後、4250 ロー パルスと 2750 ハイ パルスが送信されます。 。これらを掛け合わせると 11687500 になります。

モジュール構成を確認してください。ボタンを 1000 回押した後に送信される低パルスと高パルスの数を決定し、ボタンを押すたびにすべてのパルスが完全に処理されるのを待ちます。 送信された Low パルスの総数と High パルスの総送信数を掛けると何が得られますか?

まず、パズルの入力を取得します。

答え：
 

[共有] することもできます。] このパズル

- - パート2 - -
Island Island まで砂を移動させる最後の機械には、 という名前のモジュールが取り付けられていますrx。単一の低パルスが に送信されると、機械がオンになりますrx。

すべてのモジュールをデフォルトの状態にリセットします。ボタンを押すたびにすべてのパルスが完全に処理されるのを待って、 ?という名前のモジュールに 1 つの低パルスを送信するのに必要なボタンの最小押下回数は何回ですかrx?
