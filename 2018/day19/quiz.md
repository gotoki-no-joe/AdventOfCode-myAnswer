# 19 日目: 流れに身を任せて

妖精が北極基地の建設を着々と進めているので、あなたは装置のプログラミングの内部動作を理解することに注意を戻します。

お気づきのように[装置のオペコード](../day16/quiz.md)にはジャンプ命令などのフロー制御が含まれていません。
装置の[マニュアル](../day16/quiz.md)にはさらに次のように説明されています。

『フロー制御が必要なプログラムでは、命令ポインタを**レジスタに結合**して、命令ポインタを直接操作できるようにすることができます。
このとき、`setr`/`seti`は絶対ジャンプとして、`addr`/`addi`は相対ジャンプとして機能することができ、その他のオペコードは本当に魅力的な効果を引き起こす可能性があります。』

この機構は、`#ip 1`のような宣言によって実現されます。これは、レジスタ1にアクセスすることでプログラムが命令ポインタ自体に間接的にアクセスできるようにレジスタを変更します。
この種の結合を補うために、今や6つのレジスタ（0から5の番号が付けられています）があります。
命令ポインタに結合されていない5つは通常どおり動作します。
それ以外については、[この装置を最後に使用したとき](../day16/quiz.md)と同じ規則が適用されます。

**命令ポインタ**がレジスタに結合されている場合、その値は各命令が実行される直前にそのレジスタに書き込まれ、各命令の実行が終了した直後にそのレジスタの値が命令ポインタに書き戻されます。
その後、命令ポインタに1を加算して次の命令に移動します。これは、命令ポインタの値が命令によって更新されたばかりであっても例外ではありません。（このため、命令は事実上、次に実行したい命令の**前の**命令に命令ポインタを設定する必要があります。）

命令ポインタは、最初の命令実行中は0、2番目の命令の実行中は1、以下同様となります。
命令ポインタが、プログラムで定義されている命令の外にある命令を装置にロードさせようとした場合、プログラムはただちに停止します。命令ポインタは0から始まります。

この新しい情報はすでに役立つことが判明しています。装置のCPUはそれほど強力ではなく、バックグラウンドプロセスが実行時間のほとんどを占めています。あなたはバックグラウンドプロセスの宣言と命令をファイルダンプしました（あなたのパズルの入力）。番号ではなくオペコードの名前を使用するようにしました。

例えば、次のプログラムがあるとします：

```
#ip 0
seti 5 0 1
seti 6 0 2
addi 0 1 0
addr 1 2 3
setr 1 0 0
seti 8 0 4
seti 9 0 5
```

これを実行すると以下の命令が実行されます。
各行は、命令開始時の命令ポインタの値、命令実行前の6つのレジスタの値 (角括弧内)、命令そのもの、命令実行後の6つのレジスタの値 (角括弧内) からなります。

```
ip=0 [0, 0, 0, 0, 0, 0] seti 5 0 1 [0, 5, 0, 0, 0, 0]
ip=1 [1, 5, 0, 0, 0, 0] seti 6 0 2 [1, 5, 6, 0, 0, 0]
ip=2 [2, 5, 6, 0, 0, 0] addi 0 1 0 [3, 5, 6, 0, 0, 0]
ip=4 [4, 5, 6, 0, 0, 0] setr 1 0 0 [5, 5, 6, 0, 0, 0]
ip=6 [6, 5, 6, 0, 0, 0] seti 9 0 5 [6, 5, 6, 0, 0, 9]
```

詳細には、このプログラムを実行すると、次のイベントが発生します：

- 最初の行 (`#ip 0`) は、このプログラムでは命令ポインタがレジスタ0に結合されることを示します。
これは命令ではないため、この行の処理中に命令ポインタの値は変化しません。
- 命令ポインタには0が入っているため、最初の命令が実行されます (`seti 5 0 1`)。
これはレジスタ0を現在の命令ポインタの値(0)に更新し、レジスタ1を5に設定し、命令ポインタを0に設定し（ここで、実行した命令はレジスタ0を変更していないので効果はありません）、命令ポインタに1を加算します。
- 命令ポインタには1が含まれているため、2番目の命令`seti 6 0 2`が実行されます。
これは、その直前の命令と非常によく似ています。
レジスタ2に6を格納し、命令ポインタには値2が残されます。
- 命令ポインタは2で、命令`addi 0 1 0`を指しています。
これは**相対ジャンプ**のようなものです。
命令ポインタの値2がレジスタ0にロードされます。
次に、レジスタ0の値と値1を加算した結果を求め、その結果3をレジスタ0に格納し戻します。
次に、レジスタ0は命令ポインタにコピーされて戻されます。
これにより、命令ポインタが本来の値よりも1大きくなり、次の命令 (`addr 1 2 3`) が完全にスキップされます。最後に、1が命令ポインタに足されます。
- 命令ポインタは4であるため、命令`setr 1 0 0`が実行されます。
これは**絶対ジャンプ**のようなものです。レジスタ1に含まれる値5をレジスタ0にコピーし、この値が最終的に命令ポインタに到達します。
次に、命令ポインタがインクリメントされ、6になって終わります。
- 命令ポインタは6であるため、命令`seti 9 0 5`がレジスタ5に9を格納します。
命令ポインタがインクリメントされ、プログラムの外側を指すようになり、プログラムが終了します。

このバックグラウンドプロセスが停止したときに**レジスタ0に残る値**は何ですか？

# パート2

新しいバックグラウンドプロセスがすぐに代わりに起動します。
見た目は同じですが、よく見てみると、今回は レジスタ0が値1で始まっていることがわかります。

この新たなバックグラウンドプロセスが停止したときに**レジスタ0に残る値**は何ですか？
