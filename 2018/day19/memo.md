パート1は素直にemulationをして、それでもしばらく実行時間がかかった。
でもまぁ動いた。
パート2はghciでしばらく放置したけど、どうも進まない。
コンパイルしてやるのもどうかという気がしている。

コードを解釈してみよう。

#ip 3
addi 3 16 3  : 0 $3 <- 0 + 16 + 1 : jump 17
seti 1 9 5   : 1 $5 <- 1
seti 1 1 4   : 2 $4 <- 1
mulr 5 4 2   : 3 $2 <- $5 * $4
eqrr 2 1 2   : 4 $2 <- $2 == $1 ? 1 : 0
addr 2 3 3   : 5 $3 <- $2 + $3 : bra $2
addi 3 1 3   : 6 $3 <- $3 + 1 : bra 1
addr 5 0 0   : 7 $0 <- $0 + $5
addi 4 1 4   : 8 $5 <- $4 + 1
gtrr 4 1 2   : 9 $2 <- $4 > $1 ? 1 : 0
addr 3 2 3   :10 $3 <- $3 + $2 : 次をbypassするか否か切り替え
seti 2 3 3   :11 $3 <- 2 : jump 3
addi 5 1 5   :12 $5 <- $5 + 1
gtrr 5 1 2   :13 $2 <- $5 > $1 ? 1 : 0
addr 2 3 3   :14 $3 <- $3 + $2 : 次をbypassするか否か切り替え
seti 1 4 3   :15 $3 <- 1 : jump 1
mulr 3 3 3   :16 $3 <- $3 * $3 : HALT
addi 1 2 1   :17 [***] $1 <- $1 + 2
mulr 1 1 1   :18 $1 <- $1 * $1
mulr 3 1 1   :19 $1 <- $3 * $1 = 19 * $1
muli 1 11 1  :20 $1 <- $1 * 11
addi 2 2 2   :21 $2 <- $2 + 2
mulr 2 3 2   :22 $2 <- $2 * $3 = $2 * 22
addi 2 20 2  :23 $2 <- $2 + 20
addr 1 2 1   :24 $1 <- $1 + $2
addr 3 0 3   :25 $3 <- $3 + $0 = bra $0
seti 0 4 3   :26 $3 <- $0 + 4  = jump $0 + 5
setr 3 9 2   :27 $2 <- $3 = 27
mulr 2 3 2   :28 $2 <- $3 * $2 = 28 * 27
addr 3 2 2   :29 $2 <- $3 + $2 = 29 + $2
mulr 3 2 2   :30 $2 <- $3 * $2 = 30 * $2
muli 2 14 2  :31 $2 <- $2 * 14
mulr 2 3 2   :32 $2 <- $2 * $3 = 32 * $2
addr 1 2 1   :33 $1 <- $1 + $2
seti 0 6 0   :34 $0 <- 0
seti 0 0 3   :35 $3 <- 0 = jump 1

何をしているのか、が全然見えない。$3に代入する、ジャンプ以外のストレートな計算を、全ての位置からまっすぐ下ろすか？
計算から見て、レジスタの値は全て非負整数っぽい。

Cで書いたらめっちゃ速いけど、でも止まらない。
それを使って動作を考察する。
r4は、2で1に初期化され、3で使われ、8で++され、9～11で3に戻るループ変数Jっぽい。
r5は、1で1に初期化され、3,7,で使われ、12で++され、13～15で2に戻るループ変数Iっぽい。
r2はtmp varっぽい。

```
for (I = 1; I <= r1; I++) {     // 1; 13,14; 12
   for (J = 1; J <= r1; J++) {  // 2; 10,11 ; 8
      if (I * J == r1)          // 3,4,5,6,
      { r0 += I; }              // 7
   }                            // 11
}                               // 15
return r0;          // 16 HALT
```

r0の初期値は不明だけど、r1の全ての約数の和をr0に足し込んでいる。がコード前半にある後半。

そのr1をいくつに設定するか、が17～なんだな。初期化部分。

```
r1 = (r1=0 + 2) ^ 2 * 19 * 11; // 17,18, 19, 20 (=836)
r2 = (r2=0 + 2) * 22 + 20 // 21, 22, 23 (=64)
r1 = r1 + 64 // 24 (=900)
```
25が、パート1とパート2を分ける分岐点。
パート1だとここで1へ飛び、900の約数の総和を計算するっぽい。
どれ。
```
ghci> sum [i | i <- [1..900], mod 900 i == 0]
2821
```
うん、あっとる。

パート2では、27から続きの計算をしてからになる。
```
(r1 = 900)
r2 = (27 * 28 + 29) * 30 * 14 * 32 // 27, 28, 29, 30, 31, 32 (= 10550400)
r1 = r1 + r2 // 33 (=10551300)
r0 = 0 // 34 ずれないようにリセットしてから
jump 1 飛ぶ。
```

```haskell
part2 = sum [i | i <- [1..10551300], mod 10551300 i == 0]
30529296
```

もう面倒になってこれで答えを出してしまった。わはは。

せいかい。
