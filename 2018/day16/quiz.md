# 16日目：時間的分類 #

妖精たちがホットチョコレートをうまく防衛したのを見ると、
あなたはまた時間の流れを落ちていきました。
これは厄介なことになりそうです。

あなたが自分の時間に戻るつもりなら、
この手首のデバイスがどのように動作するのかを理解する必要があります。
あなたは次の目的地に着くまで少しだけ時間があり、
少々の試行錯誤で、
デバイスの小さな画面にプログラミングマニュアルを
表示させるができました。

マニュアルによれば、デバイスには
4つのレジスタ（0から3の番号が付いています）があり、
それは16個のオペコードからなる命令により操作できます。
レジスタは値0で始まります。

すべての命令は、
**オペコード**、2つの**入力**（AおよびBと呼ぶ）、
**出力**（Cと呼ぶ）の順の4つの値で構成されています。
オペコードは、命令の動作と入力の解釈方法を指定します。
出力Cは常にレジスタとして扱われます。

以下のオペコードの説明で、
何か「**値A**」と書かれている場合は、
Aとして**文字どおりに**与えられた数を取ることを意味します。
（これは「即値」とも呼ばれます。）
何か「**レジスタA**」と書かれている場合は、
Aとして与えられた番号を
**その番号のレジスタ**から読み出す（または書き込む）
ために使用することを意味します。
よって例えば、
オペコード`addi`がレジスタ`A`と値`B`を足し
結果をレジスタ`C`に格納するならば、
そして命令`addi 0 7 3`に遭遇したならば、
デバイスはレジスタ0にある値に7を足して結果の和をレジスタ3に格納する。
このプロセスにおいてレジスタ0,1,2は決して変更されません。

多くのオペコードは、引数をどのように解釈するかを除いて似ています。
オペコードは7つの一般的なカテゴリに分類されます。

加算：

- `addr`（レジスタと加算）レジスタAとレジスタBを加算した結果をレジスタCに格納します。
- `addi`（即値を加算）レジスタAと値Bを加算した結果をレジスタCに格納します。

乗算：

- `mulr`（レジスタと乗算）レジスタAとレジスタBを乗算した結果をレジスタCに格納します。
- `muli`（即値と乗算）レジスタAと値Bを乗算した結果をレジスタCに格納します。

ビット単位AND：

- `banr`（レジスタとビット単位AND）
レジスタAとレジスタBのビット単位の論理積の結果をレジスタCに格納します。
- `bani`（即値とビット単位AND）
レジスタAと値Bのビット単位の論理積の結果をレジスタCに格納します。

ビット単位OR：

- `borr`（レジスタとビット単位OR）
レジスタAとレジスタBのビット単位のORの結果をレジスタCに格納します。
- `bori`（即値とビット単位のOR）
レジスタAと値Bのビット単位のORの結果をレジスタCに格納します。

割り当て：

- `setr` （レジスタ設定）
レジスタAの内容をレジスタCにコピーします。（入力Bは無視されます。）
- `seti`（即値設定）
値AをレジスタCに格納します。（入力Bは無視されます。）

大なりテスト：

- `gtir`（即値-レジスタ比較）
値AがレジスタBより大きい場合にレジスタCを1に設定します。
それ以外の場合、レジスタCは0に設定されます。
- `gtri`（レジスタ-即値比較）
レジスタAが値Bより大きい場合にレジスタCを1に設定します。
それ以外の場合、レジスタCは0に設定されます。
- `gtrr`（レジスタ-レジスタ比較）
レジスタAがレジスタBより大きい場合にレジスタCを1に設定します。
それ以外の場合、レジスタCは0に設定されます。

同値テスト：

- `eqir`（即値-レジスタ同値）
値AがレジスタBと等しい場合にレジスタCを1に設定します。
それ以外の場合、レジスタCは0に設定されます。
- `eqri`（レジスタ-即値同値）
レジスタAが値Bと等しい場合にレジスタCを1に設定します。
それ以外の場合、レジスタCは0に設定されます。
- `eqrr`（レジスタ-レジスタ同値）
レジスタAがレジスタBと等しい場合にレジスタCを1に設定します。
それ以外の場合、レジスタCは0に設定されます。

残念ながら、マニュアルには各オペコードの**名前**は記載されていますが、
その**番号**は示されていません。
ただし、CPUを監視して、命令の実行前後でレジスタの内容を確認して、
それらを導出しようとすることができます。
各オペコードには0から15の番号が付いていますが、
マニュアルではどれがどれなのかは書いてありません。
たとえば、次のサンプルをキャプチャしたとします。

~~~
Before: [3, 2, 1, 1]
9 2 1 2
After:  [3, 2, 2, 1]
~~~

このサンプルは、命令`9 2 1 2`のレジスタへの効果を示しています。
命令が実行される前には、
レジスタ0は値3を持ち、レジスタ1は値2を持ち、
レジスタ2は値1を持ちます。
命令実行後、レジスタ2の値は2になります。

命令`9 2 1 2`自体は、オペコード9がA=2, B=1, C=2で実行されたことを意味します。
オペコード9は上記の16個のオペコードのいずれかになりますが、
そのうち3つだけがサンプルに示された結果を引き起こすような動作をします。

- オペコード9は`mulr`であり得ます。
レジスタ2（値1を持つ）とレジスタ1（値2を持つ）を乗じると2を得ます。
これは出力レジスタであるレジスタ2に格納された値と一致します。
- オペコード9は`addi`であり得ます。
レジスタ2（値1を持つ）と値1を足すと2を得ます。
これは出力レジスタであるレジスタ2に格納された値と一致します。
- オペコード9は`seti`であり得ます。
値2は出力レジスタであるレジスタ2に格納された値と一致します。
Bとして与えられた数は無関係です。

他のオペコードはどれも、サンプルでキャプチャされた結果を生成しません。
このため、上記のサンプルは**この3つのオペコードのように動作します**。

これらのサンプルを多く収集します。（パズル入力の最初の部分）
マニュアルには小さなテストプログラムも含まれています。（パズル入力の2番目の部分）
後者は*今は無視*してください。

オペコード番号を無視して、
**パズル入力のサンプルのうち、
3つ以上のオペコードのように振る舞るものはいくつありますか？**

# パート2 #

収集したサンプルを使用して、各オペコードの番号を調べ、
テストプログラム（パズル入力の2番目のセクション）を実行します。

**テストプログラムを実行した後、レジスタ0に入っている値はいくつですか？**
