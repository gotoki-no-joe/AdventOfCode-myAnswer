// #ip 4
// テスト1
r3 = 123;               // 0 : seti 123 0 3
r3 = r3 & 456;          // 1 : bani 3 456 3
r3 = r3 == 72 ? 1 : 0;  // 2 : eqri 3 72 3
r4 = r4 + r3;           // 3 : addr 3 4 4  r3 == 72 なら5、!=なら4へ
r4 = 0;                 // 4 : seti 0 0 4 無限ループ、テスト失敗 といっても、123 .&. 456 == 72 です。1に飛ぶんだけどな。
// テスト2？
r3 = 0;                 // 5 : seti 0 5 3
r2 = r3 | 65536;        // 6 : bori 3 65536 2
r3 = 7637914;           // 7 : seti 7637914 8 3
r1 = r2 & 255;          // 8 : bani 2 255 1     (= 0)
r3 = r3 + r1;           // 9 : addr 3 1 3       (= 7637914)
r3 = r3 & 16777215;     //10 : bani 3 16777215 3 (= 7637914)
r3 = r3 * 65889;        //11 : muli 3 65899 3 (= 22913742)
r3 = r3 & 16777215;     //12 : bani 3 16777215 3 (= 6136526)
r1 = 256 > r2 ? 1 : 0;  //13 : gtir 256 2 1 (= 1)
r4 = r4 + r1;           //14 : addr 1 4 4  256 > r2 なら16へ、違えば15へ
r4 = r4 + 1;            //15 : addi 4 1 4                           17
r4 = 27;                //16 : seti 27 1 4              28
r1 = 0;                 //17 : seti 0 7 1
r5 = r1 + 1;            //18 : addi 1 1 5 (= 1)
r5 = r5 * 256;          //19 : muli 5 256 5 (= 255)
r5 = r5 > r2 ? 1 : 0;   //20 : gtrr 5 2 5 (= 1)
r4 = r4 + r5;           //21 : addr 5 4 4   r5 > r2 なので23へ、違えば22へ
r4 = r4 + 1;            //22 : addi 4 1 4                             24
r4 = 25;                //23 : seti 25 3 4              26
r1 = r1 + 1;            //24 : addi 1 1 1
r4 = 17;                //25 : seti 17 0 4  -> 18へ(!?)
r2 = r1;                //26 : setr 1 8 2
r4 = 7;                 //27 : seti 7 7 4   -> 8へ
r1 = r3 == r0 ? 1 : 0;  //28 * eqrr 3 0 1 ------------ ここのr3をr0に設定すればいいはず。
r4 = r4 + r1;           //29 : addr 1 4 4 r3 == r0 なら HALT さもなくば 30 へ **ここが正しい終了窓口**
r4 = 5;                 //30 : seti 5 5 4                                6 テスト2再開

r0は変更されない、r3が至る値の答案入れ。
r4はPC
r1はテンポラリ
r5は18-20で一度使われるだけの、分岐先計算変数
r1は狭い広いループ変数
r2,r3は大域的に使っている。

5:
r3 = 0;

6:
r2 = r3 | 65536;
r3 = 7637914;

8:
r3 += r2 & 255; // r2の下位8ビットをr3に足す
r3 &= 0xFF_FFFF;
r3 = r3 * 65889;        //11 : muli 3 65899 3 奇妙なビットパターン、CRC的な何かかこれ？
r3 &= 0xFF_FFFF;

13: // ここ以降の計算はr3をいじっていないことに注意。
256 > r2 なら 28 へ // 抜けてテストへ。

17:
r1 = 0; // ここからループ
18:
(r1 + 1) * 256 > r2 なら 26 さもなくば 24 へ
24:
r1++;
goto 18 // r2 = r2 / 256 8ビット→シフトしている。普通に。

26:
r2 = r1;  // 上に戻る
goto 8

28:
r3 == r0 発見すれば HALT さもなくば 6 へ戻る

----

5:
r3 = 0;

6:
r2 = r3 | 65536;
r3 = 7637914;

8:
r3 += r2 & 255;
r3 &= 0xFF_FFFF;
r3 *= 65889;
r3 &= 0xFF_FFFF;

17:
if (256 > r2) break;

r2 >>= 8; つまり8ビットずつr3に足し込んでは計算する

5以降をまとめると、
r3 = 0;

for (;;) {
r2 = r3 | 65536;
r3 = 7637914;

while (r2 > 0) {
    r3 += r2 & 0xFF;
    r3 &= 0xFF_FFFF;
    r3 *= 65889;
    r3 &= 0xFF_FFFF;
    r2 >>= 8;
}

print r3;
}
こんなかな。
