{-
失われているので再現する。
-}

import Data.Char
import Data.List
import Debug.Trace

sample = "389125467"
input = "784235916"

{-
パート1は、適当にリストでやっても何とかなる。
-}

part1 = post . (!! 100) . iterate step . pre
  where
    post = map intToDigit . take 8 . tail . dropWhile (1 /=) . cycle
    pre = map digitToInt
    predd 1 = 9
    predd k = pred k
    step (d:ds) = xs3 ++ c : xs1 ++ xs4 ++ [d]
      where
        (xs1,xs2) = splitAt 3 ds
        c = head $ filter (flip notElem xs1) $ tail $ iterate predd d
        (xs3,_c:xs4) = break (c ==) xs2

test1 = part1 sample
main1 = part1 input

{-
パート2は今回が初めて。
カップが 1,000,000 個
例の説明が下手くそで萎えるんだが、5,4,3,2,1 ときて 10,9,8,7,6 となるんだろうな、多分。
しかし入力は9文字なので1余るんだ。それは飛ばすのか？
そうするしかない気がするが、ちゃんと書かないのが腹立つ。

そしてmoveの方は 10,000,000 回
線形探索は全体をぐるっと回る危険がある、なんにせよそんなに遠くには行かないから、
前後を同時に探すのがいいのかもしれない。線形探索でするなら。
part1でやったように全体をずらすのは、メモリがしっちゃかになるので避けたい。
それでは確実に 10^6 * 10^7 かかってしまう。

位置0～999,999にあるカップの番号、というmutable配列でやることを考える。
ひとつの方法として逆写像、カップの番号ごとにその位置、も管理すると、targetがO(1)で見つかる。
線形探索で両側同時に探す方法でも、そんなに悪い結果にはならない気もする。割と局所性があるはずだから。

配列ですると、移動は素直にするしかなくて、手前にあった場合に逆にずらすことをしても、10^6/2 の手間はかかる。
その工夫をしてもしなくても、オーダー的には計算量は変わらない。ダメな意味で。
そして、逆引き表を維持すると、その手間が単純に倍になってしまう。

なんかもう命令型言語でやる方が速い気がしてきたが、
自分がちゃんと使えるそれが見当たらない罠。js,python,rust,javaならこのコンピュータで動くけど。
-}
