import Data.List

-- part2考え直し

p2sample1 = [(0,7),(1,13),(4,59),(6,31),(7,19)]
p2sample2 = [(0,17),(2,13),(3,19)]
p2sample3 = [(0,67),(1,7),(2,59),(3,61)]
p2sample4 = [(0,67),(2,7),(3,59),(4,61)]
p2sample5 = [(0,67),(1,7),(3,59),(4,61)]
p2sample6 = [(0,1789),(1,37),(2,47),(3,1889)]
p2data = [(0,13),(3,41),(13,467),(25,19),(30,17),(42,29),(44,353),(50,37),(67,23)]

{-
左がいくつめか、右がID

探している時刻tは、+aするとidの倍数になっているもの、つまり
t + a = b * n, t = bn - a

naiveな方法は、どれかを選んでbn-aを順次生成し、これが他のidでも起点になっているか確認するもの。
なるべく高速にするには、最大のものを選ぶべき。
-}

comp1 abs = head $ filter test $ iterate (b +) (-a)
  where
    (a,b) = maximumBy (\(a,b) (c,d) -> compare d b) abs
    test t = and [(t+a) `mod` b == 0 | (a,b) <- abs]

{- この方法は一応サンプルでは正解を出すか、最後のサンプルで既に時間がかかりすぎる。

ヒントにある下限の数字と、問題の周期の最小公倍数
100000000000000
700404415482811
なかなかつらいな。

二つのバス (a1,b1),(a2,b2) のtがふたつt1<t2見つかったとする。
t1 = a1 + b1m1 = a2 + b2m2
t2 = a1 + b1n1 = a2 + b2n2
t2-t1 = b1(n1-m1) = b2(n2-m2)
よって、この差はb1の倍数でもb2の倍数でもあるから、その公倍数である。

ここから、最大のbでずっと刻んでいく代わりに、大きいものから順に、
次のものと合流するタイミングを見つけるたびに、その公倍数で刻み進めていくことができる。

(a1,b1),(a2,b2),.... bi < b(i+1) として、
(a1,b1)は -a1 から b1 ずつ増えたところが t1
これに対して、(a2,b2) は t1+a2 mod b2 == 0 なt1がt12となる。b12=lcm b1 b2とする。t12はb12ずつ増える
次に(a3,b3)はt12+a3 mod b3 == 0 な t12がt123となる。以下同様。
-}

comp2 abs0 = fst $ foldl' step (-a,b) abs
  where
    (a,b):abs = sortBy (\(a,b) (c,d) -> compare d b) abs0
    step (t0,b) (a1,b1) = (t1,lcm b b1)
      where
        t1 = subtract a1 $ head $ filter ((0 ==).(flip mod b1)) $ iterate (b +) (t0 + a1)

test2 = map comp2 [p2sample1,p2sample2,p2sample3,p2sample4,p2sample5,p2sample6]
test2ans = [1068781,3417,754018,779210,1261476,1202161486]

{-
混乱した頭を整理したら一瞬で答えが得られました。ふぅ。foldlの初期値の-aがポイントだったかも。

*Main> test2
[1068781,3417,754018,779210,1261476,1202161486]
*Main> test2ans
[1068781,3417,754018,779210,1261476,1202161486]
*Main> comp2 p2data
672754131923874
-}