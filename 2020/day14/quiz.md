# 14日目：入港データ #

あなたのフェリーが港に近づくと、船長は再びあなたの助けを求めます。
この港を管理するコンピュータシステムは、フェリーの入港プログラムと互換性がないため、
入港データが入港プログラムのメモリで正しく初期化されていません。

簡単な検査の結果、港のコンピュータシステムが初期化プログラムにおいて奇妙なビットマスクシステムを使用していることを見つけました。
正しいデコーダチップは手元にありませんが、ソフトウェアでエミュレートできます！

初期化プログラム（パズル入力）は、ビットマスクを更新することと、メモリに値を書き込むことができます。
値とメモリアドレスはどちらも36ビットの符号なし整数です。
たとえば、ビットマスクをひとまず無視して、`mem[8] = 11`という行は値`11`をメモリアドレス`8`に書き込みます。

ビットマスクは常に36ビットの文字列として指定され、左側に最上位ビット（2^35を表す）、
右側に最下位ビット（2^0つまり、1のビット）が書かれます。
現在のビットマスクは、値がメモリに書き込まれる直前に値に適用されます。
`0`と`1`は値の対応するビットを上書きし、`X`は値のビットを変更せずそのままにします。

たとえば、次のプログラムについて考えてみます。

~~~
mask = XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
mem[8] = 11
mem[7] = 101
mem[8] = 0
~~~

このプログラムは、ビットマスクを指定すること（`mask = ....`）から始まります。
それが指定しているマスクは、書き込まれるすべての値の2つのビットを上書きします。
2のビットは`0`で上書きされ、64のビットは`1`で上書きされます。

次に、プログラムは値`11`をメモリアドレス`8`に書き込もうとします。
すべてを個々のビットに拡張することにより、マスクは次のように適用されます。

~~~
value:  000000000000000000000000000000001011  (decimal 11)
mask:   XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
result: 000000000000000000000000000001001001  (decimal 73)
~~~

したがって、マスクがあるため、値`73`か代わりにメモリアドレス`8`に書き込まれます。
次に、プログラムは`101`をアドレス`7`に書き込もうとします。

~~~
value:  000000000000000000000000000001100101  (decimal 101)
mask:   XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
result: 000000000000000000000000000001100101  (decimal 101)
~~~

今回は、マスクが上書きしようとしたビットがすでにマスクが設定しようとした値であったため、マスクは効果がありません。
最後に、プログラムは`0`をアドレス`8`に書き込もうとします。

~~~
value:  000000000000000000000000000000000000  (decimal 0)
mask:   XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
result: 000000000000000000000000000001000000  (decimal 64)
~~~

`64`が代わりにアドレス`8`に書き込まれ、以前にあった値を上書きします。

フェリーの入港プログラムを初期化するには、初期化プログラムの完了後にメモリに残っているすべての値の合計が必要です。
（36ビットアドレス空間全体が、すべてのアドレスについて値`0`に初期化されて開始します。）
上記の例では、メモリ内の2つの値のみが零ではありません。
`101`（アドレス7）と`64`（アドレス8）は合計すると165になります。

初期化プログラムを実行します。
**完了後にメモリに残っているすべての値の合計はいくつですか？**

# パート2 #

何らかの理由で、港のコンピュータシステムはまだフェリーの入港プログラムと通信できません。
**バージョン2**のデコーダチップを使用しているに違いありません！

バージョン2のデコーダチップは、書き込まれる値をまったく変更しません。
代わりに、メモリアドレスデコーダとして機能します。
値がメモリに書き込まれる直前に、ビットマスクの各ビットは、
次の方法で書き込み先**メモリアドレス**の対応するビットを変更します。

- ビットマスクのビットが`0`の場合、メモリアドレスの対応するビットは**変更されません**。
- ビットマスクのビットが`1`の場合、メモリアドレスの対応するビットは**`1`で上書きされます**。
- ビットマスクのビットが`X`の場合、対応するメモリアドレスビットは**浮動します**。

**浮動**ビットは何にも接続されず、代わりに予測できないほど変動します。
実際には、これは浮動ビットが**すべての可能な値**を取ることを意味し、
潜在的に多くのメモリアドレスが一度に書き込まれる原因になります！

たとえば、次のプログラムについて考えてみます。

~~~
mask = 000000000000000000000000000000X1001X
mem[42] = 100
mask = 00000000000000000000000000000000X0XX
mem[26] = 1
~~~

このプログラムがメモリアドレス`42`に書き込もうとするとき、最初にビットマスクを適用します。

~~~
address: 000000000000000000000000000000101010  (decimal 42)
mask:    000000000000000000000000000000X1001X
result:  000000000000000000000000000000X1101X
~~~

マスクを適用した後、4ビットが上書きされます。そのうち3ビットは異なり、
また4ビットのうち2ビットは**浮動**です。
浮動ビットは可能なすべての値の組み合わせを取ります。
浮動ビットが2つあると、4つの実際のメモリアドレスが書き込まれます。

~~~
000000000000000000000000000000011010  (decimal 26)
000000000000000000000000000000011011  (decimal 27)
000000000000000000000000000000111010  (decimal 58)
000000000000000000000000000000111011  (decimal 59)
~~~

次に、プログラムは別のビットマスクを使用してメモリアドレス`26`に書き込もうとしています。

~~~
address: 000000000000000000000000000000011010  (decimal 26)
mask:    00000000000000000000000000000000X0XX
result:  00000000000000000000000000000001X0XX
~~~

これにより、3つの浮動ビットを持つアドレスが生成され、8つのメモリアドレスへの書き込みが発生します。

~~~
000000000000000000000000000000010000  (decimal 16)
000000000000000000000000000000010001  (decimal 17)
000000000000000000000000000000010010  (decimal 18)
000000000000000000000000000000010011  (decimal 19)
000000000000000000000000000000011000  (decimal 24)
000000000000000000000000000000011001  (decimal 25)
000000000000000000000000000000011010  (decimal 26)
000000000000000000000000000000011011  (decimal 27)
~~~

36ビットアドレス空間全体が、すべてのアドレスについて値`0`に初期化されて開始します。
そしてやはり、プログラム終了後にメモリに残っているすべての値の合計が必要です。
この例では合計は208です。

バージョン2デコーダチップ用のエミュレータを使用して初期化プログラムを実行します。
**完了後にメモリに残っているすべての値の合計はいくつですか？**
