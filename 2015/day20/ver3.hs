-- 2022-11-24

import qualified Data.Vector.Unboxed.Mutable as MUV
import Control.Monad
import Control.Monad.ST
import Data.Maybe

theInput :: Int
theInput = 36000000
theInput10 = div theInput 10

main = do
  print $ runST action1

action1 :: ST s Int
action1 = do
  v <- MUV.replicate (succ theInput10) 1
  forM_ [2..theInput10] (\i -> do
    forM_ [i, i+i..theInput10] (MUV.modify v (i +))
    )
  head . catMaybes <$> forM [1..theInput10] (\i -> do
    x <- MUV.read v i
    return $ if x >= theInput10 then Just i else Nothing)

-- コンパイルしたらサクっと答えが出たけど、ghciだとラチがあかなかった。ううむ。

{-
これはnaiveすぎるか。

part1 =
  [ i
  | i <- [1..theInput10]
  , sum (factors i) >= theInput10
  ]
-}

-- @gotoki_no_joe
factors :: Int -> [Int]
factors 1 = [1]
factors n = 1 : loop 2 [n]
  where
    loop k us
      | k2 >  n =     us
      | k2 == n = k : us
      | r  == 0 = k : next (q:us)
      | True    =     next    us
      where
        (q,r) = divMod n k
        next = loop (succ k)
        k2 = k * k

{-
> factors 831600
[1,2,3,4,5,6,7,8,9,10,11,12,14,15,16,18,20,21,22,24,25,27,28,30,33,35,36,40,42,44,45,48,50,54,55,56,60,63,66,70,72,75,77,80,84,88,90,99,100,105,108,110,112,120,126,132,135,140,144,150,154,165,168,175,176,180,189,198,200,210,216,220,225,231,240,252,264,270,275,280,297,300,308,315,330,336,350,360,378,385,396,400,420,432,440,450,462,495,504,525,528,540,550,560,594,600,616,630,660,675,693,700,720,756,770,792,825,840,880,900,924,945,990,1008,1050,1080,1100,1155,1188,1200,1232,1260,1320,1350,1386,1400,1485,1512,1540,1575,1584,1650,1680,1800,1848,1890,1925,1980,2079,2100,2160,2200,2310,2376,2475,2520,2640,2700,2772,2800,2970,3024,3080,3150,3300,3465,3600,3696,3780,3850,3960,4158,4200,4400,4620,4725,4752,4950,5040,5400,5544,5775,5940,6160,6300,6600,6930,7425,7560,7700,7920,8316,8400,9240,9450,9900,10395,10800,11088,11550,11880,12600,13200,13860,14850,15120,15400,16632,17325,18480,18900,19800,20790,23100,23760,25200,27720,29700,30800,33264,34650,37800,39600,41580,46200,51975,55440,59400,69300,75600,83160,92400,103950,118800,138600,166320,207900,277200,415800,831600]
ということで、素数やその倍数を回避して、lcmが法外に大きくならないように留意しながら和を大きくしていくといいらしい。
i=1から始めて、それを使う/使わないで2倍に場合が増えて、
使うとき、lcmがiもlcmした結果に、合計はiを加えた結果になって、目標達成する最小のモードを見つけたらいい。
とは思うけど、上のやり方が最も速いのは疑う余地がないのでここまでにしておく。
-}
