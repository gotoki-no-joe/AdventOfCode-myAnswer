# Day 18: RAM脱走

あなたと歴史学者たちは、前はこんなにドット絵ではなかった気がします。
あなたは北極の[コンピュータの中](../2017/day2.md)にいます！

ちょうど周囲を確認しようとしたとき、プログラムがあなたのところに駆け寄ってきます。
「このメモリ領域は安全ではありません！
ユーザーはプッシュダウンオートマトンが何であるかを誤解していて、
彼らのアルゴリズムが私たちの上にバイト全体を押し込んでいます！逃げて！」

アルゴリズムは高速です ー
あなたのメモリ空間に[ナノ秒](https://www.youtube.com/watch?v=9eyFDBPk4Yw)ごとにバイトが落ちてくることになります！
幸いなことにあなたの方が**速く**、アルゴリズムを素早くスキャンすることで、
**どのバイトが落ちるかのリスト**（あなたのパズル入力）をメモリ空間に落ちる順序で作成しました。

あなたのメモリ空間は、水平と垂直の両方で0から70の範囲の座標を持つ2次元グリッドです。
ただし、例のために、0から6の範囲の座標を持つ小さなグリッドにいて、
次のバイト位置のリストがあると仮定します：

```
5,4
4,2
4,5
3,0
2,1
6,3
2,4
1,5
0,6
3,3
2,6
5,1
1,2
5,5
2,5
6,5
1,4
0,4
6,4
1,1
6,1
1,0
0,5
1,6
2,0
```

各バイト位置は `X,Y` 座標として与えられ、`X` はメモリ空間の左端からの距離、`Y` はメモリ空間の上端からの距離です。

あなたと歴史学者たちは現在、メモリ空間の左上隅 (`0,0`) にいて、
右下隅の出口（あなたのメモリ空間で `70,70`、ただしこの例では `6,6`）に到達する必要があります。
まず、バイトが落ちる様子をシミュレーションして、安全に走ることができる場所を計画する必要があります。
とりあえず今は、メモリ空間に落ちる最初の数バイトだけをシミュレーションします。

バイトがあなたのメモリ空間に落ちると、その座標が**破損**します。
破損したメモリ座標には、あなたや歴史学者たちが入ることはできないので、経路を慎重に計画する必要があります。
また、メモリ空間の境界を越えることもできません。
あなたの唯一の望みは出口に到達することです。

上記の例で、最初の12バイトが落とされた後のメモリ空間を描くと
（`.` を安全、`#` を破損として使って）、次のようになります：
（訳註：リスト全体ではなく最初の12要素であることに注意）

```
...#...
..#..#.
....#..
...#..#
..#..#.
.#..#..
#.#....
```

あなたは上下左右にステップ移動できます。
メモリ空間内の12バイトが破損した後、左上隅から出口までの最短経路は22ステップかかります。
そのような経路の一つを `O` でマークした地図を示します：

```
OO.#OOO
.O#OO#O
.OOO#OO
...#OO#
..#OO#.
.#.O#..
#.#OOOO
```

最初の1キロバイト（1024バイト）がメモリ空間に落ちるのをシミュレートします。
その後、出口に到達するために必要な最小ステップ数はいくつですか？

# パート2

歴史学者たちは、このピクセル化された世界をあなたのように動き回ることに慣れていません。
あなたは、彼らが出口に辿り着く前に道が完全に塞がれてしまうのではないかと心配しています。

全員がどれだけ速く進む必要があるかを判断するために、**出口への道を塞ぐ最初のバイト**を特定する必要があります。

上記の例では、`1,1` のバイトが落ちた後でも出口への道はまだあります：

```
O..#OOO
O##OO#O
O#OO#OO
OOO#OO#
###OO##
.##O###
#.#OOOO
```

しかし、次のバイト (`6,1`) を追加すると、出口への道がなくなります：

```
...#...
.##..##
.#..#..
...#..#
###..##
.##.###
#.#....
```

よってこの例では、出口に到達できなくなる最初のバイトの座標は `6,1` です。

メモリ空間を破損させるバイト群をさらにシミュレーションしてください。
あなたの開始位置から出口に到達できなくなる最初のバイトの座標は何ですか？
（答えは、他の文字を使わずにカンマで区切った2つの整数として示してください。）
（訳註：つまり `input.txt` にある形式のままで）
