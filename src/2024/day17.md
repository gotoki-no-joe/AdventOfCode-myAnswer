# 第17日: 時空間コンピュータ

歴史学者たちが彼らの奇妙な装置のボタンを押しますが、
今回はただ皆が[落下している](../2018/day6.md)ように感じます。

「危機的な状況」と装置が馴染みのある声で通知します。
「ブートストラップ処理に失敗。デバッガを初期化中…」

小さなハンドヘルド装置は突然、コンピュータ一式へと展開しました！
歴史学者たちは緊張した様子で周りを見回し、そのうちの一人がそれをあなたに投げてよこします。

これは3ビットコンピュータのようです：
そのプログラムは3ビットの数（0から7）で構成されたリストで、例えば `0,1,2,3` のようになっています。
コンピュータには A, B, C という名前の3つの**レジスタ**もありますが、
これらのレジスタは3ビットに制限されず、任意の整数を保持できます。

コンピュータは**8つの命令**を知っており、
それぞれは3ビット数（命令の**オペコード**と呼ばれる）で識別されます。
各命令はその後に続く3ビットの数を入力として読み取ります。これを**オペランド**と呼びます。

**命令ポインタ**と呼ばれる数は、次のオペコードが読み取られるプログラム内の位置を特定します。
これは0から始まり、それはプログラム内の最初の3ビットの数を指します。
ジャンプ命令を除いて、命令ポインタは各命令が処理されるごとに2増加します
（命令のオペコードとそのオペランドを越えて次に進むため）。
コンピュータがプログラムの終わりを超えてオペコードを読み取ろうとすると、その代わりに**停止**します。

よって、プログラム `0,1,2,3` はオペコードが0の命令を実行し、それにオペランド1を渡し、
その後オペコードが2の命令を実行してそれにオペランド3を渡し、最後に停止します。

オペランドには2種類あり、それぞれの命令はそのオペランドの種類を指定します。
**即値オペランド**の値はそのオペランド自体です。
たとえば、即値オペランド7の値は数7です。
**コンボオペランド**の値は次のようにして見つけることができます：

- コンボオペランド0から3は即値0から3を表します。
- コンボオペランド4はレジスタAの値を意味します。
- コンボオペランド5はレジスタBの値を意味します。
- コンボオペランド6はレジスタCの値を意味します。
- コンボオペランド7は予約されており、正しいプログラムには現れません。

8つの命令は以下の通りです：

`adv` 命令（オペコード0）は**除算**を行います。
被除数はAレジスタの値です。除数は命令の**コンボ**オペランドの指す値の2のべき乗で求められます。
（つまり、オペランドが2の場合はAを4 $(2^2)$ で割り、オペランドが5の場合はAを $2^B$ で割ります。）
除算操作の結果は整数に**切り捨て**られ、Aレジスタに書き込まれます。

`bxl` 命令（オペコード1）は、
レジスタBと命令の**即値**オペランドの**ビット単位のXOR**を計算し、結果をレジスタBに格納します。

`bst` 命令（オペコード2）は、
**コンボ**オペランドの値を8で割った余りを計算し（つまり最下位3ビットのみを保持します）、
その値をBレジスタに書き込みます。

`jnz` 命令（オペコード3）は、Aレジスタが0の場合何もしません。
しかし、Aレジスタが**零でない**場合、**即値**オペランドの値を命令ポインタに設定することで**ジャンプ**します。
この命令がジャンプすると、命令ポインタはこの命令の後に2増加**しません**。

`bxc` 命令（オペコード4）は、レジスタBとレジスタCの**ビット単位のXOR**を計算し、結果をレジスタBに格納します。
（後方互換性のため、この命令はオペランドを読み取りますが、それを**無視**します。）

`out` 命令（オペコード5）は、**コンボ**オペランドの値を8で割った余りを計算し、その値を**出力**します。
（プログラムが複数の値を出力する場合、それらはカンマで区切られます。）

`bdv` 命令（オペコード6）は、`adv` 命令とまったく同じように機能しますが、結果は**Bレジスタ**に格納されます。
（被除数はAレジスタから読み取られます。）

`cdv` 命令（オペコード7）は、結果が**Cレジスタ**に格納されることを除いて、`adv`命令とまったく同じように動作します。
（被除数はAレジスタから読み取られます。）

命令の動作例をいくつか示します:

- レジスタCに9が入っている場合、プログラム 2,6 はレジスタBを1に設定します。
- レジスタAに10が入っている場合、プログラム 5,0,5,1,5,4 は 0,1,2 を出力します。
- レジスタAに2024が入っている場合、プログラム 0,1,5,4,3,0 は 4,2,5,6,7,7,7,7,3,1,0 を出力し、レジスタAには0が残ります。
- レジスタBに29が入っている場合、プログラム 1,7 はレジスタBを26に設定します。
- レジスタBに2024が、レジスタCに43690が含まれている場合、プログラム 4,0 はレジスタBを 44354 に設定します。

歴史学者たちの奇妙な装置がデバッガの初期化を終了し、
**実行しようとしているプログラム**（あなたのパズル入力）**に関する情報**を表示しています。
例えば:

```
Register A: 729
Register B: 0
Register C: 0

Program: 0,1,5,4,3,0
```

あなたの最初のタスクは、**プログラムが何を出力しようとしているのかを特定する**ことです。
これを行うには、レジスタを指定された値に初期化し、その後、与えられたプログラムを実行して、
出力命令によって生成された出力を収集します。
（出力命令によって生成された値は常にコンマで結合してください。）
上のプログラムが停止した後、その最終出力は 4,6,3,5,6,3,5,2,1,0 になります。

デバッガが提供する情報を使用して、レジスタを指定された値に初期化し、プログラムを実行します。
停止したら、出力された値をカンマで結合して一つの文字列にするとどうなりますか？

# パート2

デバイスのマニュアルをさらに掘り下げると、問題を見つけました。
このプログラムは**そのプログラムの別のコピーを出力する**ことになっています！
残念ながら、レジスターAの値が破損しているようです。
プログラムの出力命令がプログラム自体の正確なコピーを生成するように、
レジスタAを初期設定する新しい値を見つける必要があります。

例えば：

```
Register A: 2024
Register B: 0
Register C: 0

Program: 0,3,5,4,3,0
```

このプログラムは、レジスタAが117440に初期化されている場合に、自身のコピーを出力します。
（レジスタAの元の初期値である2024は無視されます。）

プログラムが自身のコピーを出力するような、レジスタAの最も小さい正の初期値は何ですか？
