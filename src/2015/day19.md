# 19日目：ルドルフのための薬

赤鼻のトナカイのルドルフは病気です！
彼の鼻はあまり明るく輝いていません、
そして彼は薬を必要としています。

赤鼻のトナカイ生物学は通常のトナカイ生物学と似ていません。
ルドルフは特製の薬を必要とするでしょう。
残念なことに、赤鼻のトナカイ化学も通常のトナカイ化学と似ていません。

北極には赤鼻のトナカイ核融合・核分裂プラントが装備されており、
必要なあらゆる赤鼻のトナカイ分子を構築することができます。
それはいくつかの入力分子から始めて、
それからそれが正しい分子を持つまでステップごとに1つの、
一連の**置換**をすることによって働きます。

ただし、この装置は使用する前に校正する必要があります。
校正は、与えられた出発点から1ステップで生成され得る分子の数を決定することで行います。

たとえば、以下の置換のみに対応した、ずっと単純な装置を想像してみてください。

~~~
H => HO
H => OH
O => HH
~~~

上記の置換が与えられ、`HOH`から始めると、
次のような分子が生成される可能性があります。

- `HOOH` （1番目の`H`に`H => HO`）
- `HOHO` （2番目の`H`に`H => HO`）
- `OHOH` （1番目の`H`に`H => OH`）
- `HOOH` （2番目の`H`に`H => OH`）
- `HHHH` （`O => HH`）

よって、上記の例では、`HOH`からの1回の置換の後に、
**4種類**の異なる分子があります。
（`HOOH`が2回出現するため5種類ではありません。）
サンタのお気に入りの分子`HOHOHO`は、
（`H`から6つ、`O`から3つの9個の置換を経て）
**7種類**の分子になることができます。

装置は周囲の文字を無視して置換します。
たとえば、文字列`H2O`が与えられると、遷移`H => OO`により`OO2O`となります。

あなたのパズル入力はすべての可能な置換について説明しています。
そして最下部に、あなたが装置を校正するのに必要な薬品分子があります。
薬品分子に1つの置換を行うことができるすべてのさまざまな方法の後に、
**何種類の異なる分子を作成することができますか？**

<details><summary>解説</summary><div>

原子記号は大文字1文字または大文字1文字+小文字1文字でひとつなので、原子記号一つをひとつの整数で扱うように読み込む。

```haskell
import Data.Char

encode :: String -> [Int]
encode (c1:c2:cs) | isLower c2 = ord c1 * 256 + ord c2 : encode cs
encode (c:cs) = ord c1 : encode cs
encode "" = []

parse :: String -> (Int,[Int])
parse xs = (head $ parse w1, parse w3)
  where
    [w1,_,w3] = words xs
```

初期列に対して可能な置き換えを行った全ての結果を作る。
規則の左辺は重複があるので注意。

```haskell
part1 rules molec0 = S.size s
  where
    rs = IM.fromListWith (++) [(l,[r]) | (l,r) <- rules]
    (_, s) = foldr step ([], S.empty) molec0

    step elem (elems, s) = (elem:elems, S.union s1 $ S.map (elem :) s)
      where
        s1 = S.fromList [es ++ elems | es <- IM.findWithDefault [] elem rs]
```

</div></details>

# パート2

これで装置は校正されたので、分子製造を始める準備が整いました。

分子製造は、常に単一の電子だけから始まります。
そして校正のときと同様に、一度にひとつの置換を適用します。

たとえば、次のような置換があるとします。

~~~
e => H
e => O
H => HO
H => OH
O => HH
~~~

`HOH`を作成したいならば、`e`から始め、次のように置換します。

- `e => O` これは`O`を得るため
- `O => HH` これは`HH`を得るため
- `H => OHH` （2番目の`H`に）これで`HOH`を得る

よって、**3ステップ**で`HOH`を作ることができます。
サンタの好きな分子`HOHOHO`は**6ステップ**で作ることができます。

薬を作るのにどれくらいかかりますか？
あなたのパズル入力にある
利用可能な**置換**と**薬の分子**を考えるとき、
`e`から薬の分子に行くための**最小のステップ数**はいくつですか？

<details><summary>解説</summary><div>

前向きな計算はどう考えても発散するので、目標から還元して電子1つに戻す。
また、規則は優しく作られていて、端から貪欲に書き換えを行えばよいと仮定して試す。
（もしこれがうまくいかないと、書き換えできる位置を見逃す形で深さ優先探索するコードが必要になる。）

規則の右辺の先頭文字をキーにして規則を分類しておく。

```haskell
rulesM = IM.fromListWith (++) [(head r, [lr]) | lr@(_,r) <- rules]
```

右畳み込みで、新たに繋がる文字をキーにして規則表を調べ、その中で実際に適合する規則を逆向きに適用した結果の一覧を作る。
変換を一度行ったら、それ以降は規則を調べず、残りの文字の連結につとめる。

```haskell
-- m は新たな文字、msはその続きのこれまでの文字列
ms1 = m : ms
reps =
  [ l : drop (length r) ms1
  | (l,r) <- IM.findWithDefault [] m rulesM
  , isPrefixOf r ms1
  ]
```

`reps`が要素1ならその書き換えを実行、空リストなら書き換えずに次の文字へ、要素が複数あるなら失敗で落とす。
また、一度書き換えを行ったら、それを覚えるフラグによって、以降は書き換えをしないで抜ける。

```haskell
-- molec が書き換え対象の列全体
(molec1, acted) = foldr step ([], False) molec
step m (ms, True) = (m:ms, True)
step m (ms, False)
  | null reps      = (m:ms, False)
  | singleton reps = (head reps, True)
  | otherwise      = error (show reps)
  where
    ms1 = ...
    reps = ...
```

書き換えが起きたなら繰り返し、さもなくば終了する。

```haskell
loop cnt molec
  | acted = print (length molec1) >> loop (succ cnt) molec1
  | otherwise  = print ("end", molec, cnt) >> return ()
  where
    ...
```

幸い、これで電子までさかのぼることができた。

</div></details>
