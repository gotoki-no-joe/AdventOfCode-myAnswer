# 24日目：バランスしてぶら下がっている

クリスマスイブです、そしてサンタは今年の配達のためにそりに積み込んで​​います。
しかし、1つ小さな問題があります。
彼はそりのバランスをとることができません。
バランスが取れていなければ、彼は物理学に逆らうことはできず、
そして今年誰もプレゼントをもらうことができません。

無理をしないで。

サンタはそりにうまく詰め込む必要のあるすべての包みの重量のリストをあなたに提供しました。
包みは、**まったく同じ重さの3つのグループ**に分割する必要があり、
すべての包みを収める必要があります。
最初のグループはそりの客室に行き、
2番目と3番目のグループは左右のコンテナに入ります。
3つのグループすべてがまったく同じ重さになったときにのみ、そりは飛ぶことができます。
物理学に反することには規則があります、わかりますね！

もちろん、それだけが問題ではありません。
最初のグループ、つまり客室内に移動するグループは、
サンタの足元に余裕を持たせるために、
**包みの数をできるだけ少なく**する必要があります。
すべてのグループの重量が同じであれば、
他の2つのグループにはいくつ包みが含まれていてもかまいません。

さらに、サンタは、
可能な限り少ないものが最初のグループになるように包みを配置する方法が複数ある場合、
最初のグループが最小の**量子もつれ** (Quantum Entanglement)を持つ方法を選択して、
「複雑化」(complication, 合併症？) の可能性を減らすようにする必要があります。
包みのグループの量子もつれは、それらの重みの積、つまり、それらの重みを掛け合わせたときに得られる値です。
すべてのグループの重量が同じでかつ
最初のグループに含まれる可能性のある包みの数が最も少ない場合にのみ、量子もつれを考慮してください。

たとえば、1から5と7から11の重みを持つ10の包みがあるとします。
この状況に関して、
いくつかの一意な最初のグループ、その量子もつれ、
そして残りの包みを分割する方法は以下の通りです。

~~~
Group 1;             Group 2; Group 3
11 9       (QE= 99); 10 8 2;  7 5 4 3 1
10 9 1     (QE= 90); 11 7 2;  8 5 4 3
10 8 2     (QE=160); 11 9;    7 5 4 3 1
10 7 3     (QE=210); 11 9;    8 5 4 2 1
10 5 4 1   (QE=200); 11 9;    8 7 3 2
10 5 3 2   (QE=300); 11 9;    8 7 4 1
10 4 3 2 1 (QE=240); 11 9;    8 7 5
9 8 3      (QE=216); 11 7 2;  10 5 4 1
9 7 4      (QE=252); 11 8 1;  10 5 3 2
9 5 4 2    (QE=360); 11 8 1;  10 7 3
8 7 5      (QE=280); 11 9;    10 4 3 2 1
8 5 4 3    (QE=480); 11 9;    10 7 2 1
7 5 4 3 1  (QE=420); 11 9;    10 8 2
~~~

これらのうち、`10 9 1`が最も小さい量子もつれ（90）を持っていますが、
2つの包みだけからなる構成`11 9`が、
客室内にあるときサンタに最も大きな足元の余裕を与えて勝ちます。
この状況では、理想的な配置に対する量子もつれは99です。
最初のグループに包みが2つしかない構成が2つあった場合は、
より小さな量子もつれを持つ構成が選択されます。

理想的な構成における包みの最初のグループの**量子もつれ**はいくつですか？

<details><summary>解説</summary><div>

入力の行数から、包みの個数はほどほどで、部分集合をビット表現するのに整数で足りる。
包みの部分集合について、その合計重量をキー、部分集合のビット表現のリストを値とするマップを、
「0個の取り合わせは0」から始めて、荷物をひとつずつ追加することで、全ての組み合わせの合計重量を求める。
ただし、総重量の1/3を超えるものは不要なので作らないようにする。
このマップの、総重量の1/3になる選択群から、条件を満たすものを選択する。

```haskell
import qualified Data.IntMap as IM
import Data.List

compute1 xs = ...
  where
    w3 = div (sum xs) 3
    im = foldl' step (IM.singleton 0 [0]) $ zip xs [0..]
    step im (x, i) = IM.unionWith (++) im $ IM.fromAscList $
      [(w1, map (bit i .|.) bs) | (w,bs) <- IM.assocs im, let w1 = w + x, w1 <= w3]
    bs = im IM.! w3 :: [Int]
```

見つかった組み合わせを、その要素数順、次に量子もつれの順で整列する。
これを小さい方から試して、3つの組み合わせで、互いに重なりないようなものが、探したいものである。

```haskell
compute1 xs = ans
  where
    ...
    cands = sort [(popCount b, qe, b) | b <- bs, let qe = product [x | (i,x) <- zip [0..pred num] xs, testBit b i]]
    ans = head
      [ qe
      | (_,qe,b1):cands1 <- tails cands
      , (_,_ ,b2):cands2 <- tails cands1, b1  .&. b2 == 0, let b12 = b1 .|. b2
      , (_,_ ,b3)        <-       cands2, b12 .&. b3 == 0
      ]

main = readFile "input.txt" >>= print . compute1 . map read . lines
```

</div></details>

# パート2

何か変です…そりはまだバランスが取れていません。

「ホーホーホー」サンタは自分自身に夢中になります。「トランクを忘れた。」

再びそりのバランスを取りますが、今回は、包みを3つではなく4つのグループに分けます。
他の制約は依然として適用されます。

上記の包みの例を考えたときの、いくつかの新しい一意な最初のグループ、
それらの量子もつれ、そして残りの包みを分割する方法の一つを示します。

~~~
11 4    (QE=44); 10 5;   9 3 2 1; 8 7
10 5    (QE=50); 11 4;   9 3 2 1; 8 7
9 5 1   (QE=45); 11 4;   10 3 2;  8 7
9 4 2   (QE=72); 11 3 1; 10 5;    8 7
9 3 2 1 (QE=54); 11 4;   10 5;    8 7
8 7     (QE=56); 11 4;   10 5;    9 3 2 1
~~~

このうち、そこに最初のグループに包みの最小の個数（2）を置く構成が3つあります。
`11 4`, `10 5`, `8 7`です。
これらの中で、`11 4`が量子もつれが最小なので、それが選択されます。

さて、理想的な構成における包みの最初のグループの**量子もつれ**はいくつですか？

<details><summary>解説</summary><div>

分割が4になるだけで、やることは変わらない。

```haskell
compute2 xs = ans
  where
    w4 = div (sum xs) 4
    im = ...
    step im (x, i) = ...
    bs = im IM.! w4 :: [Int]
    cands = ...
    ans = head
      [ qe
      | (_,qe,b1):cands1 <- tails cands
      , (_,_ ,b2):cands2 <- tails cands1, b1   .&. b2 == 0, let b12  = b1  .|. b2
      , (_,_ ,b3):cands3 <- tails cands2, b12  .&. b3 == 0, let b123 = b12 .|. b3
      , (_,_ ,b4)        <-       cands3, b123 .&. b4 == 0
      ]
```

</div></details>
