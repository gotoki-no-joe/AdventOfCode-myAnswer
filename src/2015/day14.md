# 14日目：トナカイオリンピック

今年はトナカイオリンピックです！
トナカイは高速で飛ぶことができますが、
エネルギーを回復するために時々休まなければなりません。
サンタは、彼のトナカイのどれが最速かを知りたいので、
彼はレースをさせます。(have one race?)

トナカイは**飛行状態**（常に最高速度）
または**休息**（全く動かない）のいずれかで、
すべての時間でいずれかの状態にあります。

たとえば、次のようなトナカイがあるとします。

- Cometは**14km/sで10秒間**飛行できますが、その後**127秒間**休む必要があります。
- Dancerは**16km/sで11秒間**飛行できますが、その後は**162秒間**休む必要があります。

1秒後、Cometは14km、Dancerは16km進みました。
10秒後、Cometは140km、Dancerは160km進みました。
11秒目に、Cometは休息を開始し（140kmに留まる）、Dancerは飛び続けて176kmまで進みます。
12秒目には、両方のトナカイが休息しています。
Comentがさらに10秒間飛ぼうとするまでの138秒目まで、
彼らは休み続けます。
174秒目に、Dancerは次の11秒間の飛行を開始します。

この例では、1000秒後に両方のトナカイが休息しており、
Cometが**1120km**で先行しています。
（この時点ではかわいそうなDancerは**1056km**しか進めていません。）
したがって、この状況ではComentが勝ちます（レースが1000秒で終了した場合）。

（あなたのパズル入力として）各トナカイの説明が与えられています。
ちょうど2503秒後に、**優勝したトナカイはどれだけの距離を移動しましたか？**

<details><summary>解説</summary><div>

また読み込みから。

```haskell
parse :: String -> (Int,Int,Int)
parse xs = (read $ ws !! 3, read $ ws !! 6, read $ ws !! 13)
  where
    ws = words xs
```

(速度 \\(s\\)、飛行時間 \\(t\\)、休憩時間 \\(u\\)) というトナカイが \\(D\\) 秒飛ぶとき、
全体のサイクルを回せる回数 \\(q\\) と、最後のサイクルをさらにする秒数 \\(r\\) は
\\((q,r) = \textrm{divMod}(D, t+u)\\) である。
このとき飛行した時間の総計は \\(q \\, t + \min(t, r)\\)となる。

```haskell
main1 = do
  co <- readFile "input.txt"
  print $ part1 2503 $ lines co

part1 time ls = maximum
  [ s * (q * t + min t r) | (s,t,u) <- map parse ls, let (q,r) = divMod time (t + u)]
```

</div></details>

# パート2

トナカイが爆発的に動くのを見て、
サンタは自分が古い評価体系に満足していないと判断します。

代わりに、各秒の終わりに、
彼は現在首位であるトナカイに1点を与えます。
（同点一位のトナカイが複数いる場合は、全員がれぞれ1点を得ます。）
彼はもちろん、伝統的な2503秒の制限時間を守りました。
そうしないのは完全にばかげているからです。

上の例のトナカイを考えると、
最初の1秒後、Dancerが先行して1点を獲得します。
彼はComentの2回目の爆発までの数秒の間は先行しつづけます。
140秒後、Cometが先頭に立ち、最初の得点を獲得します。
もちろん、Dancerはそれまでの139秒間は先行していたので、
140秒めまでに139点を貯めています。

1000秒後、Dancerは**689**点を貯めていましたが、
以前の勝者であるかわいそうなCometは312点しか持っていません。
したがって、新しい評価体系ではDancerが勝利します（レースが1000秒で終了した場合）。

今回も（あなたのパズル入力の中の）各トナカイの説明が与えられたとき、
ちょうど2503秒後に、**優勝したトナカイはどれだけの点を獲得しましたか？**

<details><summary>解説</summary><div>

それぞれのトナカイについて、次の1秒で進む距離（または0）のリストを作り、
これを累積することで各時刻の位置を作り、一位を選んで点数を付与する、を繰り返す。

```haskell
import Data.List

main2 = do
  co <- readFile "input.txt"
  print $ part2 2503 $ lines co

part2 time ls =
  maximum $ foldl1 (zipWith (+)) $
  map score2max $ take time $ transpose $
  [ scanl1 (+) $ cycle $ replicate t s ++ replicate u 0
  | (s,t,u) <- map parse ls ]

score2max xs = [if m == x then 1 else 0 | x <- xs]
  where
    m = maximum xs
```

</div></details>
