# 3日目：真空中の完全球形住宅

サンタは無限の2次元グリッド住宅街にプレゼントを届けています。

彼は出発地にある家にプレゼントを配達することから始めます。
北極にいる小人が無線で彼に連絡し、次にどこへ行くべきかを彼に伝えます。
移動は常にちょうど1軒隣の
北（`^`）、南（`v`）、東（`>`）、西（`<`）の家です。
それぞれの移動の後、彼は彼の新しい位置の家に次のプレゼントを届けます。

しかし、北極にいる小人は卵酒を少し飲み過ぎてしまったために指示が少しずれて、
その結果サンタがいくつかの家を複数回訪れてしまいました。
**少なくとも1つ**プレゼントを受けとる家は何軒ありますか？

例えば：

- `>` は2軒にプレゼントを届けます。
出発地に1つ、東に1つ。
- `^>v<` は四角く並んだ4軒にプレゼントを届けます。
彼の出発かつ終了地点の家には2度訪れます。
- `^v^v^v^v^v` は2軒の家だけにいる
非常に幸運な子どもたちにたくさんのプレゼントを届けます。

<details><summary>解説</summary><div>

座標がどちらに広がるのか事前に予測できないので、配列で扱うのは難しい。
座標の集合で扱うと制約なく扱いやすい。

```haskell
import qualified Data.Set as S

part1 :: String  -- 指示
      -> Int     -- 答え
part1 = S.size . S.fromList . scanl step (0,0)

step (x,y) '^' = (pred x, y)
step (x,y) 'v' = (succ x, y)
step (x,y) '<' = (x, pred y)
step (x,y) '>' = (x, succ y)
```

</div></details>

# パート2

翌年、処理を高速化するために、
サンタは自分自身のロボット版である**メカサンタ**を作成しました。
彼と一緒にプレゼントを届けるためのものです。

サンタとメカサンタは同じ場所から出発し
（同じ出発地点の家に2つのプレゼントを配達する）、
卵酒を飲み過ぎたせいで去年と同じ行動計画を読み上げる小人の指示に基づいて**交互に**移動します。

今年は、何軒の家が**少なくとも1つ**のプレゼントを受け取りますか？

例えば：

- `^v` は3軒にプレゼントを届けます。
サンタは北に行き、その後メカサンタが南に行くからです。
- `^>v<` は今回3軒にプレゼントを配達し、
サンタとメカサンタは彼らが始めた地点に戻ってきます。
- `^v^v^v^v^v` は今回11軒の家にプレゼントを届けます。
サンタは一方向に、メカサンタはそれと反対向きに向かって行きます。

<details><summary>解説</summary><div>

入力を、サンタ用とメカサンタ用に分離した後はパート1と同じやり方で座標を得て、
合わせてから数えればよい。

```haskell
part2 :: String  -- 指示
      -> Int     -- 答え
part2 cs = S.size . S.fromList $ go cs1 ++ go cs2
  where
    cbs = zip cs $ cycle [True, False]
    cs1 = [c | (c, True ) <- cbs]
    cs2 = [c | (c, False) <- cbs]
    go = scanl step (0,0)
```

</div></details>
