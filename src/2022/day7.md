# 7 日目: デバイスに空き容量がありません

遠征が進むにつれて、鳥のさえずりや雨滴が葉に当たる音が聞こえます。
時折、遠くでもっと大きな音が聞こえることさえあります。
どれくらい大きな動物が現れるのでしょう？

小人があなたにくれた装置には、通信システム以外にも問題があります。
システムアップデートを実行しようとすると、次のようになります。

```
$ system-update --please --pretty-please-with-sugar-on-top
Error: No space left on device
```

おそらく、いくつかのファイルを削除することで、
アップデートのための空き容量を確保できるでしょう。

ファイルシステムをあちこち調べて状況を評価し、
結果の端末出力 (パズルの入力) を保存します。
それは例えば次のようなものです：

```
$ cd /
$ ls
dir a
14848514 b.txt
8504156 c.dat
dir d
$ cd a
$ ls
dir e
29116 f
2557 g
62596 h.lst
$ cd e
$ ls
584 i
$ cd ..
$ cd ..
$ cd d
$ ls
4060174 j
8033020 d.log
5626152 d.ext
7214296 k
```


ファイルシステムは、ファイル（単なるデータ）とディレクトリ（他のディレクトリやファイルを含むことができる）の木で構成されます。
一番外側のディレクトリは `/` と呼ばれます。
ファイルシステムをナビゲートし、ディレクトリを出入りして、現在いるディレクトリの内容を一覧表示できます。

端末出力内で、 `$` で始まる行は**実行したコマンド**です。
これは最近のコンピュータと非常によく似ています。

- `cd` は**ディレクトリの変更**を意味します。
これは現在のディレクトリを変更しますが、具体的な結果は引数によって異なります。
  - `cd x` 1レベル**中に入り**ます。
現在のディレクトリで `x` という名前のディレクトリを探し、それを現在のディレクトリにします。
  - `cd ..` 1レベル**外に出**ます。
現在のディレクトリを含むディレクトリを見つけ、そのディレクトリを現在のディレクトリにします。
  - `cd /` 現在のディレクトリを最も外側のディレクトリに切り替えます。
- `ls` **リスト**を意味します。現在のディレクトリに直接含まれる全てのファイルとディレクトリを出力します。
  - `123 abc` は、現在のディレクトリに `abc` という名前で大きさ `123` のファイルが含まれていることを意味します。
  - `dir xyz` は、現在のディレクトリに `xyz` という名前のディレクトリが含まれていることを意味します。

上記の例のコマンドと出力から、ファイルシステムが視覚的に次のようになっていることがわかります。

```
- / (dir)
  - a (dir)
    - e (dir)
      - i (file, size=584)
    - f (file, size=29116)
    - g (file, size=2557)
    - h.lst (file, size=62596)
  - b.txt (file, size=14848514)
  - c.dat (file, size=8504156)
  - d (dir)
    - j (file, size=4060174)
    - d.log (file, size=8033020)
    - d.ext (file, size=5626152)
    - k (file, size=7214296)
```

ここには4つのディレクトリがあります。
`/` （最外のディレクトリ）、`a` と `d` (`/`にある) と `e`(`a` にある) です。
これらのディレクトリには、さまざまな大きさのファイルも含まれています。

ディスクがいっぱいなので、あなたの最初の一手はきっと、
削除するのに適したディレクトリを見つけることです。
これを行うには、各ディレクトリの**合計サイズ**を求める必要があります。
ディレクトリの合計サイズは、直接的または間接的に含まれるファイルのサイズの合計です。
（ディレクトリ自体は、固有のサイズを持っているとは見なしません。）

上記のディレクトリの合計サイズは次のようになります。

- ディレクトリ `e` の合計サイズは**584**です。
というのは、それがサイズ584のファイル`i`だけを持っており、他のディレクトリがないためです。
- ディレクトリ `a` には、ファイル`f`(サイズ29116)、`g`(サイズ2557)、`h.lst`(サイズ 62596)が含まれており、
さらにファイル`i`を間接的に持つ（`j`を持つ`e`を`a`は含む）ため、合計サイズは**94853**です。
- ディレクトリ `d` の合計サイズは24933642です。
- 最も外側のディレクトリである `/` には全てのファイルが含まれます。
その合計サイズは48381165で、これは全てのファイルのサイズの合計です。

まず、合計サイズが**100000以下**のディレクトリをすべて見つけてから、
それらの合計サイズの合計を計算します。
上記の例では、そのようなディレクトリは `a` と `e` です。
それらの合計サイズの合計は **95437** (94853 + 584) です。
（この例のように、この手順はファイルを複数回勘定します！）

合計サイズが100000以下の全てのディレクトリを見つけます。
**これらのディレクトリの合計サイズの合計はいくつですか？**

<!--
<details><summary>解説</summary><div>

`cd`コマンドはカレントディレクトリを変更する。
`ls`コマンドの結果は、カレントディレクトリにあるファイルの容量リストが続くことを意味する。
存在しないディレクトリに`cd`することはないと仮定する。（エラーメッセージの形式が説明されていないため。）
同じディレクトリで複数回`ls`する可能性は気に掛けておく。

ディレクトリごとにそこに含まれるファイルの容量の合計が知りたいが、
ディレクトリが入れ子になっていることも配慮しないといけない。
そこで、ディレクトリやファイルの完全パス名を名前のの文字列の（逆順の）リストで表現し、
完全パス名にそのファイルの容量を対応付けたペアのリストから、そのマップを作ることで重複を払拭する。

カレントディレクトリという状態を持ちまわすため、`mapAccumL`を用いる。
ファイル容量を報告しない行もあるので、出力は`Maybe`で包む。

```haskell
import qualified Data.Map as M
import Data.List
import Data.Maybe

parseFile :: [String] -> M.Map [String] Int
parseFile = M.fromList . catMaybes . snd . mapAccumL step []
  where
    step :: [String] -> String -> ([String], Maybe ([String], Int))
    step dir l =
      case words l of
        ["$", "cd", ".."] -> (tail dir, Nothing)
        ["$", "cd", "/"] -> ([], Nothing)
        ["$", "cd", d] -> (d:dir, Nothing)
        ["$", "ls"] -> (dir, Nothing)
        ["dir", _] -> (dir, Nothing)
        [n, fn] -> (dir, Just (fn:dir, read n))
        _ -> error $ "unexpected" ++ l
```

このマップの対応リストを取り出し、キーの`tails . tail`について容量をばらまいて足し合わせると、
全てのディレクトリについて、それが直接的または間接的に含むファイル容量のマップが作れる。

```haskell
accumlate :: M.Map [String] Int -> M.Map [String] Int
accumlate m = M.fromListWith (+)
  [(p, sz) | (path, sz) <- M.assocs m, p <- tails (tail path)]
```

ここから100000以下の容量を抜き出し、合計する。

```haskell
main1 = body1 "input.txt"

body1 fn = readFile fn >>= print . sum . filter (100000 >=) . M.elems . accumlate . parseFile . lines
```

</div></details>
-->

# パート2

これで、削除するディレクトリを選択する準備が整いました。

ファイルシステムで利用できる合計ディスク容量は**70,000,000**です。
アップデートを実行するには、少なくとも**30,000,000**の空き使用容量が必要です。
アップデートを実行するのに**十分なスペースを解放する**、削除できるディレクトリを見つける必要があります。

上の例では、最も外側のディレクトリの合計サイズ（すなわち使用済み領域の合計）は48381165です。
これは、現在の空き容量が21618835であることを意味しますが、
これはアップデートに必要とされる30000000に足りません。
従って、更新を実行するには、合計サイズが8381165以上のディレクトリをひとつ削除する必要があります。

これを実現するには、次の選択肢があります。

- ディレクトリ `e` を削除すると、未使用領域が584だけ増えます。
- ディレクトリ `a` を削除すると、未使用領域が94853だけ増えます。
- ディレクトリ `d` を削除すると、未使用領域が24933642だけ増えます。
- ディレクトリ `/` を削除すると、未使用領域が48381165だけ増えます。

ディレクトリ`e`と`a`はどちらも小さすぎます。
それらを削除しても、十分なスペースが解放されません。
一方、ディレクトリ`d`とディレクトリ`/`はどちらも十分に大きいです。
これらの中から、最小の`d`を選択し、未使用スペースを24933642だけ増やします。

削除した場合に、
アップデートを実行するのに十分なスペースをファイルシステム上で解放する
最小のディレクトリを見つけます。
**そのディレクトリの合計サイズはどれだけですか？**

<!--
<details><summary>解説</summary><div>

間接的に含むものも入れた、各ディレクトリの容量マップは上で作った。
そのマップにおいて、`/` すなわち `[] :: [String]` に割り当てられた値が現在の総使用量。
\\(70,000,000 - root の使用量 + 解放容量 \geq 30,000,000\\)
すなわち
\\(解放容量 \geq rootの使用量 - 40,000,000\\)
を満たす最小の容量をマップから探す。

```haskell
main2 = body2 "input.txt"

body2 fn = do
  m <- accumlate . parseFile . lines <$> readFile fn
  let limit = m M.! [] - 40000000
  print . minimum . filter (limit <=) . M.elems $m
```

</div></details>
-->
