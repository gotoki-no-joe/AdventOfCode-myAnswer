# 13日目: 救難信号

編集中

<!--
丘を登り、再びエルフとの接触を試みます。ただし、代わりに、予期していなかった信号を受信します:救難信号です。

ハンドヘルド デバイスはまだ正常に動作していないはずです。遭難信号からのパケットが順不同でデコードされました。メッセージをデコードするには、受信したパケット (パズルの入力) のリストを並べ替える必要があります。

リストはパケットのペアで構成されています。ペアは空白行で区切られます。正しい順序になっているパケットのペアの数を特定する必要があります。

例えば：

[1,1,3,1,1]
[1,1,5,1,1]

[[1],[2,3,4]]
[[1],4]

[9]
[[8,7,6]]

[[4,4],4,4]
[[4,4],4,4,4]

[7,7,7,7]
[7,7,7]

[]
[3]

[[[]]]
[[]]

[1,[2,[3,[4,[5,6,7]]]],8,9]
[1,[2,[3,[4,[5,6,0]]]],8,9]
パケット データは、リストと整数で構成されます。各リストは で始まり[、 で終わり]、0 個以上のカンマ区切りの値 (整数またはその他のリスト) を含みます。各パケットは常にリストであり、それぞれの行に表示されます。

2 つの値を比較する場合、最初の値はleftと呼ばれ、2 番目の値はrightと呼ばれます。それで：

両方の値が integer の場合、小さい方の整数が最初に来る必要があります。左の整数が右の整数より小さい場合、入力は正しい順序になります。左の整数が右の整数より大きい場合、入力は正しい順序ではありません。それ以外の場合、入力は同じ整数です。入力の次の部分のチェックを続けます。
両方の値がリストである場合は、各リストの最初の値を比較し、次に 2 番目の値を比較します。左側のリストが最初に項目を使い果たした場合、入力は正しい順序になっています。正しいリストが最初に項目を使い果たした場合、入力は正しい順序ではありません。リストが同じ長さで、比較によって順序が決定されない場合は、入力の次の部分のチェックを続けます。
ちょうど 1 つの値が整数である場合は、その整数を唯一の値として含むリストに整数を変換してから、比較を再試行します。たとえば、[0,0,0]と を比較する場合2、正しい値を[2]( を含むリスト2) に変換します。[0,0,0]代わりにと を比較することで結果が得られます[2]。
これらの規則を使用して、例のどのペアが正しい順序であるかを判断できます。

== Pair 1 ==
- Compare [1,1,3,1,1] vs [1,1,5,1,1]
  - Compare 1 vs 1
  - Compare 1 vs 1
  - Compare 3 vs 5
    - Left side is smaller, so inputs are in the right order

== Pair 2 ==
- Compare [[1],[2,3,4]] vs [[1],4]
  - Compare [1] vs [1]
    - Compare 1 vs 1
  - Compare [2,3,4] vs 4
    - Mixed types; convert right to [4] and retry comparison
    - Compare [2,3,4] vs [4]
      - Compare 2 vs 4
        - Left side is smaller, so inputs are in the right order

== Pair 3 ==
- Compare [9] vs [[8,7,6]]
  - Compare 9 vs [8,7,6]
    - Mixed types; convert left to [9] and retry comparison
    - Compare [9] vs [8,7,6]
      - Compare 9 vs 8
        - Right side is smaller, so inputs are not in the right order

== Pair 4 ==
- Compare [[4,4],4,4] vs [[4,4],4,4,4]
  - Compare [4,4] vs [4,4]
    - Compare 4 vs 4
    - Compare 4 vs 4
  - Compare 4 vs 4
  - Compare 4 vs 4
  - Left side ran out of items, so inputs are in the right order

== Pair 5 ==
- Compare [7,7,7,7] vs [7,7,7]
  - Compare 7 vs 7
  - Compare 7 vs 7
  - Compare 7 vs 7
  - Right side ran out of items, so inputs are not in the right order

== Pair 6 ==
- Compare [] vs [3]
  - Left side ran out of items, so inputs are in the right order

== Pair 7 ==
- Compare [[[]]] vs [[]]
  - Compare [[]] vs []
    - Right side ran out of items, so inputs are not in the right order

== Pair 8 ==
- Compare [1,[2,[3,[4,[5,6,7]]]],8,9] vs [1,[2,[3,[4,[5,6,0]]]],8,9]
  - Compare 1 vs 1
  - Compare [2,[3,[4,[5,6,7]]]] vs [2,[3,[4,[5,6,0]]]]
    - Compare 2 vs 2
    - Compare [3,[4,[5,6,7]]] vs [3,[4,[5,6,0]]]
      - Compare 3 vs 3
      - Compare [4,[5,6,7]] vs [4,[5,6,0]]
        - Compare 4 vs 4
        - Compare [5,6,7] vs [5,6,0]
          - Compare 5 vs 5
          - Compare 6 vs 6
          - Compare 7 vs 0
            - Right side is smaller, so inputs are not in the right order
すでに正しい順序になっているペアのインデックスは何ですか? (最初のペアのインデックスは 1、2 番目のペアのインデックスは 2 というように続きます。) 上記の例では、正しい順序のペアは 1、2、4、および 6 です。これらの指数の合計は です13。

どのペアのパケットがすでに正しい順序になっているかを判断します。これらのペアのインデックスの合計は?


- - パート2 - -
あとは、すべてのパケットを正しい順序に並べるだけです。受信したパケットのリストの空白行は無視してください。

遭難信号プロトコルには、2 つの追加の分割パケットを含めることも必要です。

[[2]]
[[6]]
前と同じルールを使用して、すべてのパケット (受信したパケットのリストにあるパケットと 2 つの分割パケット) を正しい順序に編成します。

上記の例では、パケットを正しい順序に並べた結果は次のようになります。

[]
[[]]
[[[]]]
[1,1,3,1,1]
[1,1,5,1,1]
[[1],[2,3,4]]
[1,[2,[3,[4,[5,6,0]]]],8,9]
[1,[2,[3,[4,[5,6,7]]]],8,9]
[[1],4]
[[2]]
[3]
[[4,4],4,4]
[[4,4],4,4,4]
[[6]]
[7,7,7]
[7,7,7,7]
[[8,7,6]]
[9]
その後、分割パケットを見つけます。この救難信号のデコーダー キーを見つけるには、2 つの分割パケットのインデックスを決定し、それらを乗算する必要があります。(最初のパケットはインデックス 1、2 番目のパケットはインデックス 2 など)。この例では、分割パケットは10 番目と14 番目であるため、デコーダ キーは です140。

すべてのパケットを正しい順序に編成します。遭難信号のデコーダキーは何ですか?
-->
