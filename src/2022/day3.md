# 3 日目 : リュックサックの再編成

ある妖精が、ジャングルへの旅の物資を全てのリュックサックに詰め込むという重要な仕事をしています。
残念ながら、その妖精は梱包の指示をまるで無視したので、いくつかの荷物を再配置する必要があります.

各リュックサックには2つの大きな区画があります。
様々な種類の全ての荷物はそれぞれ、2つの区画のいずれかにだけ入れることになっています。
荷造りをした妖精は、リュックサックごとに、同じ種類の荷物はひとつだけという規則に従いませんでした。

妖精は現在各リュックサックに入っている全ての荷物のリストを作成しました（あなたのパズル入力）が、誤りを見つけるためにあなたの助けが必要です。
全ての荷物の種類は、単一の小文字または大文字で識別されます。
 (つまり、`a`と`A`は異なる種類の荷物を指します。）

各リュックサックの荷物のリストは、全て一行の文字列として示されます。
リュックサックの2つの区画には常に同じ数の荷物が入っているため、文字列の前半は最初の区画の荷物を表し、文字列の後半は2番目の区画の荷物を表します。

例えば、次のような、6つのリュックサックの内容のリストがあるとします。

```
vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
```

- 最初のリュックサックには荷物  `vJrwpWtwJgWrhcsFMMfFFhFp` が入っています。
つまり、最初の区画には荷物 `vJrwpWtwJgWr` があり、
2番目の区画には荷物 `hcsFMMfFFhFp` が入っています。
両方の区画に現れている唯一の荷物の種類は小文字 `p` です。
- 2番目のリュックサックの区画には
`jqHRNqRjqzjGDLGL` と `rsFMfFZSrLrFZsSL`
が入っています。
両方の区画に現れている唯一の荷物の種類は大文字 `L` です。
- 3番目のリュックサックの区画には
`PmmdzqPrV` と `vPwwTWBwg`
があり、唯一の共通の種類は大文字 `P` です。
- 4番目のリュックサックの区画は種類 `v` のみを共有しています。
- 5番目のリュックサックの区画は種類 `t` のみを共有しています。
- 6番目のリュックサックの区画は種類 `s` のみを共有しています。

荷物の再配置に優先順位を付けるために、全ての荷物の種類を優先度に変換できます。

- 小文字の荷物種類 `a`～`z` は、優先度 1 から 26 を持ちます。
- 大文字の荷物種類 `A`～`Z` は、優先度 27 から 52 を持ちます。

上記の例では、各リュックサックの両方の区画に現れる荷物種類の優先度は、16 (`p`), 38 (`L`), 42 (`P`), 22 (`v`), 20 (`t`), 19 (`s`) です。
これらの合計は157です。

各リュックサックの両方の区画に現れる荷物の種類を見つけます。**これらの荷物種類の優先度の合計はいくつですか？**

<!--
<details><summary>解説</summary><div>

`Data.List.intersect`で、リストを集合とみなして共通部分を取り出すことができる。

```haskell
import Data.List

main1 = body "input.txt" compute1

body fn cp = readFile fn >>= print . cp . lines

compute1 :: [String] -> Int
compute1 = sum . map func1

func1 :: String -> Int
func1 xs = prio $ head $ intersect as bs
  where
    (as,bs) = splitAt (div (length xs) 2) xs

-- 優先度
prio c
  | c <= 'Z'  = fromEnum c - fromEnum 'A' + 27
  | otherwise = fromEnum c - fromEnum 'a' + 1
```

</div></details>
-->

# パート2

入れ間違えた荷物の特定が完了すると、妖精が別の問題を抱えてやってきます。

安全のため、妖精は3人ずつグループに分けられます。
全ての妖精はグループを識別するバッジを持っています。
効率のために、3人の妖精の各グループ内で、バッジは**その妖精3人ともが共通して持つ唯一の荷物の種類**です。
つまり、グループのバッジが種類`B`の場合、3人の妖精はみなリュックサックのどこかに種類`B`の荷物を持ち、
そしてそれ以外の種類の荷物は多くて2人までしかそれを持っていません。
（訳注：3人共通の種類はひとつに定まる、ということ。）

問題は、誰かがバッジに今年更新された証紙シールを貼り付け忘れたことです。
新しい証紙シールを貼り付けるために、全てのバッジをリュックサックから取り出す必要があります。

さらに、各グループのバッジに対応する荷物の種類を誰も書き留めていませんでした。
どの荷物種類が正解かを判断する唯一の方法は、各グループの3人の妖精全てに共通する1つの荷物種類を見つけることです。

リスト内の3行ずつの各組は1つのグループに対応しますが、各グループは異なるバッジの荷物種類を持つことができます。
したがって、上記の例では、最初のグループのリュックサックは最初の3行です。

```
vJrwpWtwJgWrhcsFMMfFFhFp
jqHRNqRjqzjGDLGLrsFMfFZSrLrFZsSL
PmmdzqPrVvPwwTWBwg
```

2番目のグループのリュックサックはその次の3行です。

```
wMqvLMZHhHMvwLHjbvcjnnSBnvTQFn
ttgJtRGJQctTZtZT
CrZsJsPPZsGzwwsLwLmpwMDw
```

最初のグループでは、3つのリュックサックすべてに現れる唯一の荷物種類は小文字 `r` です。
これが彼らのバッジに違いありません。
2番目のグループでは、バッジの荷物種類は `Z` です。

これらの荷物の優先順位は、証紙シール貼り付け作業を計画するために引き続き調べる必要があります。
ここでは、最初のグループは 18 (`r`)、2番目のグループは 52 (`Z`) です。
これらの合計は70です。

妖精の3人グループそれぞれについて、バッジに対応する荷物種類を見つけます。
**これらの荷物種類の優先度の合計はいくつですか？**

<!--
<details><summary>解説</summary><div>

3人グループのリストに対して、`intersect`を2度使えば共通の要素が取り出せる。

```haskell
import Data.List.Split

main2 = body "input.txt" compute2

compute2 :: [String] -> Int
compute2 = sum . map func2 . chunksOf 3

func2 :: [String] -> Int
func2 = prio . head . foldl1 intersect
```

</div></details>
-->
