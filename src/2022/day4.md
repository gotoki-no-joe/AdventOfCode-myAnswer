# 4 日目 : キャンプの後片付け

船から最後の物資を降ろす前に、場所を空ける必要があります。
そのため、数人の小人がキャンプの区画を片付ける仕事を割り当てられています。
全ての区画には一意の**ID番号**があり、小人にはそれぞれ区画IDの範囲がひとつずつ割り当てられています。

ところが、ある小人が区画の割り当てを互いに見比べたところ、
割り当ての多くに**重複がある**ことに気付きました。
重複をすばやく見つけて無駄な作業を減らすために、小人たちは二人一組になり、
**それぞれの組の割り当て区画の大きなリスト**（パズル入力）を作成します。

例えば、次の区画割り当て対のリストを考えてみましょう：

```
2-4,6-8
2-3,4-5
5-7,7-9
2-8,3-7
6-6,4-6
2-6,4-8
```

最初の数個の対について、このリストの意味を説明します：

- 最初の小人の組では、最初の小人には区画2-4（区画2,3,4）が割り当てられ、
2番目の小人には区画6-8（区画6,7,8）が割り当てられました。
- 2番目の小人の組には、それぞれ2つの区画が割り当てられました。
- 3番目の小人の組には、それぞれ3つの区画が割り当てられました。
一人は区画5,6,7で、もう一方は同じく7と、あと8,9です。

このリストの例では、図示しやすいように1桁の区画IDを使用しています。
実際のリストにはもっと大きな数が含まれている可能性があります。
これらの区画割り当ての対は、視覚的には次のようになります。

```
.234.....  2-4
.....678.  6-8

.23......  2-3
...45....  4-5

....567..  5-7
......789  7-9

.2345678.  2-8
..34567..  3-7

.....6...  6-6
...456...  4-6

.23456...  2-6
...45678.  4-8
```

一部の組は、彼らの割り当ての一方が他方を**完全に含んでいる**ことに気付きました。
例えば、`2-8`は`3-7`を完全に含んでおり、`6-6`は`4-6`に完全に含まれています。

一方の割り当てがもう一方の割り当てを完全に含む組では、組の小人の一人は、
相棒が既に清掃している区画だけを清掃するため、これらは最も再検討が必要と思われます。
この例では、そのような組が2組あります。

**一人の範囲がもう一人の範囲に完全に含まれる割り当ての組はいくつありますか？**

<!--
<details><summary>解説</summary><div>

一行にある4つの数を順に \\(a,b,c,d\\) と呼ぶことにする。
データに矛盾がないこと、すなわち\\(a \leq b, c \leq d\\)は満たされていると仮定する。

行を読み取るのには、数字の並びの部分だけを抽出する必要がある。
次に出現する数字でない文字が固定なので、それを用いて取り出すのが簡易。

```haskell
import Data.List

parse :: String -> (Int,Int,Int,Int)
parse xs0 = (read as, read bs, read cs, read ds)
  where
    (as,_:xs1) = span ('-' /=) xs0
    (bs,_:xs2) = span (',' /=) xs1
    (cs,_:ds ) = span ('-' /=) xs2
```

完全に重なっているとは、\\(a \leq c \land d \leq b\\) または
\\(c \leq a \land b \leq d\\) である。
これを満たしている行の数を数える。

```haskell
prop1 (a,b,c,d) = a <= c && d <= b || c <= a && b <= d

main1 = readFile "input.txt" >>= print . length . filter prop1 . map parse . lines
```

</div></details>
-->

# パート2

まだかなりの重複作業が予定されているようです。
代わりに、小人たちは重なりがある組のの数を知りたがっています。

上記の例では、最初の2つの組（`2-4,6-8`と`2-3,4-5`）は重なりませんが、
残りの4つ組（`5-7,7-9`, `2-8,3-7`, `6-6,4-6`, `2-6,4-8)）は重なります。

- `5-7,7-9` は単一の区画`7`が重複しています。
- `2-8,3-7` は`3`から`7`までの全ての区画で重なっています。
- `6-6,4-6` 単一の区画`6`で重なっています。
- `2-6,4-8` は区画`4`,`5`,`6`で重なっています。

したがって、この例では、重なりのある割り当て組のの数は4です。

**範囲が重複する割り当て組はいくつありますか？**

<!--
<details><summary>解説</summary><div>

逆に、重複が**ない**とは、\\(b < c\\) または \\(d < a\\) が満たされることである。
これをそのまま書いてもいいし、ド・モルガンの法則を用いて
\\(\neg (b < c \lor d < a) = b \geq c \land d \geq a\\)
としてもよい。

```haskell
prop2 (a,b,c,d) = not (b < c || d < a)

main2 = readFile "input.txt" >>= print . length . filter prop2 . map parse . lines
```

</div></details>
-->
