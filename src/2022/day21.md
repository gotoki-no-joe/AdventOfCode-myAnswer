# 21 日目: サルの算数

[サル](./day11.md)が戻ってきました！
あなたは、サルがまたあなたの持ち物を盗もうとするのではないかと心配になりますが、
彼らはただ自分たちの縄張りを守るために、
さまざまな猿の声をあなたに浴びせているだけのようです。
<!--
hold one's ground 自分の立場を守る, (反対などに対して)一歩も引かない.
という訳語があるが、ここはそういう成句ではない感じ。
-->

最終的に、象の1頭が、あなたが猿の言葉を話さないことに気づき、通訳をしにやってきます。
彼らはあなたが果樹園を見つけようとしていると話しているのを耳にした、ということがわかりました。
サルの出す**なぞなぞ**に答えられれば、近道を教えてくれるそうです。

それぞれのサルに、役割が与えられました。
それは、**特定の数字叫ぶ**か、**数学演算の結果を叫ぶ**かのどちらかです。
数を叫ぶサルはすべて、最初から自分の数を知っています。
しかし、算術演算のサルは、他の2匹のサルが数を叫ぶのを待つ必要があり、
その2匹のサルも**また**他のサルを待っている可能性があります。

あなたの仕事は、サルが自分で答えを見つける前に、
**`root`という名前のサルが叫ぶ数を算出する**ことです。

例えば：

```
root: pppw + sjmn
dbpl: 5
cczh: sllz + lgvd
zczc: 2
ptdq: humn - dvpt
dvpt: 3
lfqf: 4
humn: 5
ljgn: 2
sjmn: drzm * dbpl
sllz: 4
pppw: cczh / lfqf
lgvd: ljgn * ptdq
drzm: hmdt - zczc
hmdt: 32
```

各行は、サルの名前、コロン、そしてそのサルの役割が書いてあります。

- 数ひとつだけが書かれているとき、そのサルの役割は単にその数を叫ぶことです。
- `aaaa + bbbb` のような役割は、サル`aaaa`とサル`bbbb`が自分の数を叫ぶのを待って、
それら二つの数の和を叫ぶことを意味します。
- `aaaa - bbbb` は、サル`aaaa`の数引く`bbbb`の数を叫ぶことを意味します。
- 役割 `aaaa * bbbb` は`aaaa`の数に`bbbb`の数を掛けたものを叫びます。
- 役割 `aaaa / bbbb` は`aaaa`の数を`bbbb`の数で割った値を叫びます。（訳注：端数切り捨て）

したがって、上記の例では、サル `drzm` はサル `hmdt` と `zczc` がそれぞれの数を叫ぶのを待つ必要があります。
幸いなことに、`hmdt` と `zczc` は共に単に数を叫ぶだけの役割を持っているので、
即座にそれをします。`32` と `2` です。
そしてサル `drzm` は `32` から `2` を引くことで、自分の数 `30` を叫ぶことができます。

すると、サル `sjmn` はその数のひとつ（`drzm` からの `30`）を持ち、
またもうひとつの数（`5dbpl` からの `5`）を既に持っています。
`30` に `5` を掛けることで、自分の数 `150` を叫ぶことができます。

この手順は `root` が数 `152` を叫ぶまで続きます。

ただし、あなたの実際の状況には、かなり多くのサルが関係しています。
**サル `root` が叫ぶ数はいくつでしょう？**

<details><summary>解説</summary><div>

遅延評価を活かして、サルの名前をキー、叫ぶ数を値とする`Map`を構成する。
計算をするサルは、依存するサルの叫ぶ値を、その`Map`を介して受け取る。

```haskell
import qualified Data.Map as M

compute1 :: String -> Int
compute1 co = m M.! "root"
  where
    m = M.fromList $ map (parse . words) $ lines co
    parse [key, num] = (init key, read num)
    parse [key, m1, op:_, m2] = (init key, funof op (m M.! m1) (m M.! m2))

funof '+' = (+)
funof '-' = (-)
funof '*' = (*)
funof '/' = div

test1 = readFile  "test.txt" >>= print . compute1
main1 = readFile "input.txt" >>= print . compute1
```

</div></details>

# パート2

サル→ゾウ→人間の間の何らかの誤訳のせいで、なぞなぞのいくつかの重要な詳細を誤解しているようです。

第一に、あなたは `root` という名前のサルの任務を間違えました。
具体的には、間違った算術演算と受け取りました。
サル `root` の正しい動作は `=` です。
これは、やはり2つの数を（前と同じ2匹のサルから）聞きますが、
2つの数が**一致する**かどうかを確認することを意味します。

第二に、あなたは `humn` から始まる任務の行について、間違ったサルを割り当てました。
それはサルではありません ー **あなた**です。
実際のところ、あなた自身の任務も間違えました。
`root` の同値性判定に合格するには、**あなたがどの数を叫ぶ**必要があるかを見つけ出す必要があります。
（あなたの入力の `humn:` の続きにある数は、今や無意味です。）

上の例では、`root` の同値性判定に合格するために叫ばなければならない数は`301`です。
（これにより、`root` は両方のサルから同じ数 `150` を得ます。）

**`root`の同値性判定に合格するために、あなたはどんな数を叫びますか？**

<details><summary>解説</summary><div>
解説

パート1では、木の根 `root` の方から、親ノードが子ノードの名前を知っていて、その値を取得していた。

パート2では、`humn` を根として、`humn`から`root`までの経路は今までと辿る向きおよび計算を逆向きにして、
`root`の両辺が等しい値になるために、`humn`側の子がとるべき値を求める計算を、`humn` まで繋げる。
そのため、二分木の全ての方向について、ノードの値を求められる必要がある。

例えば、一つの式 `one: two + three` は、全ての方向から見たときのそのノードのとる（べき）値を定義している。
`root` を根とした木で、`one`の親を `parent` とするとき、

|向き| | | | |
|---|---|---|---|---|
|上から|oneをparentから見た値は|twoをoneから見た値 |＋| threeをoneから見た値|
|左下から|oneをtwoから見た値は|parentをoneから見たの値 |ー| threeをoneから見た値|
|右下から|oneをthreeから見たの値は|parentをoneから見た値 |ー| twoをoneから見たの値|

となる。他の演算についても同様である。また `root` に関しては、`root: left = right` としたとき（演算子は無視する）

|向き| | |
|---|---|---|
|左下から|rootをleftから見た値は|rightをrootから見たの値 |
|右下から|rootをrightから見た値は|leftをrootから見たの値 |

とすればよい。

これを実現するために、パート1での`Map`のキーを、サルの名前に加えて、誰から見たときか、で拡張する。
なお、数を叫ぶ任務のサルは親からしか参照されることはない。
このとき、任務の定義 `one: two + three`, `four: 5` を見ただけでは、`parent` の名前がわからないので、
それを先に取り出しておく。

```haskell
compute2 :: String -> Int
compute2 co = m M.! (parent M.! "humn", "humn")
  where
    wls = map words $ lines co
    parent = M.fromList $ concatMap parseParent wls
    parseParent [key, m1, _, m2] = [(m1, init key),(m2, init key)]
    parseParent _ = []
-- m M.! (w,wFrom) : wをwFromから見たときの値
    m = M.fromList $ concatMap parse wls
    parse (w:ws) =
      case ws of
        [num] -> [((w1,wP), read num)]
        [wL,_,wR] | w1 == "root" -> [((w1,wL), m M.! (wR,w1)),((w1,wR), m M.! (wL,w1))]
        [wL,'+':_,wR] -> [((w1,wP), m M.! (wL,w1) + m M.! (wR,w1))
                         ,((w1,wL), m M.! (wP,w1) - m M.! (wR,w1))        -- w1(wL) = wP - wR
                         ,((w1,wR), m M.! (wP,w1) - m M.! (wL,w1))]       -- w1(wR) = wP - wL
        [wL,'-':_,wR] -> [((w1,wP), m M.! (wL,w1) - m M.! (wR,w1))
                         ,((w1,wL), m M.! (wP,w1) + m M.! (wR,w1))        -- w1(wL) = wP + wR
                         ,((w1,wR), m M.! (wL,w1) - m M.! (wP,w1))]       -- w1(wR) = wL - wP
        [wL,'*':_,wR] -> [((w1,wP), m M.! (wL,w1) * m M.! (wR,w1))
                         ,((w1,wL), m M.! (wP,w1) `div` m M.! (wR,w1))    -- w1(wL) = wP / wR
                         ,((w1,wR), m M.! (wP,w1) `div` m M.! (wL,w1))]   -- w1(wR) = wP / wL
        [wL,'/':_,wR] -> [((w1,wP), m M.! (wL,w1) `div` m M.! (wR,w1))
                         ,((w1,wL), m M.! (wP,w1) * m M.! (wR,w1))        -- w1(wL) = wP * wR
                         ,((w1,wR), m M.! (wL,w1) `div` m M.! (wP,w1))]   -- w1(wR) = wL / wP
        _ -> error $ "never" ++ show (w:ws)
      where
        w1 = init w
        wP = parent M.! w1
    parse _ = error "never"
```

このコードが求めた値が正解と無事に判定されたが、少し疑問が残る。

割り算が切り捨てで考えられているため、切り捨てられる分について誤差が許容され、答えが一意に定まらない可能性がある。

- \\(2 = X / 3\\) は \\(X=6\\) だけでなく \\(X =7, 8\\) でも成り立つ。  
一般に \\(A = X / B\\) は \\(AB \leq X < AB+B\\) で成り立つ。
- \\(2 = 8 / Y\\) は \\(Y=4\\) だけでなく \\(Y = 3\\) でも成り立つ。  
一般に \\(A = B / X\\) は、最小の \\(X\\) は \\(AX + X - 1 = B\\) より \\(X \geq \frac{B+1}{A+1}\\),
最大の\\(X\\)は\\(AX=B\\)より\\(X \leq \frac{B}{A}\\),
まとめると\\(\lceil \frac{B+1}{A+1} \rceil \leq X \leq \lfloor \frac{B}{A} \rfloor\\)
（こちらはあまり揺れないということか。）

掛け算の逆で割り算をするとき、計算が合わなくなる恐れがある。

- \\(8 = X * 3\\) をナイーブに \\(X = 8/3 = 2\\) とやると誤り。これを満たす整数 \\(X\\) は存在しない。  
一般に、\\(A = X * B\\) は、\\(A \bmod B = 0\\) のときに限り \\(X = A / B\\) である。

可能性のある値を集合で持つカスタム版を作成して実験してみる…
と、例について `[301, 302]` となった。301が本文に示された答え。
そして302でも確かに計算は合う。

本問題について `[3740214169961,3740214169962,3740214169963,3740214169964]` と
4つも答えが出てきた。これらを答えたらどうなったんだろう。
</div></details>
