# 8日目: 樹上の木の家

遠征隊は、格子状に注意深く植えられた背の高い木の独特の区画に出くわします。
小人たちは、以前の遠征で、森林再生の取り組みとしてこれらの木を植えたと説明しています。
今、彼らはこれがツリーハウスに適した場所であるかどうかに興味を持っています.

まず、ツリーハウスを**隠す**のに十分な樹木がここにあるかどうかを判断します。
これを行うには、行または列に沿ってまっすぐ見たときに、**グリッドの外側から見える**木の数を数える必要があります。

小人は既に[ドローン](https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AF%E3%83%83%E3%83%89%E3%83%AD%E3%83%BC%E3%82%BF%E3%83%BC)を発進させ、
それぞれの木の高さの地図を生成しています（パズル入力）。例えば：

```
30373
25512
65332
33549
35390
```

それぞれの木は数字1文字で表されます。その値が木の高さです。
ここで`0`は最も短く、`9`が最も高いです。

ひとつの木に関して、その木とグリッドの外周までの間にある他の全ての木がその木**よりも低い**とき、
その木は**外から見える**状態です。
同じ行または列にある木のみを考慮します。
つまり、その木から上、下、左、右だけを見てください。

グリッドの端にある全ての木は**見えます**。
これらはすでに端にあるため、視界を遮る木はありません。
この例では、これにより考慮すべき木として**内部の9本**のみが残ります。

- 左上の`5`は左と上から**見えます**。
（右や下からは見えません、途中に高さ`5`の他の木があるからです。）
- 上中央の`5`は上と右から見えます。
- 右上の`1`はどの方向からも見えません。
それが見えるようにするには、それと外周までの間は高さ0の木だけでないといけません。
- 左中央の`5`は**見えます**が、右からのみです。
- 中心の`3`はどの方向からも見えません。
それが見えるようにするには、それと外周までの間は高さ2以下の木だけでないといけません。
- 右中央の3は右から**見えます**。
- 一番下の行では、中央の5は**見えます**が、3と4は見えません。

端にある16本の木が見え、その他に内部にある木の5本が見えるので、
この配置では合計で21本の木が見えます。

あなたの地図について考えてください。
**グリッドの外から見える木は何本ありますか？**

<!--
<details><summary>解説</summary><div>

地図データを読み込んだら、行ごとに分け、地図の高さと幅も数えておく。

```haskell
dss <- lines <$> readFile "input.txt"
let h = length dss
let w = length $ head dss
```

ひとつの方向から見たときの木の高さの列があるとき、
前から順にそれらが見えるかどうかを判定するには、
手前までの最大値よりも自分が高いかどうかを比較すればよい。
ただし先頭については、それより手前の最大値が求められない点に注意する。

```haskell
check :: Ord a => [a] -> [Bool]
check xs = True : zipWith (<>) (scanl1 max xs) (tail xs)
```

`dss`に対して、
それぞれに`check`をそのまま適用すると左から、`reverse`してから適用すると右から、
`transpose`した結果へそれぞれに適用すると上から、さらに`reverse`すると下から、
見えるかどうかの判定結果が得られる。

木のそれぞれがいずれかの方向から見えるかどうかは、
この4方向からの結果のいずれかで見えればよいので、
`accumArray`でこれを足し合わせて数える。

```haskell
tdss = transpose dss
arr = accumArray (||) False ((1,1),(h,w)) $
  [((i,j), True) | (i,ds) <- zip [1..] dss , (j,True) <- zip [1..] (check ds)] ++
  [((i,j), True) | (i,ds) <- zip [1..] dss , (j,True) <- zip [w, pred w..] (check $ reverse ds)] ++
  [((i,j), True) | (j,ds) <- zip [1..] tdss, (i,True) <- zip [1..] (check ds)] ++
  [((i,j), True) | (j,ds) <- zip [1..] tdss, (i,True) <- zip [h, pred h..] (check $ reverse ds)]
```

この配列の中の `True` の個数が答えである。

```haskell
length . filter id . elems $ arr
```

</div></details>
-->

# パート2

視界を覆う木の量に満足している小人たちは、ツリーハウスを建てるのに最適な場所だけが知りたいです。
彼らはたくさんの**木**を見たいと思っています。

ひとつの木に対して、そこからの見通しを測定するには、その木から上、下、左、右を見ます。
外周に到達した場合、または対象の木と同じ高さまたはそれよりも高い最初の木に到達した場合に停止します。
（木が端にある場合、少なくとも1つの見通しは零になります。）

小人たちは、上記の規則で見つかったものよりも背の高い遠くの木を気にしません。
提案されたツリーハウスには、乾燥を保つために大きな「ひさし」が付いているため、
いずれにせよツリーハウスより高いところを見ることはできません。

上の例で、2 行目中央の`5`を考えてみましょう：

```
30 3 73
25[5]12
65 3 32
33 5 49
35 3 90
```

- 見上げると、その視界は遮られていません。それは（高さ3の）1本の木を見ることができます。
- 左を見ると、その視界はすぐに遮られます。木は1本（高さ5、すぐ隣）のみを見ることができます。
- 右を見ると、その視界は遮られていません。木が2本見えます。
- 見下ろすと、その視界は最終的に遮られます。
2本の木を見ることができます（高さ3が1本、次に視界を遮る高さ5の木）。

木の**景観スコア**は、4つの方向のそれぞれの見通しを**掛け合わせる**ことによって求められます。
この木の場合、その値は4（\\(1 \times 1 \times 2 \times 2\\)の掛け算により求められます）です。

しかし、もっとうまくやることができます：
4行目の真ん中にある高さ5の木を考えてみましょう：

```
30 3 73
25 5 12
65 3 32
33[5]49
35 3 90
```

- 見上げると、その視界は2本めの木で遮られています（高さ5の別の木によって）。
- 左を見ると、その視界は遮られていません。2本の木が見えます。
- 見下ろしても、視界も遮られません。1本の木が見えます。
- 右を見ると、その視界は2本めの木で遮られています (高さ9の巨木によって）。

この木の景観スコアは8 \\((2 \times 2 \times 1 \times 2)\\) です。
ここがツリーハウスの理想の場所です。

マップ上のそれぞれの木を調べてください。
**いずれかの木で達成される最大の景観スコアはいくつですか？**

<!--
<details><summary>解説</summary><div>

ある木から外周までの高さの列があるとき、その方向の見通しは、
その高さ以上になるまでの木の本数であるが、視界を遮ったその木も数える。
しかし、外周まで遮られずに視界が達したとき、数える木がないので、この二つを区別する必要がある。

```haskell
viewscore (x:xs) =
  case span (x >) xs of
    (as,[ ]) -> length as
    (as,_:_) -> succ $ length as
```

`reverse`を高速化するテクニックで、要素をひとつずつ移動させる内部関数を立てた。

```haskell
reverse xs = rev [] xs
  where
    rev ys [] = ys
    rev ys (x:xs) = rev (x:ys) xs
```

これと同様にして、一列の木の並びに対して、全ての木のそこから右とそこから左の見通しを同時に計算できる。

```haskell
part2sub ys [] = []
part2sub ys (x:xs) = viewscore ys * viewscore xs : part2sub (x:ys) xs
  where
    count zs = case span (x >) zs of
      (as,[]) -> length as
      (as,_ ) -> succ $ length as
```

あとは、全ての行と、パート1同様に`transpose`を用いて全ての列についてこれを行い、
結果を掛け合わせて最大値を見つける。

```haskell
part2 h w dss = maximumBy (compare `on` snd) . assocs $ arr
  where
    tdss = transpose dss
    arr = accumArray (*) 1 ((1,1),(h,w)) $
      [((i,j), s) | (i,ds) <- zip [1..] dss , (j,s) <- zip [1..] $ part2sub [] ds] ++
      [((i,j), s) | (j,ds) <- zip [1..] tdss, (i,s) <- zip [1..] $ part2sub [] ds]
```

</div></details>
-->
