{-
これDPでも数が足らなくねぇか？どうなってんだ。

type State = ((Score, Pos), (Score, Pos))

スコアは最大で+10されるので、0から20までと21以上？を管理する必要がある。
Posは1から10までの全ての組み合わせで100とおり。
ダイスは3面なので、1から3が出るのを3回振るので、3から9までが結果だけど、
和が同じでもuniverseの数は異なるから、それを数えないといけない。
1 1 1 : 3
1 1 2, 1 2 1, 2 1 1 : 4
1 2 2, 2 1 2, 2 2 1, 1 1 3, 1 3 1, 3 1 1 : 5
1 2 3, 1 3 2, 2 1 3, 2 3 1, 3 1 2, 3 2 1, 2 2 2 : 6
2 2 3, 2 3 2, 3 2 2, 3 3 1, 3 1 3, 1 3 3 : 7
3 3 2, 3 2 3, 2 3 3 : 8
3 3 3 : 9

初期位置 4 8 について、((0,4),(0,8)) な世界は1つ。
そこから27とおりの世界に分岐して、状態*場合の数 を記録して交代する。
決着がついた状態は破棄して、前向きにやっていくと、同じ状態について何度も計算するはめになる。

スコアは単調増加するから、スコアの少ない状態から消化していけば一回だけで作れるような気もするが。

全てを別にするのはなんか勿体ない気がする。位置かスコアかのどちらかを軸にして、もう一つは従属させて、一度に状態を配りたい。
位置をメインにすると、次の位置の分布は明確だから配りやすいけど、スコアは不明瞭だから無理っぽい。

スコアをメインにすると、次のスコアは明確で、それぞれのスコアに関して位置の可能性をばらまくことになる。
毎回、スコアは1～10だけ増えるから、それらが全て確定した（あるいは存在しない）状態について、状態を確定させていくことができる。
これ結局、全ての状態要素をインデックスにすると言っているだけかも？

-}

import Data.Array

main2 p1 p2 = arr
  where
    arr = array ((1,0,0,1,1),(2,30,30,10,10))
          [((side,sc1,sc2,p1,p2), f side sc1 sc2 p1 p2) | side <- [1,2], sc1 <- [0..30], sc2 <- [0..30], p1 <- [1..10], p2 <- [1..10]]
    f _ _ _ _ _ = 0
