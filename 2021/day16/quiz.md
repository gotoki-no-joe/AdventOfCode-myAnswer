# 16日目：パケットデコーダ #

洞窟を出て開けた海中に出ると、母船にいる妖精からの通信が届きます。

通信は、数式をビット列に符号化する方法である
浮力交換送信システム (Buoyancy Interchange Transmission System, BITS) を使用して送信されました。
潜水艦のコンピュータは、通信を16進数で保存しました（パズル入力）。

メッセージを復号する最初のステップは、16進数を2進数に変換することです。
16進数の各文字は、4ビットの2進数データに対応します。

```
0 = 0000
1 = 0001
2 = 0010
3 = 0011
4 = 0100
5 = 0101
6 = 0110
7 = 0111
8 = 1000
9 = 1001
A = 1010
B = 1011
C = 1100
D = 1101
E = 1110
F = 1111
```

BITS通信文の最外層は単一の**パケット**からなり、その中に他の多くのパケットが含まれます。
このパケットの16進表現は、末尾にいくつかの余計なビット0を伴う場合があります。
これらは通信文の一部ではないため、無視する必要があります。

すべてのパケットは標準ヘッダで始まります。
最初の3ビットはパケット**バージョン**を符号化し、
次の3ビットはパケット**タイプID**を符号化しています。
これらの2つの値は数値です。
パケットの中で符号化された数値はすべて、
最上位ビットを先にして2進数として表されます。
たとえば、ビット列 `100` と符号化されたバージョンは、数値4を表します。

タイプIDが4であるパケットは、**リテラル値**を表します。
リテラル値パケットは、単一の2進数を符号化しています。
符号化はまず、2進数をその長さが4ビットの倍数になるまで先行するゼロを追加し、
その後、4ビットのグループに分割されます。
各グループには1ビットの接頭辞が付けられていて、
最後のグループは0、それ以外のグループは1です。
これらの5ビットのグループはパケットヘッダの直後に続きます。
たとえば、16進文字列 `D2FE28` は次のようになります。

```
110100101111111000101000
VVVTTTAAAAABBBBBCCCCC
```

各ビットの下には、その目的を示すラベルがあります。

- `V` のラベルが付いた3ビット (110) は、パケットバージョン6を表します。
- `T` のラベルが付いた3ビット (100) はパケットタイプIDであり、その値4はパケットがリテラル値であることを意味します。
- `A` のラベルが付いた5ビット (10111) は1で始まり（最後のグループではないので読み続けよ、の意味）、数値の最初の4ビット 0111 を持ちます。
- `B` のラベルが付いた5ビット (11110) は1で始まり（最後のグループではないので読み続けよ、の意味）、数値の続きの4ビット 1110 を持ちます。
- `C` のラベルが付いた5ビット (00101) は0で始まり（最後のグループ、パケットの終わりの意味）、数値の最後の4ビット 0101 を持ちます。
- 最後のラベルのない3つのビット0は、16進表現のための追加であり、無視する必要があります。

したがってこのパケットは、2進表現で `011111100101`、
10進数で 2021 のリテラル値を表します。

他のすべてのタイプのパケット（タイプIDが4以外のパケット）は**演算子**を表し、
その中に含まれる1つ以上のサブパケットに対して何らかの計算を実行します。
今は、その演算の内容は重要ではありません。
サブパケットの階層の読み取りに焦点を当てます。

演算子パケットには、1つ以上のパケットが含まれます。
後続のどのバイナリデータがそのサブパケットを表すかを示すために、
演算子パケットは、パケットヘッダの直後のビットで示される2つのモードのいずれかを使用できます。
これは**長さタイプID**と呼ばれます：

- 長さタイプIDが0の場合、続く15ビットは、このパケットに含まれるサブパケットの**ビット単位の全長**を表す数値です。
- 長さタイプIDが1の場合、続く11ビットは、このパケットに**直接含まれるサブパケットの個数**を表す数値です。

最後に、長さタイプIDビットと15ビットまたは11ビットフィールドの後に、サブパケットが現われます。

たとえば、長さタイプIDが0で2つのサブパケットを含む演算子パケット（16進表記で `38006F45291200` ）を示します。

```
00111000000000000110111101000101001010010001001000000000
VVVTTTILLLLLLLLLLLLLLLAAAAAAAAAAABBBBBBBBBBBBBBBB
```

- `V` のラベルが付いた3ビット (001) は、パケットバージョン=1です。
- `T` のラベルが付いた3ビット (110) はパケットタイプID=6であり、これはパケットが演算子であることを意味します。
- `I` のラベルが付いた1ビット (0) は長さタイプID=0であり、
サブパケットのビット数を表す数値が15ビットの数値であることを示します。
- `L` のラベルが付いた15ビット (000000000011011) には、サブパケットの長さ27がビット単位で含まれています。
- `A` のラベルが付いた11ビットには、最初のサブパケットとして、数値10を表すリテラル値が含まれています。
- `B` のラベルが付いた16ビットには、数値20を表すリテラル値である2番目のサブパケットが含まれています。

サブパケットのデータ11ビットと16ビットを読み取った後、
`L` (27) に示されている全長に達するため、このパケットの読み込みは停止します。

別の例として、
長さタイプIDが1で3つのサブパケットを含む演算子パケット（16進表記で `EE00D40C823060` ）を示します。

```
11101110000000001101010000001100100000100011000001100000
VVVTTTILLLLLLLLLLLAAAAAAAAAAABBBBBBBBBBBCCCCCCCCCCC
```

- `V` のラベルが付いた3ビット (111) は、パケットバージョン=7です。
- `T` のラベルが付いた3ビット (011) はパケットタイプID=3であり、これはパケットが演算子であることを意味します。
- `I` のラベルが付いた1ビット (1) は長さタイプID=1であり、
サブパケットの個数を表す数値が11ビットの数値であることを示します。
- `L` のラベルが付いた15ビット (00000000011) には、サブパケットの個数3が含まれています。
- `A` のラベルが付いた11ビットには、最初のサブパケットとして、数値1を表すリテラル値が含まれています。
- `B` のラベルが付いた11ビットには、数値2を表すリテラル値である2番目のサブパケットが含まれています。
- `C` のラベルが付いた11ビットには、数値3を表すリテラル値である3番目のサブパケットが含まれています。

3つの完全なサブパケットを読み取った後、
`L` (3) に示されているサブパケットの個数に達したため、このパケットの読み込みは停止します。

まずは、通信文全体のパケットの階層を解析し、**すべてのバージョン番号を合計**します。

16進エンコードされた通信文の例をさらにいくつか示します。

- `8A004A801A8002F478` は演算子パケット（バージョン4）を表します。
そこには演算子パケット（バージョン1）が含まれます。
そこには演算子パケット（バージョン5）が含まれます。
そこにはリテラル値（バージョン6）が含まれます。
このパケットのバージョンの合計は16です。
- `620080001611562C8802118E34` は2つのサブパケットを含む演算子パケット（バージョン3）を表します。
各サブパケットは、2つのリテラル値を含む演算子パケットです。
このパケットのバージョンの合計は12です。
- `C0015000016115A2E0802F182340` は前の例と同じ構造をしていますが、
最も外側のパケットは異なる長さのタイプIDを使用します。このパケットのバージョン合計は23です。
- `A0016C880162017C3686B18A3D4780` は
5つのリテラル値を含む演算子パケットを含む演算子パケットを含む演算子パケットです。
そのバージョン合計は31です。

16進表記されたBITS通信文の構造を復号します。
**すべてのパケットのバージョン番号を合計するといくつですか？**

# パート2 #

通信文の構造が復号されたので、それが表す式の値を計算できます。

リテラル値（タイプID 4）は、上記のように単一の数値を表します。
残りのタイプIDはもっと興味深いものです。

- タイプID 0のパケットは**総和**パケットで、その値はサブパケットの値の合計です。
サブパケットが1つしかない場合、その値はサブパケットの値になります。
- タイプID 1のパケットは**積**パケットで、その値はサブパケットの値を乗算した結果です。
サブパケットが1つしかない場合、その値はサブパケットの値になります。
- タイプID 2のパケットは**最小値**パケットで、その値はサブパケットの値の最小値です。
- タイプID 3のパケットは**最大値**パケットで、その値はサブパケットの値の最大値です。
- タイプID 5のパケットは**より大きい**パケットです。
最初のサブパケットの値が2番目のサブパケットの値より大きい場合、その値は1です。それ以外の場合、その値は0です。
これらのパケットには、常にちょうど2つのサブパケットがあります。
- タイプID 6のパケットは**より小さい**パケットです。
最初のサブパケットの値が2番目のサブパケットの値より小さい場合、その値は1です。それ以外の場合、その値は0です。
これらのパケットには、常にちょうど2つのサブパケットがあります。
- タイプID 7のパケットは**等しい**パケットです。
最初のサブパケットの値と2番目のサブパケットの値が等しい場合、その値は1です。それ以外の場合、その値は0です。
これらのパケットには、常にちょうど2つのサブパケットがあります。

これらの規則を使用して、BITS通信文の最も外側のパケットの値を計算できるようになりました。

例えば：

- `C200B40A82` 1と2の和を求めて、結果は値3になります。
- `04005AC33890` 6と9の積を求めて、結果は値54になります。
- `880086C3E88112` 7,8,9の最小値を求めて、結果は7になります。
- `CE00C43D881120` 7,8,9の最大値を求めて、結果は9になります。
- `D8005AC2A8F0` は1になります。5は15より小さいからです。
- `F600BC2D8F` は0になります。5は15より大きくないからです。
- `9C005AC2F8F0` 5と15は等しくないため、0になります。
- `9C0141080250320F1802104A08` 1+3 = 2*2 なので、1になります。

**16進数で符号化されたBITS通信文よって表される式を評価した結果はいくつですか？**
